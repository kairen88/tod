/*
TOD - Trace Oriented Debugger.
Copyright (c) 2006-2008, Guillaume Pothier
All rights reserved.

This program is free software; you can redistribute it and/or 
modify it under the terms of the GNU General Public License 
version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
General Public License for more details.

You should have received a copy of the GNU General Public License 
along with this program; if not, write to the Free Software 
Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
MA 02111-1307 USA

Parts of this work rely on the MD5 algorithm "derived from the 
RSA Data Security, Inc. MD5 Message-Digest Algorithm".
*/
package tod.impl.bci.asm.attributes;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.Attribute;
import org.objectweb.asm.Label;

import tod.impl.database.structure.standard.TagMap;

/**
 * Represents a non-standard code attribute (based on those generated by soot).
 * These attributes permit to assign tags to ranges of bytecode.
 * The binary form is:
 * - one short to indicate the number of entries
 * - each entry is of the form (short pc, V v) where pc represents a 
 * bytecode index and v a value.
 * @see http://pleiad.dcc.uchile.cl/trac/tod/wiki/BytecodeTags
 * @param <V> The type of the value of each entry
 * @author gpothier
 */
public abstract class SootAttribute<V> extends DataAttribute
{
	private Entry<V>[] itsEntries;
	
	public SootAttribute(String aType)
	{
		this(aType, null);
	}
	
	public SootAttribute(String aType, Entry<V>[] aEntries)
	{
		super(aType);
		itsEntries = aEntries;
	}
	
	/**
	 * Fills the given tagmap with information about this attribute's tags.
	 * @param aTagMap The tag map to fill
	 * @param aCodeSize The size of the method's bytecode
	 */
	public void fillTagMap(TagMap aTagMap, int aCodeSize)
	{
		int theCurrentPc = 0;
		V theCurrentValue = null;
		
		for (Entry<V> theEntry : itsEntries)
		{
			int theNextPc = theEntry.label.getOffset();
			if (theCurrentValue != null) fillTagMap(aTagMap, theCurrentPc, theNextPc, theCurrentValue);
			
			theCurrentPc = theNextPc;
			theCurrentValue = theEntry.v;
		}
		
		int theNextPc = aCodeSize;
		if (theCurrentValue != null) fillTagMap(aTagMap, theCurrentPc, theNextPc, theCurrentValue);
	}
	
	/**
	 * Puts the tags corresponding to a given bytecode range in the given tag map.
	 * @param aTagMap The tag map to fill
	 * @param aStart Start of the range
	 * @param aEnd End of the range
	 * @param aValue Value of the Soot tag in the range.
	 */
	protected abstract void fillTagMap(TagMap aTagMap, int aStart, int aEnd, V aValue);
	
	@Override
	public final boolean isCodeAttribute()
	{
		return true;
	}
	
	private Label getLabel(int offset, Label[] labels)
	{
		Label l = labels[offset];
		if (l != null) return l;
		return labels[offset] = new Label();
	}

	/**
	 * Reads a single value from the input stream.
	 */
	protected abstract V readValue(DataInputStream aStream) throws IOException;
	
	/**
	 * Writes a single value to the stream.
	 */
	protected abstract void writeValue(DataOutputStream aStream, V aValue) throws IOException;
	
	@Override
	protected Attribute read(DataInputStream aStream, Label[] aLabels) throws IOException
	{
		int theEntriesCount = aStream.readUnsignedShort();
		Entry<V>[] theEntries = new Entry[theEntriesCount];
		
		for(int i=0;i<theEntriesCount;i++)
		{
			int thePc = aStream.readUnsignedShort();
			V theValue = readValue(aStream);
			theEntries[i] = new Entry<V>(getLabel(thePc, aLabels), theValue);
		}
		
		try
		{
			Constructor<? extends SootAttribute> theConstructor = getClass().getConstructor(Entry[].class);
			return theConstructor.newInstance((Object) theEntries);
		}
		catch (Exception e)
		{
			throw new RuntimeException(e);
		}
	}

	@Override
	protected void write(DataOutputStream aStream, int aLen, int aMaxStack, int aMaxLocals) throws IOException
	{
		aStream.writeShort(itsEntries.length);
		for (Entry<V> theEntry : itsEntries)
		{
			aStream.writeShort(theEntry.label.getOffset());
			writeValue(aStream, theEntry.v);
		}
	}
	
	@Override
	protected Label[] getLabels()
	{
		List<Label> labels = new ArrayList<Label>();
		for (Entry theEntry : itsEntries) labels.add(theEntry.label);
		return (Label[]) labels.toArray(new Label[labels.size()]);
	}
	
	public static class Entry<V>
	{
		public final Label label;
		public final V v;
		
		public Entry(Label aLabel, V aV)
		{
			label = aLabel;
			v = aV;
		}
		
		@Override
		public String toString()
		{
			return label+"->"+v;
		}
	}
}