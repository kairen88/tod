\documentclass[12pt,legalpaper]{report}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{moreverb} 
\usepackage{hyperref}
\usepackage{colortbl}
\usepackage[doublespacing]{setspace}
\usepackage[left=4cm,top=4cm,right=3cm,bottom=3cm]{geometry}
\pagestyle{headings}
\hypersetup{colorlinks=false, draft = true}
\usepackage{appendix}
\usepackage[T1]{fontenc}
\setcounter{secnumdepth}{6}
\setcounter{tocdepth}{6}
\renewcommand{\appendixname}{Apéndice}
\renewcommand{\appendixpagename}{Apéndices}
\renewcommand{\appendixtocname}{Apéndices}
%para funcionamiento de listings
\usepackage{times}
\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}
\usepackage{listings}
\lstset{ 
	frame=Ltb,
	framerule=0pt,
	aboveskip=0.5cm,
	framextopmargin=3pt,
	framexbottommargin=3pt,
	framexleftmargin=0.4cm,
	framesep=0pt,
	rulesep=.4pt,
	backgroundcolor=\color{gray97},
	rulesepcolor=\color{black},
	%
	stringstyle=\ttfamily,
	showstringspaces = false,
	basicstyle=\small\ttfamily,
	commentstyle=\color{gray45},
	keywordstyle=\bfseries,
	%
	numbers=left,
	numbersep=15pt,
	numberstyle=\tiny,
	numberfirstline = false,
	breaklines=true,
}

% minimizar fragmentado de listados
%\lstrenewenvironment{listing}[1][]
%   {\lstset{#1}\pagebreak[0]}{\pagebreak[0]}
 
\lstdefinestyle{consola}
{
	basicstyle=\scriptsize\bf\ttfamily,
	backgroundcolor=\color{gray75},
}
 
\lstdefinestyle{python}
{
	language=python
}

\lstdefinestyle{java}
{
	language=java
}
%para funcionamiento de arboles
\usepackage{pstricks}
\usepackage{pst-tree}
\usepackage{algorithm}
\newcommand{\algorithmname}{\textbf{Algoritmo:}}
\usepackage{algorithmic}
\renewcommand{\algorithmicrequire}{\textbf{Entrada:}}
\renewcommand{\algorithmicensure}{\textbf{Salida:}}
\renewcommand{\algorithmicend}{\textbf{fin}}
\renewcommand{\algorithmicif}{\textbf{si}}
\renewcommand{\algorithmicthen}{\textbf{entonces}}
\renewcommand{\algorithmicelse}{\textbf{sino}}
\renewcommand{\algorithmicreturn}{\textbf{retorna}}
\renewcommand{\algorithmicfor}{\textbf{para}}
\renewcommand{\algorithmicwhile}{\textbf{mientras}}
\begin{document}
\renewcommand{\tablename}{Tabla}
\renewcommand{\listtablename}{Índice de tablas}
%\title{}
%\author{Milton Inostroza Aguilera}
%\date{}
%\clearpage
%\maketitle
\include{portada_memoria}

\begin{abstract}

La depuración es la mayor tarea del proceso de construcción de programas de un software, considerándolo en términos de tiempo y costo. Desafortunadamente los depuradores en muchos ambientes de desarrollo de software sólo entregan una asistencia mínima contribuyendo a que la depuración sea algo tedioso y una tarea que consume mucho tiempo.

Existen dos métodos tradicionales para realizar depuración de programas de un software: 

\begin{enumerate}
	\item \textit{log-based}, basado en mensaje, y
	\item \textit{breakpoint-based}, basado en punto de quiebre.
\end{enumerate}
	
La primera propuesta consiste en ir insertando registros de declaraciones dentro del código fuente, en el orden que se produce una huella ad-hoc durante la ejecución del programa. Esta técnica expone la historia actual de ejecución del programa pero: 

\begin{itemize}
	\item Requiere grandes modificaciones del código fuente.
	\item Esta técnica no es escalar, debido a que el análisis manual de grandes huellas es complicado. 
\end{itemize}

El segundo método consiste en ejecutar el programa bajo un depurador dedicado, cuando el programador permita pausar la ejecución en un punto determinado del software, este podrá examinar el contenido de la memoria, y/o continuar la ejecución paso a paso. A pesar de lo anterior, la depuración basada en \textit{breakpoint} es limitada: cuando la ejecución es pausada, la información sobre el estado y actividad anterior del programa es limitada por la introspección\footnotemark[1] de la pila\footnotemark[2] de llamada actual.

\footnotetext[1]{introspección: Capacidad de un programa de razonar sobre su propia estructura}
\footnotetext[2]{Pila: Estructura de datos de tipo LIFO que permite almacenar y recuperar datos}


Aunque los dos métodos anteriormente señalados han sido utilizados ampliamente existe una tercera propuesta llamada depuración omnisciente, también conocida como \textit{atrás-en-el-tiempo} o \textit{después-de-la-muerte}.  Esta propuesta supera todas las características de los métodos anteriores. Un depurador \textit{omnisciente} registra los eventos que ocurren durante la ejecución del programa depurado y en seguida entrega al usuario un conveniente navegador por medio del cual obtiene la huella de ejecución.  Esta propuesta combina las ventajas de la depuración basada en log -- la actividad pasada no se pierde nunca -- y también de la depuración basada en breakpoint -- fácil navegación, ejecución paso a paso e inspección completa de la pila de ejecución. Un depurador omnisciente puede simular la ejecución paso a paso hacia adelante y hacia atrás, y es posible construir inmediatamente preguntas/respuestas que podrían de una u otra forma exigir un esfuerzo significante al programador, como ¿En qué punto la variable \textit{x} fue asignada al valor \textit{y}? o ¿En qué estado estaba el objeto \textit{o} cuando se le pasó un argumento al método \textit{foo}?.

Es importante señalar que los depuradores omniscientes además de superar todas las características anteriormente señaladas poseen una característica única y es la de identificar la causa inicial de los bugs\footnotemark[3].

\footnotetext[3]{Bug: Defecto de software}

Existen varias implementaciones de los depuradores omniscientes, pero se basará el caso de estudio en TOD\footnotemark[4], un depurador omnisciente orientado a la huella de ejecución.  TOD depura sólo programas escritos en Java y para esto brinda cuatro características principales:

\footnotetext[4]{TOD: Trace-Oriented debugger, implementado en el lenguaje de programación Java}

\begin{enumerate}
         \item Stepping, ejecución paso a paso del programa a depurar.
         \item Estado de reconstitución.
         \item Reconstitución del control de flujo.
         \item Identificar la causa inicial de los bugs.
\end{enumerate}

El desafío que se plantea en este trabajo de título es diseñar un prototipo experimental llamado pyTOD que permita realizar depuración omnisciente a scripts escritos en un lenguaje de programación con tipado dinámico llamado Python, basándose en el estudio, análisis y utilización de TOD.

\end{abstract}

\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage

\chapter{Introducción}

El proceso de depuración de programas de un software se hace cada vez más necesario debido al crecimiento y evolución de los lenguajes de programación (cambios de paradigmas y características).  Es importante que el programador disponga de ambientes adecuados para que de una forma fácil, rápida e intuitiva pueda corregir los defectos del software.  Si el programador no cuenta con un ambiente adecuado para poder inspeccionar los programas de su software y corregir ciertas anomalías el costo y tiempo del desarrollo de software aumenta dramáticamente \cite{cost}. En muchos casos los programas de un software desarrollado no son expuestos a pruebas exhaustivas para conocer su verdadero comportamiento en diversos ambientes, debido a lo costoso de esto, lo que conlleva a tener comportamientos inesperados en la fase de producción de estos.

El proceso anterior se define como la manera de identificar y eliminar errores dentro de un programa perteneciente a un software y sigue siendo, hoy en día a pesar del avance de la tecnología, en buena medida una actividad manual.  Actividad que desafía la paciencia, imaginación e intuición de los programadores.  En muchos casos los programadores deben incluir en el código fuente instrucciones auxiliares que permitan el seguimiento de la ejecución del programa, presentando los valores de variables, direcciones de memoria o lo que les sea necesario.

Es deseable que una herramienta de depuración de programas de un software evite que los programadores tengan que introducir lineas adicionales en sus programas para intentar saber el comportamiento de ciertos componentes de su software.

Es de esta forma como la industria del software ha planteado diversas soluciones, las cuales mitigan el pesado proceso de depuración de programas de un software.  Las soluciones mayormente utilizadas son los depuradores basados en logs y basados en puntos de quiebre, relegando la solución de los depuradores omniscientes.  Es en este punto donde nacen preguntas fundamentales tales como ¿Conociendo las bondades de los depuradores omniscientes por qué no son ampliamente utilizados?, ¿A los programadores sólo les basta con los depuradores basados en\textit{breakpoint} y/o basados en \textit{log}?, ¿Cuáles son las desventajas que hace impracticable implementar un depurador omnisciente?, ¿No es necesario para el programador conocer la principal causa del defecto de software?.

Enfocándose en la solución de depuración omnisciente, no basta con sólo almacenar la historia del programa depurado, si no que se debe contar con un almacén de datos adecuado que sea escalable y eficiente para guardar esta enorme cantidad de información.  Además de esto, un depurador omnisciente debe implementar una interfaz que responda en un tiempo aceptable todas las peticiones que el programador le solicite.

Es por lo anterior que se ha seleccionado como caso de estudio TOD (Trace-oriented Debugger) \cite{tod} un depurador omnisciente con almacenamiento escalable.  Su interfaz gráfica responde rápidamente a las peticiones del programador y la sobre carga que produce en el ambiente en el cual se ejecuta es menor que otras implementaciones existentes sobre este concepto.

De este modo, este trabajo de memoria se centra en la implementación de un prototipo experimental, el cual realice depuración omnisciente a scripts escritos en el lenguaje de programación Python, utilizando como base de estudio e implementación TOD, un depurador omnisciente escrito en el lenguaje de programación Java.

\chapter{Propósito general}

Como concepto general se dice que software es el conjunto de programas de cómputo, procedimientos, reglas, documentación y datos asociados que forman parte de las operaciones de un sistema de computación. \cite{ieee}

La Ingeniería de Software plantea que existen tres grandes procesos para desarrollar software, que se detallan en orden cronológico:
\begin{enumerate}
	\item Análisis de sistema
	\item Diseño de sistema
	\item Codificación de software.
\end{enumerate}

En especial nos centraremos en el último proceso en donde se realizan las tareas que comúnmente se conocen como programación; que consiste, esencialmente, en llevar a código fuente, en el lenguaje de programación elegido, todo lo diseñado en la fase anterior. Esta tarea la realiza el programador, siguiendo por completo los lineamientos impuestos en el diseño y en consideración siempre a los requisitos funcionales y no funcionales (ERS) especificados en la primera etapa.

Es común pensar que la etapa de programación o codificación (algunos la llaman implementación) es la que consume la mayor parte del trabajo de desarrollo del software; sin embargo, esto puede ser relativo (y generalmente aplicable a sistemas pequeños) ya que las etapas previas son cruciales y críticas, las que pueden llevar bastante más tiempo. Se suele hacer estimaciones de un 30\% del tiempo total consumido en la programación, pero esta cifra no es consistente ya que depende en gran medida de las características del sistema, el nivel critico que tenga y el lenguaje de programación elegido. En tanto menor es el nivel del lenguaje de programación mayor será el tiempo de programación requerido, así por ejemplo se tardaría más tiempo en codificar un algoritmo en ensamblador que el mismo programado en lenguaje C.

Durante la fase de programación, el código puede adoptar varios estados, dependiendo de la forma de trabajo y del lenguaje de programación elegido.  Para introducir conceptos fundamentales en este tema de memoria, es importante precisar lo siguiente:

\begin{itemize}

    \item \textbf{Código fuente :} Es el escrito directamente por los programadores en editores de texto, lo cual genera el programa. Contiene el conjunto de instrucciones codificadas en algún lenguaje de programación. Puede estar distribuido en paquetes, procedimientos, librerías fuente, etc.

    \item \textbf{Código objeto :} Es el código binario o intermedio resultante de procesar con un compilador el código fuente. Consiste en una traducción completa y de una sola vez de éste último. El código objeto no es inteligible por el ser humano (normalmente es formato binario) pero tampoco es directamente ejecutable por el computador. Se trata de una representación intermedia entre el código fuente y el código ejecutable, a la espera de un enlace final con las rutinas de librería y entre procedimientos.

	\begin{itemize}
		\item El código objeto no existe si el programador trabaja con un lenguaje a modo de intérprete puro, en este caso el mismo intérprete se encarga de traducir y ejecutar línea por línea el código fuente (de acuerdo al flujo del programa), en tiempo de ejecución. En este caso tampoco existe él o los archivos de código ejecutable. Una desventaja de esta modalidad es que la ejecución del programa o sistema es un poco más lenta que si se hiciera con un intérprete intermedio, y bastante más lenta que si existe el o los archivos de código ejecutable. Es decir no favorece el rendimiento en velocidad de ejecución. Una gran ventaja de la modalidad intérprete puro, es que esta forma de trabajo facilita enormemente la tarea de depuración del código fuente (frente a la alternativa de hacerlo con un compilador puro). Frecuentemente se suele usar una forma mixta de trabajo (si el lenguaje de programación elegido lo permite), es decir inicialmente trabajar a modo de intérprete puro, y una vez depurado el código fuente (liberado de errores) se utiliza un compilador del mismo lenguaje para obtener el código ejecutable completo, con lo cual se agiliza la depuración y la velocidad de ejecución se optimiza.
	\end{itemize}

	\item \textbf{Código ejecutable :} Es el código binario resultante de enlazar uno o más fragmentos de código objeto con las rutinas y librerías necesarias. Constituye uno o más archivos binarios con un formato tal que el sistema operativo es capaz de cargarlo en la memoria RAM (eventualmente también parte de este en una memoria virtual), y proceder a su ejecución directa. Por lo anterior se dice que el código ejecutable es directamente \textit{inteligible por la computadora}. El código ejecutable, también conocido como código máquina, no existe si se programa con modalidad de \textit{intérprete puro}.

	\item \textbf{Compilador :} Es un programa informático que traduce un programa escrito en un lenguaje de programación a otro lenguaje de programación, generando un programa equivalente que la máquina será capaz de interpretar. Usualmente el segundo lenguaje es código máquina, pero también puede ser simplemente texto. Este proceso de traducción se conoce como compilación. De esta manera un programador puede diseñar un programa en un lenguaje mucho más cercano a como piensa un ser humano, para luego compilarlo a un programa manejable por un computador.

	\item \textbf{Intérprete :} Es un programa informático capaz de analizar y ejecutar otros programas, escritos en un lenguaje de programación de alto nivel. Los intérpretes se diferencian de los compiladores en que mientras estos traducen un programa desde su descripción en un lenguaje de programación al código máquina del sistema destino, los primeros (los intérpretes) sólo realizan la traducción a medida que sea necesario, comúnmente, instrucción por instrucción, y normalmente no guardan el resultado de dicha traducción.
	
\end{itemize}

Mientras se programa la aplicación, sistema, o software en general, se realizan también tareas de depuración, esto es la labor de ir liberando al código de los errores factibles de ser hallados en esta fase (de semántica, sintáctica y lógica). 

De acuerdo con Grace Murray Hopper, uno de los pioneros de la ciencia de la computación, la situación que dio origen al término depuración sucedió a principio de la década de los años 1950, los programadores de la Universidad de Harvard invirtieron semanas en intentos infructuosos para encontrar el error en uno de sus programas. Finalmente, una investigación dentro de las computadoras reveló que un insecto había muerto ahí. Una vez removido el insecto, el programa funcionó correctamente. Desde entonces, el proceso de quitar errores de los programas ha sido llamado \textit{depuración}.

Pero, de acuerdo a Edsgar Dijkstra, otro pionero en las ciencias de la computación, el término es irresponsable. Depuración sugiere que el programador no tiene la culpa por el error. Esto es como si el insecto trepara dentro del código mientras el programador estaba mirando hacía otro lado.

Aunque el término tenga algunas dicidencias podemos decir que depuración es un proceso metódico, el cual encuentra y reduce el número de bug, o defectos, en un programa de computación, haciendo de esta forma que estos se comporten como es esperado.  La depuración tiende a ser dura cuando varios subsistemas, que contienen muchos programas, están estrechamentes acoplados, y cambios en uno pueden provocar bugs en otros.

La Depuración es, en general, una pesada y cansadora tarea.  La habilidad para depurar del programador es probablemente el mayor factor en la capacidad de resolver un problema, pero la dificultad de la depuración de software varía enormemente referente al lenguaje de programación utilizado y a las herramientas disponibles, tales como los depuradores.  

Los depuradores son herramientas de software, las cuales permiten al programador monitorear la ejecución de un determinado programa, detenerlo, reactivarlo, poner puntos de quiebre, cambiar valores en memoria e incluso, en algunos casos, ir atrás en el tiempo.  El término depurador puede estar además relacionado con la persona que realiza la depuración.

Generalmente, los lenguajes de alto nivel, hacen la depuración fácil, porque ellos tienen características tales como manejo de excepciones que permiten manejar el comportamiento errático de una manera fácil.  En los lenguajes de nivel medio como C o bajo nivel como ensamblador, los bugs pueden causar silenciosos problemas, un ejemplo de estos es la corrupción de memoria, y esto frecuentemente dificulta ver donde el problema principal ha ocurrido.  En estos casos, las herramientas de depuración de memoria pueden ser útiles.

En determinadas situaciones, herramientas de software de propósito general que son lenguajes específicos pueden ser muy útiles.  Estas son llamadas herramientas de análisis estático.  Estas herramientas observan problemas conocidos que son muy específicos, algunos comunes y algunos extraños, dentro del código fuente.  Cada uno de estos son detectados por estas herramientas y raramente son detectados por el compilador o intérprete, por lo tanto ellos no son correctores sintácticos, si no más bien correctores semánticos.


	\section{Herramientas}

Un depurador es un software que es utilizado para probar y depurar otros programas.  Una técnica de gran utilidad en esto es la capacidad de suspender el programa depurado, cuando una condición específica es encontrada.

Cuando un programa lanza un error, el depurador muestra la posición en el código original donde se produjo dicho error, esto si es que es un depurador a nivel de código fuente, comúnmente vistos en ambientes de desarrollos integrados.  Un lanzamiento de error sucede cuando el programa no puede manejar un comportamiento extraño o desconocido debido a un defecto de software (más conocido como Bug).  Por ejemplo, tal vez el programa intentó utilizar una instrucción no disponible en la versión actual de la CPU o intentó acceder a memoria no disponible o protegida.

Comúnmente, los depuradores además ofrecen prestaciones más sofisticadas como ejecutar un programa paso a paso (\textit{step by step}), detener la ejecución (detener le ejecución del programa para examinar el estado actual) en algún tipo de evento mediante un punto de quiebre (\textit{breakpoint}), y seguirle la pista a los valores de determinadas variables.  Algunos depuradores tienen la capacidad de modificar el estado del programa mientras este se ejecuta y así no solamente son meros espectadores de la ejecución de éste.

	\section{Proceso de depuración}

La depuración comienza tratando de reproducir un problema.  Esto puede ser una tarea no trivial, por ejemplo en el caso de procesos paralelos o algún problema inusual de software.  Además el ambiente específico del usuario y el uso de la historia puede hacer que sea difícil reproducir el problema.

Después de que el bug es reproducido, la entrada del programa necesita ser simplificada para hacer más fácil el proceso de depuración.  Por ejemplo, un bug en un compilador puede hacer que este falle cuando este analizando sintácticamente un programa fuente muy largo.  Tal simplificación puede ser realizada manualmente, utilizando un enfoque \textit{divide y vencerás}.  El programador intentará sacar algunas partes del caso original de prueba y verificar si el problema aún continúa.  Cuando se depura el problema en una interfaz gráfica, el programador tratará de saltarse alguna interacción desde la descripción original del problema y verificar si las acciones restantes son suficientes para que aparezca el bug.

Después de que el caso de prueba es suficientemente simplificado, el programador puede usar el depurador para examinar el estado del programa (valores de las variables, la pila de llamadas) e identificar el origen del problema.  De forma alternativa un rastreo puede ser utilizado.  En un caso sencillo el rastreo consiste sólo en algunas instrucciones de impresión, las cuales muestran el valor de las variables en determinados puntos del programa en ejecución.

La depuración remota es el proceso de depuración de un programa que está ejecutándose en un sistema diferente que el depurador.  Para comenzar la depuración remota, el depurador se conecta a un sistema remoto sobre una red de datos.  Una vez conectado, el depurador puede controlar la ejecución del programa  sobre un sistema remoto y recobrar la información sobre el estado de éste.

	\section{Objetivo general}

El objetivo general de este trabajo de memoria es:
\begin{itemize}
\item Construir un prototipo experimental llamado pyTOD para realizar depuración omnisciente a scripts escritos en el lenguaje de programación Python, utilizando como base de estudio TOD, un depurador omnisciente implementado en el lenguaje de programación Java.
\end{itemize}

    Esto implica brindar un ambiente de depuración que sea eficiente para el programador, además de entregar una herramienta básica para inspeccionar programas y poder encontrar las causas de los bugs.

	\section{Objetivos específicos}

Para lograr el éxito del objetivo general de este trabajo de título se han definido los siguientes objetivos específicos:

\begin{itemize}
\item[1.] \textit{Diseñar e Implementar un sistema que instrumente\footnotemark[1] el código Python de tal forma que envíe eventos a la base de datos de TOD.}
\footnotetext[1]{Agregar instrucciones al código para que realice determinadas tareas}
\end{itemize}

A través de la metodología de \textit{ensayo y error} se implementará un capturador de huella de ejecución ad-hoc, que capturará todos los sucesos ocurridos en el programa objetivo escrito en Python, para luego enviarlos a la base de datos de TOD.


\begin{itemize}
\item[2.] \textit{Analizar la compatibilidad del modelo actual de huella de ejecución\footnotemark[1] de TOD con el lenguaje de programación Python.}
\end{itemize}

\footnotetext[1]{Secuencia ordenada de eventos heterogéneos de un programa computacional.}

Una vez que el capturador de huellas funcione parcialmente, se comenzará con el estudio de compatibilidad de huella de ejecución de TOD.  De ser necesario el modelo actual de huella de ejecución de TOD será modificado para conseguir compatibilidad con pyTOD.

\begin{itemize}
\item[3.] \textit{Diseñar e Implementar un protocolo de comunicación entre pyTOD (Python) y TOD (Java)}
\end{itemize}

Será necesario implementar un protocolo de comunicación el cual transporte la huella de ejecución capturada en pyTOD hacía la base de datos de TOD.  Esto se realizará una vez que se haya analizado y modificado el modelo de huella de ejecución de TOD.

%\begin{itemize}
%\item[4.] \textit{Diseñar e Implementar una interfaz gráfica para el depurador pyTOD.}
%\end{itemize}

%De ser necesario se construirá una interfaz gráfica en la cual el usuario pueda interactuar con el programa depurado.  Para esto se debe evaluar si la actual interfaz gráfica de TOD sirve y es compatible.  De ser compatible realizando modificaciones se tomará esta opción como valida y se reutilizará este componente.

\begin{itemize}
\item[4.] \textit{Diseñar e Implementar un plugin para eclipse el cual permita conectar la interfaz gráfica del depurador con el ambiente de desarrollo.}
\end{itemize}

No basta con tener una interfaz gráfica independiente del ambiente de desarrollo del programador, es fundamental que la interfaz de usuario del depurador sea incorporado como plugin dentro del ambiente de desarrollo.  Para este caso se considerará como ambiente de desarrallo el IDE Eclipse\footnotemark[2].  Se utilizará el plugin de Python para Eclipse, PyDev como base de extensión para el nuevo plugin el cual permita al programador una interacción transparente entre el ambiente de desarrollo y el ambiente de depuración.

\footnotetext[2]{Entorno integrado de desarrollo de software}

\begin{itemize}
\item[5.] \textit{Aplicar pyTOD en un caso de prueba real.}
\end{itemize}

El resultado de éxito y contribución de este trabajo de título depende mayormente de este punto.  Es importante que la herramienta desarrollada pyTOD, sea útil y demuestre con resultados reales que es una aproximación a lo que podría ser un ambiente de depuración para asistir efectivamente a los programadores que utilizan el lenguaje de programación Python.


	\section{Hipótesis del trabajo}

    ¿Es posible utilizar TOD, como base de desarrollo técnico y conceptual, para construir un prototipo experimental que realice depuración omnisciente a scripts escritos en Python?.

	\section{Alcance del trabajo}

    Se plantea construir un prototipo experimental el cual realice depuración básica a scripts escritos en Python. Si es necesario y existe la compatibilidad suficiente, se reutilizarán algunas herramientas que utiliza TOD para realizar este tipo de depuración. En ningún caso este trabajo producirá un Depurador Omnisciente con la implementación completa de las funcionalidades que este implica.

	\section{Limitaciones y supuestos}

El prototipo experimental no realizará depuración a programas que hagan uso de multithread.

    Para mantener un registro exacto de todos los objetos\footnotemark[1] dentro del programa depurado se necesita marcarlos a cada uno de ellos con un identificador, Python para esto utiliza la función \textit{id}, la cual entrega la dirección de memoria en donde se encuentra el objeto.  En el momento que un objeto se destruye esta dirección puede volver a ser utilizada por el lenguaje de programación.  Para la tarea de depuración se necesita un identificador único en todo momento y la única manera de realizarlo es modificando la maquina virtual, situación que queda fuera del alcance de este trabajo de memoria. Sin embargo esto no impide del todo implementar las funcionalidades de los depuradores omniscientes.  

    Todo el desarrollo y pruebas del prototipo se realizarán en un sistema operativo basado en el kernel de Linux, debido a esto no será un objetivo lograr compatibilidad con otros sistemas operativos.

\footnotetext[1]{Referente a todos los elementos dentro de la ejecución de un programa (métodos, funciones, atributos, instancia de clases, etc.)}

\chapter{Metodología del trabajo}
	\section{Búsqueda bibliográfica}

Esta etapa principalmente se enfocó a la búsquedas de papers relacionados con el tema de depuración en general.  Se utilizó como patrón de búsqueda la bibliografía utilizada en el paper de TOD \cite{tod} que está relacionada con el concepto de depuración y depuradores omniscientes.

A medida que fue avanzando la memoria, se utilizó la documentación en línea acerca del lenguaje de programación Python.

	\section{Análisis del Marco teórico}

Se comenzó conceptualizando las diferencias entre distintos tipos de lenguajes de programación, luego los términos de depuración en general, para luego profundizar en la depuración omnisciente.

Posterior a esto se estudiaron las distintas aproximaciones técnicas (depuradores) que existen para implementar la depuración omnisciente.


	\section{Análisis de TOD}

TOD es un depurador omnisciente que tiene como principal característica ser escalable en el sentido de almacenamiento de la huella de ejecución.  Para el actual trabajo se deben analizar los siguientes componentes de TOD:

\begin{itemize}
	\item \textbf{Structure Database :} Base de datos escrita en Java que almacena toda la estructura (definiciones) del programa depurado.
	\item \textbf{Event Database :} Base de datos escrita en Java que almacena todos los eventos ocurridos en el programa depurado.
	\item \textbf{Debugger frontend :} Interfaz gráfica que es utilizada por el programador para navegar a través de la huella de ejecución del programa depurado.
\end{itemize}

	\section{Modelamiento y diseño de pyTOD}

    Se modeló la arquitectura de pyTOD y los componentes bases para su funcionamiento.  En esta etapa se establecieron todas las modificaciones necesarias que se tuvieron que realizar a los componentes de TOD (base de datos estructural, base de datos de sucesos e interfaz gráfica) para que fuera compatible con pyTOD.

	\section{Implementación de pyTOD}

    Esta sección comprende todo el desarrollo práctico del presente trabajo de memoria, en el cual se implementó el capturador de huella utilizando el paradigma de orientación de objetos, luego la interfaz de conexión con la base de datos de TOD, luego su protocolo de comunicación y finalmente la interfaz gráfica para un ambiente de desarrollo.
    
%Es importante señalar que el uso de la función settrace perteneciente al módulo sys se torna en un elemento central en este desarrollo.  Además se inspeccionará el bytecode de Python para ciertas operaciones.

	\section{Evaluación de pyTOD en casos de pruebas}

 Se tomaron tres algoritmos implementados en el lenguaje de programación Python.  Algoritmos adecuados para ver el funcionamiento y comportamiento de pyTOD.  Los comportamientos que se midieron fueron la capacidad de encontrar bugs y la de registrar la huella de ejecución.


\chapter{Marco teórico}
	\section{Introducción}

En la práctica, un programador inevitablemente invierte demasiado tiempo encontrando y solucionando bugs. La Depuración, particularmente la realizada a programas escritos por otras personas, es una habilidad independiente a la de escribir programas correctos al primer intento.

Desafortunadamente, mientras la depuración es frecuentemente utilizada, esta es raras veces enseñada. Un curso típico sobre técnicas de depuración consiste únicamente en estudiar el manual de un depurador determinado.

\subsection{Identificación del bug}

Depuración significa remover los bugs de un programa.  Un bug es un comportamiento del programa que es inesperado y no deseado.

Ocasionalmente existe una especificación formal que un programa está obligado a seguir, en este caso un bug es la falla en el seguimiento de esta especificación.  Frecuentemente la especificación del programa es informal, en este caso las personas pueden discutir si un comportamiento particular es de hecho un bug o no.

Como una de las personas que escriben programas, el programador debe ser la fuente de los reportes de bugs.  No simplemente confiando en los usuarios finales o en los dedicados a probar determinadas funcionalidades.  Si el programador nota algo extraño mientras el programa se está ejecutando, este puede tentarse a ignorarlo y esperar que todo vaya bien en el programa.  Esto es aceptable si el programador en ese momento está trabajando en otra cosa.  Si el programador tiene archivos o reportes del bug, es mejor que siempre los guarde.  Si tiene tiempo después, debe volver al caso anómalo.  Si esto no es posible, sería recomendable que alguien más estudie este problema para que lo pueda solucionar.  Como una de las personas más familiarizadas con el programa, el programador está en la mejor posición para detectar comportamientos inesperados.

Una vez que el programador tiene un reporte de bug, el primer paso para remover este bug es identificarlo.  Esto es particularmente importante cuando se está trabajando con un reporte de bug que ha sido producido por otra persona, tales como usuarios o un equipo de pruebas.  Algunos bug son relativamente obvios, como cuando el programa termina su ejecución inesperadamente. Otros son difíciles de encontrar, como cuando el programa genera una salida la cual es levemente incorrecta.

Muchos reportes de bug recibidos de los usuarios son de la forma \textit{Yo hice esto y esto otro, y el programa falló}.  Antes de hacer cualquier cosa, el programador debe encontrar que es lo que falló -- esto es, el programador debe identificar el bug determinando el comportamiento del programa el cual fue inesperado o no deseado.  Cualquier intento de corregir el bug antes de entender que es lo que falló es generalmente tiempo desperdiciado.

Identificar un reporte de bug hecho por un usuario, normalmente requiere obtener la respuesta a estas dos preguntas: \textit{¿Qué hizo el programa?} y \textit{¿Qué esperaba que hiciera el programa?}.  El objetivo es determinar precisamente el comportamiento del programa el cual fue inesperado o no deseado.

Una vez que el bug es identificado, la forma más fácil y rápida de solucionarlo es determinar que este no es del todo un bug.  Si existe una especificación formal del programa, el programador debe modificar la especificación.  En otros casos, el programador debe modificar las expectativas del usuario.  Esta rápida solución consiste en llamar a este comportamiento como una \textit{característica no documentada}.  A pesar del potencial abuso que se pueda cometer,  esto es de hecho la forma correcta de manejar un problema.

Desafortunadamente, la mayoría de los bugs son realmente bugs y requieren de mucho esfuerzo para buscarlos, identificarlos y solucionarlos.


\subsection{Réplica del bug}

El primer paso para solucionar un bug es replicarlo, esto significa recrear el comportamiento no deseado bajo condiciones controladas.  El objetivo es encontrar un conjunto de especificaciones precisas de los pasos, que demuestran el bug.

En muchos casos esto es sencillo, el programador ejecuta el programa con una determinada información de entrada, o presiona un botón en particular o una ventana de diálogo y el bug ocurre.  En otros casos, replicar el bug puede ser difícil.  Esto puede requerir series de pasos muy largos, o en un programa interactivo como un juego, este puede requerir precisión de tiempo.  En los peores casos, la replicación puede ser casi imposible.

Es importante que el programador nunca salte este paso.  En la mayoría de los casos los programadores son tentados algunas veces  a saltar el paso de replicación, e ir directamente desde el reporte del bug a la eliminación del mismo.  Sin embargo, fallar en la replicación del bug significa que es imposible verificar la correción.  La solución propuesta puede provocar un bug diferente, o puede tener un efecto insignificante.  Si el bug no ha sido replicado, no hay forma de conocerlo.

Fallar en replicar el bug es un problema real que puede suceder muchas veces.  En un programa complejo, es frecuente encontrar algo que solucionar.  Esta es la naturaleza del humano, la de asumir que cualquier solución particular resuelve el problema que se tiene.  Sin necesitar verificaciones, cualquier solución convincente puede ser aceptada, esté bien o mal.  Una solución incorrecta libera futuros problemas.  En promedio, saltarse el paso de replicación implica que el programador gastará más tiempo en bugs relacionados a la solución que haya propuesto.


\subsubsection{Situaciones de difícil replicación}

Lejos, la mejor vía para replicar el bug es sobre un sistema que este completamente bajo el control del programador, con una copia del programa construida por el mismo.  Replicando el bug sobre su propio programa significa que el puede fácilmente hacer pruebas y nuevos parches para el programa, desafortunadamente en algunos casos esto es imposible.

Una de las razones por lo que la replicación en el sistema del programador puede ser imposible, es debido a que el usuario que reporte el bug puede que tenga un único sistema de configuración, o puede que el usuario sólo use archivos de entradas confidenciales a los cuales el programador no pueda acceder.  En estos caso el programador debe tratar de asegurar que el usuario puede realmente replicar el bug, y que el usuario pueda probar el nuevo parche desarrollado.  Sin la ayuda del usuario en este sentido, la depuración es reducida a algo más pequeño, que son los supuestos.  Esto generalmente no es un mal procedimiento.  Si no existe opción, entonces el programador puede tratar al menos de construir algunos casos aleatorios de prueba para construir un parche, confirmando que este hace algo útil incluso si el programador no puede verificar que este elimina el bug original.

Un problema mucho más común es que el usuario reporte un bug, pero el programador no pueda replicarlo en su propio sistema, y el programador no sepa por qué.  Esta no es una opción definitiva para resolver este tipo de problema, pero a continuación se detallan algunas posibles consideraciones:

\begin{itemize}
	\item El usuario puede simplemente reportar de forma incorrecta el problema o de la forma en la cual puede ser replicado.  El programador debe volver al usuario, confirmar que es lo que el usuario actualmente está escribiendo o donde el usuario actualmente está haciendo clicks, confirmar que es lo que el usuario ve en pantalla.  El programador no debe hacer presunciones sobre como el programa está ejecutándose -- el usuario puede estar haciendo algo que el programador nunca hubiera imaginado o considerado.

    \item Algunos programas tienen comportamientos extraños bajo condiciones inusuales.  El programador debe verificar si el sistema del usuario tiene poco espacio en el disco duro, o tiene una conexión de red defectuosa, o si está muy sobrecargado.  Es recomendable que a su vez verifique si otros programas están fallando inesperadamente y provocan el bug en el programa objetivo.

    \item El programador además debe revisar la versión de los programas del software que el usuario está ejecutando, revisar la versión del sistema operativo, etc.
\end{itemize}

En algunos casos un bug puede suceder raramente y aparentemente de forma aleatoria, entonces es difícil imaginarse la forma como estos son lanzados, y como replicarlos.  En esta situación frustrante al programador sólo le queda tomar una opción confiable que es la de automáticamente registrar todos los eventos que potencialmente puedan ser relevantes y guardar todos estos registros cuando el bug ocurra.  En algunos casos es particularmente útil ser capaz de volver a ejecutar el programa usando los registros, los cuales pueden ser mecanismos poderosos para replicar un bug.


\subsection{Comprensión del bug}


Una vez que el programador es capaz de replicar el bug, debe entender que es lo que lo produjo.  Este es generalmente el paso que consume mayor tiempo.


\subsubsection{Entender el programa}

Con el objetivo de entender un bug en un programa, el programador debe entender algo del funcionamiento acerca del programa.

Si el programador escribió el programa, es presumible que ya lo entienda.  De caso contrario, entonces el programador tiene un problema más serio.

Si el programador no ha escrito el programa, el necesita basarse en la estructura general del programa.  Muchos programas están organizados de una forma sensata.  Si el programador tiene suerte, la organización del programa estará documentada, o podrá preguntar a los diseñadores del programa.

Comúnmente, el programador necesitará sacar la estructura del código fuente.  La mejor opción es comenzar mirando el código fuente desde el principio del programa.  Leer rápidamente el programa, bajando por las funciones, hasta que encuentre el principal centro de acción.  En la mayoría de los programas, se trata de algún tipo de ciclo.  Esto puede hacerse normalmente  muy rápido.  La naturaleza de este centro de acción puede decirle donde mirar en el código fuente para cualquier actividad en particular.  Esto, además puede decirle en lineas generales como es que el programa actúa.

El peor de los casos son los programas grandes escritos por muchos años y por diferentes desarrolladores.  Estos llegan, en algunos casos, a ser un conjunto de ideas diferentes con muy poca consistencia.  La situación comunmente es depresiva.  El programador solamente debe hacer lo mejor que pueda.

Un depurador puede además ser útil cuando se trata de entender un programa.  Mediante la ejecución del programa bajo un depurador y definiendo puntos de quiebre, el programador puede ser capaz de ver el comportamiento dinámico del programa.  Cuando alcanza el punto de quiebre definido por el programador, puede mirar la pila de llamadas para analizar como llegó a la parte en donde está, y mirar algunas variables claves.  Incluso si el programador no alcanza el punto de quiebre definido por él, este ya habrá aprendido algo.


\subsubsection{Encontrar el bug}

El siguiente paso es localizar el bug en el código fuente del programa.  Existen dos ubicaciones en el código fuente que se debieran considerar por el programador: (a) el código que hace que el comportamiento incorrecto sea visible y (b) el código que en realidad es incorrecto.  Es muy común que éstas sean las mismas piezas de código.  Sin embargo, es bastante común que éstas estén en diferentes partes del programa.  Un ejemplo típico de esto es cuando existe un error en un parte del programa que causa un acceso a memoria restringida el cual provoca una visión errónea del comportamiento en una parte completamente diferente en el programa.  El programador no puede permitirse que en el afán de arreglar el error se confunda y piense que el código que directamente causa el comportamiento erróneo es en realidad la parte incorrecta del programa.

Por lo general, el programador tiene que encontrar el código que produce el comportamiento erróneo.  Conociendo el comportamiento erróneo, y entendiendo como el código fuente fue organizado, a menudo esto lo dirige rápidamente a la parte del programa que causa el problema.  Algunas veces una rápida lectura del código es suficiente para identificar el código problemático.

De lo contrario, disminuyendo el comportamiento erróneo en una particular pieza de código es donde un depurador puede ser de mucha utilidad.  Si el programador tiene bastante suerte tendrá un volcado de memoria, un depurador inmediatamente puede identificar la linea que ha fallado.  De lo contrario, juiciosamente el programador deberá ir poniendo puntos de quiebre mientras la replicación del bug puede ser rápidamente acotada sobre el código defectuoso.

Los Depuradores modernos, tienen poderosas capacidades para hacer este proceso más manejable, tales como los puntos de quiebre, los datos de los puntos de observación, ignorar puntos de quiebre en un determinado número de veces.  Estas características, muchas veces, son muy útiles para localizar el comportamiento erróneo en el código fuente, y esto sólo falla en circunstancias especiales.

Por supuesto, un depurador a veces no ayuda, en algunos casos, un error no se produce cuando el programa se ejecuta bajo un depurador, a pesar de que se pueden reproducir sin contar con el depurador, lo que generalmente indica un problema que depende del momento preciso de ejecución o del diseño de la memoria (problemas específicos). En otros casos, puede que no tenga acceso a un depurador, o el depurador puede que no sea muy poderoso, lo que puede suceder cuando se trabaja en sistemas empotrados o de otros entornos de programación más restringidos, o cuando se utilizan características de programación que no están soportadas por el depurador (por ejemplo, en algunos ambientes distribuidos).

En estos casos simples las instrucciones de impresión a veces pueden ayudar a localizar la fuente del comportamiento erróneo. Añadir instrucciones de impresión en lugares pertinentes, reconstruir el programa, reproducir el problema con el nuevo programa, y usar las instrucciones de impresión para perfeccionar con exactitud qué código se está ejecutando cuando se produjo el problema.  Lo ideal sería que el programa ya cuente con algún tipo de implementación que permita ser reutilizada. Incluso si no es así, el programador debería considerar la posibilidad de un enfoque sistemático para añadir instrucciones de impresión, de modo que este pueda utilizar posteriormente estos resultados al momento de realizar una nueva depuración al mismo programa. En particular, cada instrucción de impresión debe indicar claramente dónde está localizado en el programa, a fin de que pueda ser rápidamente encontrada más tarde.

Finalmente un método alternativo para localizar la fuente del comportamiento erróneo es la simple inspección del código fuente. Esta es la única opción si el programador no puede reproducir el problema. Una clara comprensión de todo el código fuente del programa es un requisito fundamental para que esta alternativa sea una buena opción. Desafortunadamente, un problema complejo es casi imposible aislar mediante la simple lectura del código fuente.  El programador tendrá que seleccionar entre ciertas posibilidades, y tratar de localizar a través del código fuente de forma cuidadosa si está en frente realmente de algún problema.


\subsubsection{Identificar el error}

Ahora que el programador ha encontrado el código que causa el comportamiento erróneo, es necesario identificar el error en la codificación real. A menudo son el mismo código, es decir, la codificación errónea directamente causa el mal comportamiento. Sin embargo, el programador siempre debe considerar la posibilidad de que el error está en otros lugares.

Por ejemplo, la rutina que causa el comportamiento erróneo puede comportarse correctamente, pero puede ser llamada con datos de entrada erróneos, o en el momento equivocado. Un error en la codificación de otros lugares puede causar una estructura de datos que espera valores erróneos. Otra posibilidad es que el usuario ingrese datos incorrectos.

La solución en estos casos pueden ser dos, el programador debe, por supuesto, arreglar el código que llama la rutina de forma incorrecta o de lo contrario restringir los datos de entrada para que no sean incorrectos. En el caso de una mala entrada del usuario, deberá validar la entrada. Además, puede que desee agregar controles al código que utiliza los valores.  Se deben comprobar valores que no sean correctos para la entrada, y generar un informe de error u otro manejador con el objetivo de que no se produzca un comportamiento erróneo del programa.


\subsection{Corregir el bug}

El último paso en el proceso de depuración es, por supuesto, eliminar el bug. Este punto es importante detallarlo pero sólo se mencionarán un par de puntos:

\begin{itemize}
    \item Si el programador desea un programa que pueda mantenerse en el futuro, entonces deberá asegurarse de arreglar el error de forma correcta. Esto significa que la solución encaja con el resto del programa, y que fija todos los aspectos del problema, sin introducir nuevos problemas. 

    \item El programador debe actualizar toda la documentación. 

    \item En algunos casos puede que el programador necesite un parche rápido para solucionar un problema inmediato. No hay nada malo en ello, siempre y cuando el programador se dé el tiempo para después volver atrás y arreglar de forma definitiva el bug. 

    \item Obviamente, siempre fijar cualquier prueba que se haga velando por que ya no se vuelva a repetir el comportamiento erróneo. No debe olvidar asegurarse de que el programa sigue para pasar una serie de ensayos. El programador debe considerar la posibilidad de extender las series de ensayos para detectar el caso que se ha fijado anteriormente, para asegurarse de que éste no vuelva a manifestarse.
\end{itemize}

A partir de lo anterior, es interesante observar las técnicas que el mercado de software ha desarrollado para satisfacer las necesidades tanto de las empresas que construyen software como la de los desarrolladores independientes.


	\section{Técnicas de depuración}
		\subsection{Depuración basada en mensajes}
			\subsubsection{Motivación}
			
Insertar instrucciones de mensajes en un código es una técnica que necesita muy poca tecnología para hacer depuración.  Esta puede ser la única manera de hacer depuración debido a que los depuradores no siempre están disponibles o son aplicables. Normalmente este es el caso de aplicaciones distribuidas.

La experiencia indica que la acción de registrar determinados comportamientos es un proceso importante dentro del ciclo de desarrollo de software. Estos ofrecen varias ventajas:
\begin{itemize}
	\item Proporcionan contextos precisos sobre la ejecución del programa. Una vez insertado en el código, la generación del registro de salida no requiere la intervención humana.
	\item Por otra parte, el registro de salida se debe guardar en un medio persistente, para ser estudiado en otro momento.
	\item Además de su uso en el ciclo de desarrollo de software, un buen manejo de las instrucciones de mensajes de comportamientos pueden ser vistos como una buena herramienta de auditoría.
\end{itemize}


Como Brian W. Kernighan y Rob Pike exponen en \cite{thePracticeOfProgramming}:

"\textit{Como opción personal, tendemos a no utilizar depuradores más allá de obtener un pila de traza o el valor de una o dos variables. Una de las razones es, que es fácil perderse en detalles complicados de estructuras de datos y control de flujo; nos encontramos que ir a través del programa es menos productivo que pensar intensamente y añadir instrucciones de salida que verifiquen por si mismos puntos críticos de este. Al hacer click sobre las declaraciones, llevará más tiempo que el rastreo de la salida que juiciosamente fueron colocadas. Se tarda menos tiempo para decidir dónde colocar las declaraciones de impresión que dar pasos para lograr seccionar la región crítica del código, incluso asumiendo que nosotros sabemos donde está. Más importante aún, las instrucciones de depuración permanecen en el programa, las sesiones de depuración son transitorias}".

			\subsubsection{Proceso de depuración}

Este proceso consiste en que el programador manualmente vaya insertando instrucciones que impriman datos de interés (ubicación, ambiente, etc.), y estos se guarden en un archivo o se impriman directamente en una consola o terminal.  En general esto se hace a nivel de código fuente y lo que se imprime siempre está dirigido para que un humano lo comprenda.

			\subsubsection{Ventajas/Desventajas}

Una de las principales ventajas de esta técnica es que se puede aplicar sin la necesidad de contar con una herramienta dedicada para tal labor.

La técnica de mensajes también tiene sus inconvenientes:
\begin{itemize}
	\item Puede retardar una solicitud que se le realiza al programa. 
	\item Si los mensajes son demasiados extensos pueden causar ceguera de desplazamiento sobre el código fuente original.
\end{itemize}	
Es importante señalar que esta técnica no es escalable.  


			\subsubsection{Herramientas}
				\paragraph{Log4j}
			  			
Esta herramienta \cite{log4j} es una biblioteca de código de abierto desarrollada en el lenguaje de programación \textit{Java} por \textit{Apache Software Foundation} que permite a los desarrolladores de software realizar depuración basada en mensajes con distintos niveles de granularidad (nivel de detalle) en tiempo de ejecución. La configuración de salida y granularidad de los mensajes es realizada en tiempo de ejecución mediante el uso de archivos de configuración externos.

Un ejemplo simple de uso es el siguiente:
\begin{singlespace}
\begin{lstlisting}
import com.foo.Bar;
//Importa las clases de log4j.
import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;
public class MyApp{
   //Define una variable estatica que tiene una referencia
   //a una instancia de Logger llamada "MyApp".
   static Logger logger = Logger.getLogger(MyApp.class);

   public static void main(String[]args){
      //Crea una simple configuracion a la consola
      BasicConfigurator.configure();
      logger.info("Entrando en la aplicacion.");
      Bar bar = new Bar();
      bar.doIt();
      logger.info("Saliendo de la aplicacion.");	
      }
}	
\end{lstlisting}
\end{singlespace}
	
\textit{MyApp} utiliza la clase \textit{Bar} del paquete \textit{com.foo}, la cual ya no tiene que configurar el log sino únicamente utilizarlo.

\begin{singlespace}
\begin{lstlisting}
package com.foo;
import org.apache.log4j.Logger;

public class Bar{
   static Loggerlogger = Logger.getLogger(Bar.class);
   public void doIt(){
      logger.debug("Dentro de Bar!");
   }
}
\end{lstlisting}
\end{singlespace}
	
La salida en el log es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
0 [main] INFOMyApp - Entrando en la aplicacion.
36[main]DEBUG com.foo.Bar - Dentro de Bar!
51[main]INFO MyApp - Saliendo de la aplicacion.	
\end{lstlisting}
\end{singlespace}
				\paragraph{django-logging}
				
Esta herramienta \cite{django-logging} es un módulo que permite realizar depuración basada en mensajes para aplicaciones web desarrolladas en el framework \textit{Django}. Fue desarrollada para funcionar con \textit{Django} cuando está siendo ejecutado vía \textit{runserver}.  Django-logging evita que el programador tenga que imprimir mensajes de depuración vía consola, permitiéndole insertar determinadas instrucciones que serán mostradas en una cómoda vista dentro de la pagina web en la cual han sido insertadas.  						
Un ejemplo sencillo de uso es el siguiente:

\begin{singlespace}
\begin{lstlisting}[style=Python]
def monthlyReport(aRequest):
    logging.debug('This is a sample debug message')
    logging.info('This is a sample informational message')
    logging.warn('This is a sample warning message')
    logging.error('This is a sample error message')
    logging.critical('This is a sample critical message')    
    if aRequest.method == "POST":
    	....
    ....
\end{lstlisting}
\end{singlespace}

El resultado de la introducción de las instrucciones de mensajes son observados a través del navegador web, en el formulario en el cual fueron introducidas:

\begin{figure}[hpb]
	\centering
	\includegraphics[scale=0.5]{images/django-logging.eps}
	\caption{Resultado de depuración con django-logging}
\end{figure}
 

		\subsection{Depuración basada en puntos de quiebre}
			\subsubsection{Motivación}

Un punto de quiebre es una detención intencional o pausa en un lugar del programa o script, puesto en ese lugar con propósitos de depuración.  En general, un punto de quiebre es el significado de adquirir conocimiento acerca de un programa durante su ejecución.  Durante la interrupción, el programador inspecciona el ambiente de prueba (memoria, archivos, reportes, etc) para averiguar si el programa funciona correctamente.

			\subsubsection{Proceso de depuración}

En la práctica, un punto de quiebre consiste en una o más condiciones que determinan cuando la ejecución de un programa debe ser interrumpida.  La forma más común de un punto de quiebre es uno, donde la ejecución del programa es interrumpido antes de ejecutar la instrucción especificada por el programador, esto es comúnmente llamado instrucción de punto de quiebre.

Otro tipo de condiciones pueden ser utilizadas, tales como lectura, escritura o modificación de un ubicación específica en el área de memoria.  Esto es comúnmente llamado información de punto de quiebre o un punto de observación.

Los puntos de quiebres además pueden ser utilizados para interrumpir la ejecución en un momento determinado, o cuando se presiona determinada tecla.

Muchos procesadores incluyen soporte de hardware para los puntos de quiebre (comúnmente para los puntos de quiebre de instrucción e información).  Dicho hardware puede incluir limitantes, por ejemplo no permitir puntos de quiebres o instrucciones ubicadas en sectores reservados por el mismo.  Este tipo de restricciones es impuesta por la micro arquitectura del procesador, variando de procesador en procesador.

Sin soporte de hardware, los depuradores tienen que implementar los puntos de quiebre mediante software, lo cual, particularmente para los puntos de quiebre de información, pueden tener un impacto enorme en el rendimiento de la aplicación que está siendo depurada.


			\subsubsection{Ventajas/Desventajas}
			
Los depuradores de punto de quiebre tienen las siguientes ventajas sobre los depuradores basados en mensajes:

\begin{itemize} 
	\item Examinar y modificar la memoria y las variables del programa.
	\item Examinar el contenido de los registros del procesador.
	\item Examinar la pila de llamadas que ha desembocado la situación actual.
	\item Cambiar el punto de ejecución, de manera que el programa continúe su ejecución en un punto diferente al punto en el que fue detenido.
	\item Ejecutar instrucción a instrucción.
	\item Ejecutar partes determinadas del código, como el interior de una función, o el resto de código antes de salir de una función.
\end{itemize}

La principal desventaja de los depuradores de punto de quiebre es que al encontrar el punto de quiebre, no tiene en sus registros la pila de llamadas que se produjeron, perdiendo toda la información anterior al punto de quiebre.

			\subsubsection{Herramientas}

				\paragraph{Depurador de Eclipse}
				
Eclipse es una plataforma de software compuesta por un framework de aplicaciones extensible, herramientas y una librería de tiempo de ejecución para software.  Este está escrito fundamentalmente en Java para entregar a los desarrolladores de software y administradores un ambiente de desarrollo integrado (IDE).

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.35]{images/Eclipse.eps}
	\caption{Resultado de depuración con Eclipse}
\end{figure}

Los usuarios de Eclipse pueden extender sus capacidades mediante la instalación de plugins escritos para el framework Eclipse, al igual que herramientas de desarrollo para otros lenguajes de programación, y pueden escribir y contribuir con sus propios plugins.

Todas las liberaciones de Eclipse están bajo los términos de la licencia pública de Eclipse, Eclipse es una herramienta de software libre y abierta.

				\paragraph{Depurador Winpdb }	

Winpdb es un depurador de punto de quiebre para Python independiente de la plataforma, la cual soporta múltiple hilos de ejecución, modificación del espacio de nombres, depuración embebida, comunicación encriptada y es 20 veces más rápido que pdb (Módulo de Python para realizar depuración).

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.35]{images/Winpdb.eps}
	\caption{Resultado de depuración con Winpdb}
\end{figure}


		\subsection{Depuración Omnisciente}
			\subsubsection{Motivación}

Mediante el registro de cada cambio de un programa en ejecución, es posible presentar al programador cualquier información que desee.  Esencialmente, esto hace posible depurar el programa yendo \textit{atrás en el tiempo}, simplificando bastante el proceso de depuración.


Los desarrolladores de los depuradores se han concentrado completamente en responder la siguiente pregunta: \textit{¿Qué información podemos entregar a los programadores mientras el programa se está ejecutando?}.  Aunque esto no es del todo errado, no es la pregunta correcta.  La pregunta que debieran tener que responder es: \textit{¿Qué información ayudaría más al programador?}.

De estudios informales \cite{odb} se ha revelado que cientos de programadores, aproximadamente el $90\%$ de ellos, depuran todos sus programas utilizando sólo instrucciones de impresión.


			\paragraph{Depuración omnisciente}

Un depurador omnisciente trabaja mediante la recolección de eventos generados por cada cambio de estado (cada asignación de variable de cualquier tipo) y cada llamada a un método dentro del programa depurado \cite{tod,odb}.  Después de terminado el programa es mostrado el depurador (interfaz gráfica) permitiendo al programador ver el estado del programa en el tiempo de ejecución que desee.  

El programador puede seleccionar cualquier variable e ir \textit{atrás en el tiempo} y mirar donde ésta fue definida o cual fue su valor.


			\subsubsection{Proceso de depuración}

Aunque no existe una definición formal de como llevar a cabo el proceso de depuración en esta técnica, se utiliza la definición de Bil Lewis \cite{odb} para explicar el proceso y componentes esenciales que debe tener un depurador omnisciente.

				\paragraph{Mantener el estado}

Se quiere ser capaz de revertir el programa hacia cualquier estado anterior de ejecución.  Esto implica que se debe grabar cada cambio de cada objeto o variable.  Se necesita grabar cada asignación en cada hilo de ejecución y definir un orden sobre ellos.  La marca de tiempo debe ser el único referente del estado del programa.

				\paragraph{Presentación}

Cada objeto, variable, instrucción de E/S tendrá un valor conocido para cada marca de tiempo.  Cuando \textit{revertimos el depurador} a un tiempo dado, toda la información es actualizada para reflejar los valores para esa marca de tiempo.

Se muestra toda la información de forma adecuada y el programador no debiera nunca preguntarse \textit{¿Ésto cambió?} o \textit{¿dónde estoy?}.

				\paragraph{Identificar el estado}

El programador debe ser capas de mirar un objeto y saber que objeto es y que valores tienen las variables de instancias.  Los objetos de clases son mostrados justo con el nombre de la clase (ej.: Persona), strings y otras primitivas como se esperan (1, True, "soy una cadena").

				\paragraph{Navegación}

La simple navegación a través de la historia del programa es dotado a través de la selección de línea en un panel o presionando algunos botones.  Los botones deben trabajar de una forma estándar para los diferentes paneles que existan.


			\subsubsection{Ventajas/Desventajas}

Existen varias razones para hacer un esfuerzo y estudiar la depuración omnisciente:

\begin{itemize}
	\item La primera y más famosa, es fácil depurar cuando se puede ir hacia atrás.  La pregunta más común que los programadores se hacen es \textit{¿Quién definió esta variable?}.

	\item Elimina los terribles problemas con depuradores de punto de quiebre, con los cuales el programador debe \textit{adivinar} en donde poner el punto de quiebre.  No existen pasos extras para depurar, no sucede la situación común de \textit{fui demasiado lejos}.  Se eliminan los problemas no determinísticos.

	\item Entrega al programador una lista única de eventos del programa siendo capaz de ver las huellas de llamadas a los métodos.

	\item Toda la información es serializada y puede ser analizada remotamente.
\end{itemize}

La gran desventaja de esta técnica se relaciona con la enorme capacidad de almacenamiento que se necesita para almacenar las huellas de ejecución.  En el mejor de los casos es adecuado utilizar un cluster.

			\subsubsection{Herramientas}

Algunas de las herramientas que existen son:
\begin{itemize}
	\item \textbf{EXDAMS}, un depurador extensible y sistema de monitoreo
	\item \textbf{ODB}, un depurador omnisciente no escalable para el lenguaje de programación Java 
	\item \textbf{ZSTEP}, un depurador omnisciente para el lenguaje de programación Lisp
	\item \textbf{TOD}, un depurador omnisciente escalable para el lenguaje de programación Java
\end{itemize}

En el capítulo número 5 se individualizarán algunas de estas herramientas.

	\section{Lenguajes de Programación}

Un lenguaje de programación es un lenguaje que puede ser utilizado para hacer funcionar o controlar el comportamiento de una máquina, particularmente una computadora. Consiste en un conjunto de símbolos y reglas (sintácticas y semánticas), que definen su estructura y el significado de sus elementos y expresiones.

Aunque muchas veces se usa lenguaje de programación y lenguaje informático como si fuesen sinónimos, no tiene por qué ser así, ya que los lenguajes informáticos engloban a los lenguajes de programación y a otros más, como, por ejemplo, el HTML (lenguaje para el marcado de páginas Web).

Un lenguaje de programación permite a uno o más programadores especificar de manera precisa: sobre qué datos una computadora debe operar, cómo deben ser estos almacenados, transmitidos y qué acciones deben tomar bajo una variada gama de circunstancias. Todo esto, a través de un lenguaje que intenta estar relativamente próximo al lenguaje humano o natural, tal como sucede con el lenguaje Léxico. Una característica relevante de los lenguajes de programación, es precisamente que más de un programador pueda tener un conjunto común de instrucciones que puedan ser comprendidas entre ellos para realizar la construcción del programa de forma colaborativa.

Los procesadores utilizados en las computadoras son capaces de entender y actuar según lo indican programas escritos en un lenguaje fijo llamado lenguaje de máquina. Todo programa escrito en otro lenguaje puede ser ejecutado de dos maneras:

\begin{itemize}
	\item Mediante un programa que va adaptando las instrucciones conforme son encontradas. A este proceso se lo llama interpretar y a los programas que lo hacen se los conoce como intérpretes.
	\item Traduciendo este programa al programa equivalente escrito en lenguaje de máquina. A ese proceso se lo llama compilar.
\end{itemize}

		\subsection{Clasificación de los lenguajes de programación}

Los lenguajes de programación se determinan según el nivel de abstracción, según la forma de ejecución y según el paradigma de programación que poseen cada uno de ellos, estos pueden ser:

			\subsubsection{Según su nivel de abstracción}

				\paragraph{Lenguajes de bajo nivel}

Los lenguajes de bajo nivel son lenguajes de programación que se acercan al funcionamiento de una computadora. El lenguaje de más bajo nivel es, por excelencia, el código máquina. A éste le sigue el lenguaje ensamblador, ya que al programar en ensamblador se trabajan con los registros de memoria de la computadora de forma directa.

				\paragraph{Lenguajes de nivel medio}

Existen lenguajes de programación que son considerados por algunos expertos como lenguajes de medio nivel (como es el caso del lenguaje C), al tener ciertas características que los acercan a los lenguajes de bajo nivel pero teniendo, al mismo tiempo, ciertas cualidades que lo hacen un lenguaje más cercano al humano y, por tanto, de alto nivel.

				\paragraph{Lenguajes de alto nivel}

Los lenguajes de alto nivel son normalmente fáciles de aprender porque están formados por elementos de lenguajes naturales, como el inglés. En \textit{BASIC}, el lenguaje de alto nivel más conocido, los comandos como \textit{IF contador = 10 THEN STOP} pueden utilizarse para pedir a la computadora que pare si \textit{contador} es igual a 10. Por desgracia para muchas personas esta forma de trabajar es un poco frustrante, dado que a pesar de que las computadoras parecen comprender un lenguaje natural, lo hacen en realidad de una forma rígida y sistemática.


			\subsubsection{Según la forma de ejecución}

				\paragraph{Lenguajes compilados}

Naturalmente, un programa que se escribe en un lenguaje de alto nivel también tiene que traducirse a un código que pueda utilizar la máquina. Los programas traductores que pueden realizar esta operación se llaman compiladores. Éstos, como los programas ensambladores avanzados, pueden generar muchas líneas de código de máquina por cada proposición o instrucción del programa fuente. Se requiere un proceso de compilación antes de procesar los datos de un problema.

Los compiladores son aquellos programas computacionales, cuya función es traducir un programa escrito en un determinado lenguaje a un idioma que la computadora entienda (lenguaje máquina con código binario).

Al usar un lenguaje compilado, el programa desarrollado no se ejecuta mientras existan errores sintácticos, sino hasta que luego de haber compilado el programa, ya no aparecen estos errores en el código.

				\paragraph{Lenguajes interpretados}

Se puede también utilizar una alternativa diferente de los compiladores para traducir lenguajes de alto nivel. En vez de traducir el programa fuente y grabar en forma permanente el código objeto que se produce durante el proceso de compilación para utilizarlo en un proceso de producción futura, el programador sólo carga el programa fuente en la computadora junto con los datos que se van a procesar. Un programa intérprete, almacenado en el sistema operativo del disco, o incluido de manera permanente dentro de la máquina, convierte cada proposición o instrucción del programa fuente en lenguaje de máquina conforme vaya siendo necesario durante el proceso de los datos. No se graba el código objeto para utilizarlo posteriormente.

La siguiente vez que se utilice una instrucción, se debe interpretar otra vez y traducir a lenguaje máquina. Por ejemplo, durante el procesamiento repetitivo de los pasos de un ciclo, cada instrucción del ciclo tendrá que volver a ser interpretado cada vez que se ejecute el ciclo, lo cual hace que el programa sea más lento en tiempo de ejecución (porque se va revisando el código en tiempo de ejecución), pero más rápido en tiempo de diseño (porque no se tiene que estar compilando a cada momento el código completo). 

El intérprete elimina la necesidad de realizar un proceso de compilación después de cada modificación del programa cuando se quiere agregar funciones o corregir errores; pero es obvio que un programa objeto compilado con antelación deberá ejecutarse con mucha mayor rapidez que uno que se debe interpretar a cada paso durante un proceso de producción.

			\subsubsection{Según el paradigma de programación}

Un paradigma de programación representa un enfoque particular o filosofía para la construcción del software. No es mejor uno que otro, sino que cada uno tiene ventajas y desventajas. Dependiendo de la situación un paradigma resulta más apropiado que otro. Atendiendo al paradigma de programación, se pueden clasificar los lenguajes en:


					\paragraph{Paradigma Imperativo}
				
Describe la programación como una secuencia de instrucciones o comandos que cambian el estado de un programa. El código máquina en general está basado en el paradigma imperativo. Su contrario es el paradigma declarativo. En este paradigma se incluye en el paradigma procedimental (procedural) entre otros.
				
					\paragraph{Paradigma Declarativo}

No se basa en el cómo se hace algo (cómo se logra un objetivo paso a paso), sino que describe (declara) cómo es algo. En otras palabras, se enfoca en describir las propiedades de la solución buscada, dejando indeterminado el algoritmo (conjunto de instrucciones) usado para encontrar esa solución. Es más complicado de implementar que el paradigma imperativo, tiene desventajas en la eficiencia, pero ventajas en la solución de determinados problemas.

					\paragraph{Paradigma Estructurado}

La programación se divide en bloques (procedimientos y funciones) que pueden o no comunicarse entre sí. Además la programación se controla con secuencia, selección e iteración. Permite reutilizar código programado y otorga una mejor compresión de la programación. Es contrario al paradigma inestructurado, de poco uso, que no tiene ninguna estructura, es simplemente un \textit{bloque}, como por ejemplo, los archivos batch o lotes.
				
					\paragraph{Paradigma Funcional}
				 
Este paradigma concibe a la computación como la evaluación de funciones matemáticas y evita declarar y cambiar datos. En otras palabras, hace hincapié en la aplicación de las funciones y composición entre ellas, más que en los cambios de estados y la ejecución secuencial de comandos. Permite resolver ciertos problemas de forma elegante y los lenguajes puramente funcionales evitan los efectos secundarios comunes en otro tipo de programaciones.
	
					\paragraph{Paradigma Lógico}
				
Se basa en la definición de reglas lógicas para luego, a través de un motor de inferencias lógicas, responder preguntas planteadas al sistema y así resolver los problemas.

	
					\paragraph{Paradigma Orientado a Objetos}
				
La programación orientada a objetos expresa un programa como un conjunto de estos objetos, que colaboran entre ellos para realizar tareas. Esto permite hacer los programas y módulos más fáciles de escribir, mantener y reutilizar.


Si bien puede seleccionarse la forma pura de estos paradigmas al momento de programar, en la práctica es habitual que se mezclen, dando lugar a la programación multiparadigma.

Actualmente el paradigma de programación más utilizado debido a múltiples ventajas respecto a sus anteriores, es la programación orientada a objetos.

A continuación se detallan algunas características del lenguaje de programación utilizado en el presente trabajo de memoria para realizar la etapa de implementación.

		\subsection{Python}

			\subsubsection{¿Qué es Python?}

Python es un lenguaje de programación de alto nivel creado por Guido van Rossum a principios de los años 1990.  Es un lenguaje similar a Perl, pero con una sintaxis muy limpia y que favorece un código legible.

Se trata de un lenguaje interpretado o de script, con tipado dinámico, fuertemente tipado, multiplataforma y multiparadigma (orientación a objetos, estructurada y funcional).

			\subsubsection{Lenguaje interpretado}

Es un lenguaje de programación interpretado o de script, esto quiere decir que se ejecuta utilizando un programa intermedio llamado intérprete, en lugar de compilar el código a lenguaje máquina que pueda comprender y ejecutar directamente una computadora.

La ventaja de los lenguajes compilados es que su ejecución es más rápida. Sin embargo los lenguajes interpretados son más flexibles y portables.

Python tiene, no obstante, muchas de las características de los lenguajes compilados, por lo que se podría decir que es semi interpretado. En Python, como en Java y muchos otros lenguajes, el código fuente se traduce, la primera vez que se ejecuta a un pseudocódigo máquina intermedio llamado bytecode, generando archivos .pyc o .pyo (bytecode optimizado), que son los que se ejecutarán en sucesivas ocasiones.


			\subsubsection{Tipado dinámico}

La característica de tipado dinámico se refiere a que no es necesario declarar el tipo de dato que va a contener una determinada variable, sino que su tipo se determinará en tiempo de ejecución según el tipo del valor al que se asigne, y el tipo de esta variable puede cambiar si se le asigna un valor de otro tipo.


			\subsubsection{Fuertemente tipado}

No se permite tratar a una variable como si fuera de un tipo distinto al que tiene, es necesario convertir de forma explícita dicha variable al nuevo tipo previamente. Por ejemplo, si se tiene una variable que contiene un texto (variable de tipo cadena o string) no se podrá tratar como un número (sumar la cadena "9"\ y el número 8). En otros lenguajes el tipo de la variable cambiaría para adaptarse al comportamiento esperado, aunque esto es más propenso a errores.

		\subsection{Comparativa entre Python y Java}

Esta sección muestra similitudes y diferencias entre estos dos lenguajes de programación, evitando principalmente mostrar que uno es mejor que otro, debido a que los lenguajes de programación son herramientas, y diferentes herramientas son apropiadas para distintos trabajos.  Como ejemplo podemos ver a un plomero quien sólo tiene en su caja de herramientas un martillo (sin importar el tamaño del martillo), \textit{¿Este será capaz de solucionar todos los problemas de las cañerías y alcantarillados?}.  En analogía a este ejemplo podemos ver a una organización de desarrollo de software, que plantea desarrollar todas las soluciones de software con el lenguaje de programación Java, \textit{¿Esta organización será capaz de dar solución eficiente a todos los problemas que se le plantean?}.

Java es un lenguaje de tipado estático, cuyos tipos se fijan en el momento de compilar. La mayoría de los lenguajes de tipado estático fuerzan esto exigiéndole al programador que declare todas las varibles con sus tipos antes de usarlas. 

Existen tres principales características que los programadores deben tomar en cuenta: \newpage

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c |}
\hline
\rowcolor[gray]{0.9}Java & Python\\
\hline
\begin{minipage}{7cm}
\ \newline
\underline{\textit{Tipado estático}:} En java, todos los nombres de variables (junto con sus tipos), deben ser explícitamente declarados.  El intento de asignar un objeto con un tipo de datos erróneo a un nombre de variable levantará inmediatamente una excepción de tipo. \newline
Los objetos contenedores Java (Ejemplo: \textit{Vector} y \textit{ArrayList}) esperan objetos del tipo genérico \textit{Object}, pero no pueden esperar primitivas como un \textit{int}.  Para almacenar un \textit{int} en un \textit{Vector}, se debe primero convertir el \textit{int} a un \textit{Integer}. Cuando se rescata un objeto desde un contenedor, este no recuerda su tipo, y debe ser explícitamente convertido al tipo deseado.\\
\end{minipage}&
\begin{minipage}{7cm}
\ \newline
\underline{\textit{Tipado dinámico}:} En Python, nunca se declara nada.  Una instrucción de asignación vincula un nombre con un objeto, y el objeto puede ser de cualquier tipo.  Si un nombre es asignado a otro objeto de un tipo, este puede más tarde ser asignado con un objeto de diferente tipo.  Esto quiere decir que Python es un lenguaje de programación de tipado dinámico.\newline 
Los objetos contenedores Python (Ejemplo: \textit{listas} y \textit{diccionarios}) pueden esperar objetos de cualquier tipo, incluyendo números y listas. Cuando se recupera un objeto desde un contenedor, este recuerda su tipo, entonces la conversión no es requerida.\\
\ \newline
\end{minipage}\\
\hline
\begin{minipage}{7cm}
\ \newline
\underline{\textit{Prolijo}:}
Abundante en palabras; utilizando o conteniendo muchas palabras que son necesarias.\\
\end{minipage}&
\begin{minipage}{7cm}
\ \newline
\underline{\textit{Conciso}:}
Expresando mucho en pocas palabras.  Esto implica brevedad, consiguiendo eliminar cosas superfluas.\\
\end{minipage}\\
\hline
\begin{minipage}{7cm}
\ \newline
\underline{\textit{No es compacto}}\\
\end{minipage}&
\begin{minipage}{7cm}
\ \newline
\underline{\textit{Compacto}:}
En The new hacker's Dictionary \cite{EricRaymond} entrega la siguiente información de compacto:
Compacto adj. de diseño, describe la propiedad valuable que este puede ser retenido en la mente.  Esto significa que el objeto fue creado desde el diseño para ser utilizado con mucha facilidad y pocos errores.\\
\end{minipage}\\
\hline
\end{tabular}
%\caption{Comparativa entre lenguajes Java y Python}
\label{comparativa}
\end{center}
\end{table}

A continuación se muestran ejemplos que comparan el uso entre Java y Python:

El clásico programa que ilustra "Hola, mundo!"\

\begin{itemize}
	\item Java
\begin{singlespace}
\begin{lstlisting}
public class HelloWorld
{
	public static void main (String[] args)
	{
		System.out.printlin("Hola Mundo!");
	}
}
\end{lstlisting}
	\item Python
\begin{lstlisting}[style=Python]
print "Hola Mundo!"
\end{lstlisting}
\end{singlespace}
\end{itemize}

En el siguiente ejemplo, se inicializa un entero con cero, luego este se convierte a string, luego se verifica si es que este está vacío.  Es importante notar que la declaración es necesaria en Java pero no en Python.

\begin{itemize}
	\item Java
\begin{singlespace}
\begin{lstlisting}
int myCounter = 0;
String myString = String.valueof(myCounter);
if (MyString.equals("0"))
...
//imprimir los enteros del 1 al 9
for(int i = 1; i < 10; i++){
	System.out.println(i);
}
\end{lstlisting}
	\item Python
\begin{lstlisting}[style=Python]
myCounter = 0
myString = str(myCounter)
if myString == 0
...
for i in range(1,10):
	print i
\end{lstlisting}
\end{singlespace}
\end{itemize}

Imagine que su aplicación tiene 15 clases.  (Más precisamente, esta tiene 15 clases públicas de nivel superior).

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c |}
\hline
\rowcolor[gray]{0.9}Java & Python\\
\hline
\begin{minipage}{7cm}
\ \newline
Cada nivel superior de clases públicas debe ser definida en su propio archivo.  Si la aplicación tiene 15 clases, esta tiene 15 archivos.\\
\end{minipage}&
\begin{minipage}{7cm}
\ \newline
Múltiples clases pueden ser definidas en un archivo.  Si la aplicación tiene 15 clases, la aplicación completa puede ser almacenada en un solo archivo, aunque quizás se desee dividir de forma sensata las clases entre 4, 5, o 6 archivos.\\
\end{minipage}\\
\hline
\end{tabular}
\end{center}
\end{table}

En una aplicación, el método A llama al método B, el método B llama al método C, el método C llama al método D, el método D llama al método E, el método E llama al método F.  Se descubre que el método F debe lanzar la excepción SpecialException, y esta debe ser capturada por el método A.

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c |}
\hline
\rowcolor[gray]{0.9}Java & Python\\
\hline
\begin{minipage}{7cm}
\ \newline
Se debe lanzar SpecialException en el método F, y capturarla en A, y se debe añadir \textit{throws SpecialException} en las firmas de los métodos B, C, D, E y F.\\
\end{minipage}&
\begin{minipage}{7cm}
\ \newline
Se debe levantar SpecialException en el método F, y capturarla en A.  Las excepciones serán propagadas hacia los niveles superiores automáticamente.\\
\end{minipage}\\
\hline
\end{tabular}
\end{center}
\end{table}

En una aplicación se tiene una clase \textit{Empleado}.  Cuando una instancia de Empleado es creada, al constructor debe ser pasado uno, dos o tres argumentos.

Si se está programando en Java, esto significa que se tiene que escribir tres constructores, con tres diferentes firmas.  Si se está programando en Python, sólo se escribe un constructor, con valores por defecto para los argumentos opcionales.

\begin{itemize}
	\item Java
\begin{singlespace}
\begin{lstlisting}
public class Empleado
{
	private String Nombre;
	private int Impuesto;
	private String estadoCivil;
	//------constructor #1------
	public Empleado(String aEmpleado)
	{
		this(aEmleado,1);
	}
	//------constructor #2------
	public Empleado(String aEmpleado, int aImpuesto)
	{
		this(aEmleado, aImpuesto, "soltero");
	}
	//------constructor #3------
	public Empleado(String aEmpleado, int aImpuesto, String aEstadoCivil)
	{
		this.Nombre = aEmpleado;
		this.Impuesto = aImpuesto;
		this.estadoCivil = aEstadoCivil;
	}	
}
\end{lstlisting}
	\item Python
\begin{lstlisting}[style=Python]
class Empleado():

	def __init__(self, aNombre, aImpuesto=2, aEstadoCivil="soltero"):
		self.nombre = aNombre
		self.impuesto = aImpuesto
		self.estadoCivil = aEstadoCivil
\end{lstlisting}
\end{singlespace}
\end{itemize}

Para graficar de mejor manera el tipado estático versus el tipado dinámico se muestran los siguientes gráficos:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/JavaPython/staticTyping.eps}
	\caption{Tipado estático}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/JavaPython/dynamicTyping.eps}
	\caption{Tipado dinámico}
\end{figure}


\chapter{Implementación de depuradores omniscientes}

A lo largo de la historia de la Ciencia de la Computación han existido muchos esfuerzos por implementar depuradores omniscientes, es por esto que se encuentra importante conocer las distintas perspectivas de diferentes equipos de implementación.  A continuación se muestra, dividida por etapas, las distintas implementaciones existentes al día de hoy.

	\section{Implementaciones históricas}

En esta sección se considera EXDAMS - Extendable Debugging And Monitoring System, como la implementación histórica más importante.

		\subsection{EXDAMS}
			\subsubsection{Historia}

Con la llegada de los lenguajes algebraicos de alto nivel, la industria de la computación esperaba ser aliviada de los detalles de programación requeridos en el nivel de los lenguajes ensamblador.  Esta expectativa ha sido en gran parte cumplida y muchos sistemas son ahora construídos en lenguajes de alto nivel.

Sin embargo, la habilidad de depurar programas tiene avances que son pequeños en relación al incremento en el uso de estos lenguajes de alto nivel.  Como Evans and Darlay \cite{EvansDarlay} indican:
"\textit{Nosotros encontramos que, hablando en términos generales, un análisis cercano de casi todas las principales técnicas de depuración de los lenguajes en ensamblador, existe al menos un sistema de depuración perteneciente a algún lenguaje de alto nivel.  Sin embargo, las facilidades de la depuración en linea para los lenguajes de alto nivel son en general menos desarrolladas y menos utilizadas (relativo al uso de estos lenguajes) que sus contrapartes para lenguajes en ensamblador}".

En general, los sistemas construidos son meramente copias de los depuradores en línea de los lenguajes en ensamblador, más que diseños de facilidades totalmente nuevas para los lenguajes de alto nivel.  Ellos no han creado ni formatos gráficos en los cuales se presente información acerca de la depuración, no han entregado una manera razonable con la cual los usuarios puedan especificar el proceso requerido en cualquier depurador de información disponible.

EXDAMS, es un intento por quebrar este impasse entregando un ambiente simple en el cual los usuarios pueden facilmente añadir nuevas funcionalidades a un depurador en línea sin tener que modificar mayormente el compilador a nivel de código fuente, ni EXDAMS, o sus programas para que sean depurados.


			\subsubsection{Motivación}

EXDAMS, es un sistema depurador y monitor en línea diseñado para facilitar la experimentación con nuevas herramientas de ayuda que cumplan estas mismas características, y para proveer alternancia de forma flexible entre estas ayudas.  Es importante señalar que en esta herramienta el tiempo de ejecución es controlado en cualquiera de los sentidos adelante o atrás.

			\subsubsection{Características}

Es un poderozo depurador y monitor a nivel de código fuente para lenguajes de programación.  Sus facilidades son de dos tipos: estático, el cual hace referencia a un punto específico en tiempo de ejecución; y movimiento, el cual cambia en tiempo de ejecución y puede ser visto, en tiempo de ejecución, sin importar la dirección atrás o adelante (ejemplo: Un usuario puede ver la ejecución de su programa, en reversa, yendo hacía atrás a algún estado anterior).

Adicionalmente, de estas facilidades, las características de ambiente de EXDAMS son:
\begin{enumerate}
	\item Habilidad para alternar, en cualquier punto de ejecución, entre el espacio de los datos (\textit{¿Qué está sucediendo?}) y el espacio de control (\textit{¿Cómo sucedió esto?}), de esta forma asociando una acción del programa con la instrucción exacta que produce la acción.

	\item Fácil extensión para nuevas herramientas de depuración y monitoreo definidas por el usuario.
\end{enumerate} 

			\subsubsection{Objetivos de diseño}

EXDAMS, fue diseñado para satisfacer tres necesidades:
\begin{itemize}
	\item Como un vehículo para probar algunos propuestas, pero sin aplicarlas, para facilidades de depuración y monitoreo en línea.

	\item Como facilidades extensibles las cuales los nuevos depuradores y monitores pueden añadir fácilmente y luego probarlas.

	\item Como un sistema que provee algunas medidas de independencia de no sólo una máquina en particular sobre la cual está siendo ejecutado este, y la particular implementación de un lenguaje que está siendo depurado y/o monitoreado, sino que además de muchos lenguajes fuentes en los cuales los programas de los usuarios pueden ser escritos y depurados, y/o monitoreados.
\end{itemize}

En una situación perfecta para hacer depuración, de acuerdo con la filosofía de EXDAMS, el usuario primero establece \textit{que es lo que está sucediendo}, luego decide si ese comportamiento es correcto, y finalmente, si este no es correcto, determina \textit{como} el programa efectuó esa operación, al mismo tiempo que busca el error en el programa o en la información.  De esta manera, cualquier sistema de depuración y monitoreo exhaustivo debe incluir facilidades poderosas en los espacios de información y control, como también proveer una manera simple de alternancia entre los puntos correspondientes en cualquier espacio, como las necesidades del usuario o preferencias personales le indiquen.

			\subsubsection[Depuración y monitoreo]{Depuración y monitoreo dentro de EXDAMS}

EXDAMS contiene dos tipos de asistencia para la depuración y monitoreo:

\begin{itemize}
	\item \textbf{Asistencia estática :} Muestra información que es invariable en relación al tiempo de ejecución (una marca de tiempo es incrementada como cada instrucción del código es ejecutado y usado para referir un punto particular en la ejecución del programa), como son los valores de variables al momento de ocurrir un error, una lista de todos los valores de las variables que fueron dadas en tiempo de ejecución, o una muestra de una porción del código fuente.

	\item \textbf{Asistencia dinámica :} Esta asistencia es sensible al tiempo de ejecución, esto es, la información que ella muestra puede variar con el tiempo de ejecución.  Esta asistencia dinámica incluye el último valor de \textit{n} de un conjunto de variables, la instrucción actual y la subrutina, además del valor actual del conjunto de variables.  El usuario puede ejecutar la asistencia dinámica en cualquiera de las direcciones, adelante y atrás, controlando el tiempo de ejecución.

\end{itemize}

Las características más importantes, desde el punto de vista del usuario son:

\begin{itemize}
	\item La habilidad para controlar el tiempo de ejecución de su programa, moviendo una variable rápidamente hacia atrás o adelante, mientras el depurador y/o monitor actualiza constantemente su despliegue de información.

	\item La habilidad de detenerse en cualquier punto en tiempo de ejecución del programa, cambiando al otro asistente, y examinando concienzudamente el comportamiento de su programa.

\end{itemize}

			\paragraph[Análisis de flujo]{Análisis de flujo invertido}

Mediante la llamada de \textit{FLOWBACK FOR} (instrucción reservada de EXDAMS) y especificando un valor en particular, el usuario solicitará a EXDAMS analizar \textit{¿Cómo la información fluyó a través de su programa para producir el valor especificado?}.  Este análisis es presentado en la forma de un árbol invertido, con el nodo de más abajo correspondiente al valor del cual el análisis inverso fue solicitado.  Cada nodo consiste en una instrucción de asignación a nivel de código de lenguaje que produjo el valor, el valor mismo, y conectado con los nodos del siguiente nivel.  Estos nodos corresponden a valores no constantes dentro de la instrucción de asignación mostrada que está conectada con esos nodos.  Esos nodos tienen la misma forma como el original y están conectados para todos los valores no constantes utilizados en una instrucción de asignación en particular produciendo su valor.  De esta manera, la siguiente figura muestra en análisis de flujo invertido para un valor particular de $A$. 

Esta figura muestra que la instrucción de asignación $A=B+C-10;$ produjo un valor específico de $A$, y este valor fue $105$.  Los valores de $B$ y $C$ usados en la asignación de $A$ fue $8$ y $107$, respectivamente, y fueron producidas mediante las instrucciones de asignación $B=R-1;$ y $C=A+E;$ respectivamente.  Cada uno de los otros nodos se explican de la misma manera.

A continuación se muestra un ejemplo de flujo invertido:
\begin{footnotesize}
\begin{center}
\psframebox[linearc=0.5cm,cornersize=absolute] {
	\psset{arrows=->}\pstree [treemode=U, nodesep=4pt]
		{\Toval[fillstyle=solid,fillcolor=lightgray] {$A = B + C - 10 \rightarrow 105$} }
		{
			\pstree
				{\Toval{$B = R -1 \rightarrow 8$}}
				{
					\pstree
						{\Toval{$R = D - 5 + S \rightarrow 9$}}
						{
							\Tcircle{$D$}
							\Tcircle{$S$}
						}
				}
			\pstree
				{\Toval{$C = A + E \rightarrow 107$} }
				{
					\Toval{$A = 100 \rightarrow 100$}
					\pstree
						{\Toval{$E = D\cdot ({R\over K}) \rightarrow 7$}}
						{
							\Tcircle{$D$}
							\Tcircle{$R$}
							\Tcircle{$K$}
						}
				}
		}
	}
\end{center}
\end{footnotesize}


			\subsubsection{Arquitectura}

EXDAMS es un sistema que cuenta de cuatro fases.  Estas fases son: análisis del programa, compilación, recolección de historia y depuración en tiempo de ejecución, con navegación a través de la historia del programa.

				\paragraph{Análisis del programa}

La primera fase analiza el programa fuente del usuario como efectúa las cuatro funciones, la más importante de las cuales es la creación de un modelo para este programa.  Este modelo, el corazón de la fase depuración en tiempo de ejecución con navegación a través de la historia del programa, es la manera por la cual los valores recolectados sobre la cinta de la historia son interpretados y por la cual porciones del código fuente son recuperados, y es el repositorio de toda la información estructural conocida acerca del programa.

En general, la historia contiene toda la información dinámica necesaria para actualizar en tiempo de ejecución cuando se vaya en las direcciones hacia atrás o adelante, mientras el modelo contiene todo lo necesario sobre la información estática.

El modelo contiene la información estática de control y la información variable de alteración del programa del usuario.  La información de control consiste en la estructura del programa acerca de \textit{CALL}, \textit{GOTO}, \textit{IF-THEN-ELSE} y \textit{DO-END}, mientras que la información variable de alteración consiste en los nombres de las variables sobre el lado izquierdo los cuales son afectados por instrucciones de asignación y las cuales a la vez pueden ser alteradas por instrucciones de entrada.

Las instrucciones de depuración añadidas al programa pasan la información relevante de tiempo de ejecución hacia  la recolección de historia en tiempo de ejecución.

				\paragraph{Compilación}

El procesador estándar del lenguaje fuente compila el programa fuente actualizado durante el análisis del programa.

				\paragraph[Recolección de historia]{Recolección de historia en tiempo de ejecución}

La versión compilada del programa actualizado es ejecutada con un conjunto de rutinas en tiempo de ejecución que este llama.  Estas rutinas reúnen la información dinámica acerca del comportamiento del programa.

Esta información es completada en un buffer que es escrito cuando se llena.  Esta es la cinta de historia del comportamiento del programa y, junto con la tabla simbólica y el modelo, es suficiente para recrear el comportamiento del programa en cualquiera de las direcciones (atrás o adelante) en tiempo de ejecución.

				\paragraph[Historia del programa]{Depuración en tiempo de ejecución con navegación a través de la historia del programa.}

Esta fase contiene a los asistentes para depuración y monitoreo los cuales presentan la información histórica hacia el usuario de una manera usable en su pantalla.  Esto además interpreta los comandos del usuario para mostrar alternativas y/o variaciones en tiempo de ejecución, y entrega la capacidad de editar para modificar bug descubiertos y para retornar el programa modificado a las cuatras fases para un nuevo proceso de depuración.


	\section{Implementaciones recientes}

En esta sección consideraremos ODB - Omniscient Debugger, como la implementación reciente más importante.

		\subsection{ODB}

ODB es una implementación Java que recolecta información mediante la instrumentación del bytecode del programa objetivo, al momento que éste es cargado.  Utiliza un mecanismo simple de alto nivel para ordenar los eventos de diferentes hilos.  ODB ha sido probado en MacOS, UNIX, y Windows sobre una gran variedad de programas.

Para un depurador gráfico como este, existen dos temas de vital importancia:
\begin{enumerate}
	\item Presentación de la información; \textit{¿Cómo el programador puede obtener desde el depurador, el estado del programa que le interese?}
	\item Navegación; \textit{¿Cómo el programador reconoce el estado?}
\end{enumerate} 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/ODB/main.eps}
	\caption{Ventana principal de depuración}
	\label{mainWindow}
\end{figure}

			\subsubsection{La naturaleza de los bug bajo ODB}

ODB divide a los bug en dos dimensiones:  \textit{¿Todos los eventos registrados para el bug caben en memoria?} y \textit{¿El bug produce una información errónea o este falla al producir una información correcta?}.

				\paragraph{La serpiente en el pasto}

Si el programa imprime \textit{la respuesta } $41$ en vez de $42$, entonces se tiene un manejador sobre el bug.  Se observa la serpiente en el pasto y se puede agarrar su cola.  Ahora si el programa falla al producir la respuesta correcta, entonces no se tiene un manejador directo del bug, esta es la serpiente en el pasto que no podemos ver.

Para programas en los cuales todos sus eventos son registrados en memoria y en los cuales se pueda ver la serpiente en el pasto, entonces ODB es absolutamente efectivo.  Es posible comenzar sobre la salida errónea e ir hacia atrás, encontrando el valor inapropiado en cada punto, y luego seguir este valor hasta su causa. (Si se tiene la cola de una serpiente y se tira lo suficientemente fuerte, se obtendrá su cabeza.). Es común iniciar el depurador, seleccionando la salida errónea, y navegar por todo el código fuente en $60$ segundos, con absoluta confianza.

Los depuradores basados en punto de quiebre sufren del problema \textit{La lagartija en el pasto}.  Incluso cuando ellos pueden ver la lagartija y tirar de su cola, la lagartija quebrará su cola y se irá.  Luego ellos vuelven a otro problema \textit{La lagartija perdida en el pasto}.

Con ODB, existe una versión de este problema.  Cuando la producción incorrecta es causada por la falla de un determinado objeto cuando está siendo asignado, entonces se tiene que responder la pregunta \textit{¿Quién pudo haber echo esto?}, la cual es una pregunta mucho más difícil que \textit{¿Quién hizo esto?} (Esta es la lagartija sin pata en el problema del pasto).  Se piensa que tenemos una serpiente, pero después de tirar su cola por un momento, esta la quiebra de cualquier forma.

Para problemas relativamente pequeños (digamos 10.000 eventos), esto es fácil y basta con sólo examinar por completo las huellas de asignación de los métodos.  Para problemas más grandes, la \textit{serpiente perdida en el pasto}, se tornan más problemáticos.  Se tiene una gran cantidad de información acerca de la asignación y una idea no muy cierta de lo que estamos buscando.

Afortunadamente, el problema anterior es un caso profundamente analizado, ODB incorpora la función \textit{get()} de Ducassé \cite{ducasse}.

				\paragraph{Tamaño}

Otra dimensión importante es el tamaño.  Dentro de un espacio de direccionamiento de 31-bit, existe espacio para almacenar alrededor de 10 millones de eventos.  Un gran porcentaje de los bug reales se encuentran dentro de este espacio, un buen porcentaje no.  Existe un número de opciones para atacar este problema:
\begin{itemize}
	\item Recolector de basura, tirar a la basura a los eventos antiguos
	\item Instrumentar pocos métodos
	\item Registrar por poco tiempo 
\end{itemize}

					\subparagraph{Recolección de basura}

Esto es bueno porque no requiere esfuerzo y efectivamente mantiene una ventana de eventos circundante al bug.  Por el contrario esto es malo porque no se elimina basura, si no que sólo eventos antiguos que pudieran ser importantes.  Además es malo porque permite el programa correr lo bastante para que el rendimiento se convierta en un tema importante.  Añade un $50$\% extra sobre el mayor de los costos promedio para un evento.

Cuando la fuente del bug está dentro de los 10 millones de eventos en el momento cuando la grabación se apague, entonces se vuelve al bien conocido problema de \textit{la serpiente en el pasto}. Cuando este va más lejos, nosotros perdemos la fuente del bug, y el recolector de basura pierde su valor.

					\subparagraph{Código seguro}

Es común que para un programa exista un gran porcentaje de código fuente seguro (Cualquier método recomputable, o métodos que no se quieren ver al interior de ellos).  Mediante la solicitud que estos métodos no sean instrumentados, muchos eventos que no son interesantes son eliminados.  ODB permite al programador seleccionar arbitrariamente un conjunto de métodos, clases, o paquetes, los cuales pueden ser instrumentados o no.

					\subparagraph{Comenzar/Detener registro}

Si el programador sospecha que determinado evento conocido siempre ocurre antes del bug (Ejemplo: Cuando presiona un botón y el programa se cae), entonces el registro puede ser habilitado en ese punto y apagado después del bug.  ODB permite control manual (Existe un botón inicio/fin registro).  Este además permite control automático de la manera que se irá examinando un gran conjunto de eventos por un patrón particular, el cual Comenzará/Detendrá el registro.  Una vez más, esto es precisamente el problema de los analizadores de eventos para lo cual ODB utiliza la función \textit{get()} de Ducassé.

				\paragraph{Implementación}

ODB mantiene un array sencillo de marca de tiempos.  Cada marca de tiempo es un entero de 32 bit, conteniendo un índice de hilo (8 bits), un indice de línea (20 bits) y un indice de tipo (4 bits).  Un evento para cambiar una instancia de una variable necesita tres palabras: una marca de tiempo, la variable que ha cambiado, y el nuevo valor.  Un evento para una llamada de método necesita: objeto, nombre del método, los argumentos y el valor de retorno (o excepción), junto con un pequeño conjunto de variables internas propias del depurador.  Esto añade cerca de 20 palabras, la instrucción return line además generará 10 palabras más.

Cada variable tiene un historial asociado que es sólo una lista de pares marca de tiempo/valor. Cuando ODB quiere saber el valor de una variable en el tiempo $102$, este justo toma el valor que está más cerca al valor previo.  La lista de historia para variables locales y argumentos cuelgan sobre la línea de huella.

Siempre que ocurra un evento, este bloquea por completo el depurador, una nueva marca de tiempo es generada y registrada dentro de la lista, y estructuras asociadas son construidas.  Los valores de retorno y excepciones son agregadas dentro de la apropiada línea de huella como estas fueran generadas.

La inserción en el código es muy simple, el bytecode fuente es examinado, y un código instrumentado es insertado antes de cada asignación y cerca de cada llamada de método.

Una inserción típica luce de esta forma:

\begin{singlespace}
\begin{verbatim}
289 aload 4   // nuevo valor
291 astore_1 // variable local ie
292 ldc_w #404 <String "Micro4:Micro4.java:64">
295 ldc_w #416 <String "ie">
298 aload_1 // ie
299 aload_2 // Huella padre
300 invokestatic #14 <change(String, String, Object, Trace)>
\end{verbatim}
\end{singlespace}

Donde el código original son las líneas $289$ y $291$, asignando un valor a la variable local \textit{ie}, la instrumentación crea un evento registra que sobre la línea $64$ de Micro.java(\#292), la variable local \textit{ie}(\#295), de quien su lista de historia puede ser encontrada sobre la línea de huella en el registro $2$ (\#299), le fue asignada al valor en el registro $1$ (\#298), los otros tipos de eventos son similares.


	\section{TOD: Depurador orientado a la huella para Java}
		\subsection{Contribución}

La contribución de este trabajo es mostrar que la depuración omnisciente puede ser realizada a través del uso de diferentes técnicas mejorando factores como la eficiencia, escalabilidad y usabilidad.  Lo planteado es validado por TOD, un depurador portable orientado a la huella para Java integrado dentro de ECLIPSE \cite{eclipse}.  Las características de TOD son:
\begin{itemize}
	\item \textbf{Eficiente generación de eventos}: Basado en un compacto modelo de huella, un uso de codificación binaria de eventos, y un rápido tejedor de bajo nivel.

	\item \textbf{Máquina especializada de base de datos distribuida}: Para un almacenamiento escalable, rápido y consultas sobre eventos, que aprovecha la muy limitada naturaleza de la ejecución huellas.  En unos 10 nodos dedicados en cluster, TOD mantiene una tasa sustancial de entrada de 170.000 eventos por segundo y cientos de consultas por segundo.

	\item \textbf{Soporte para huellas parciales}: Ofreciendo mecanismos estáticos y dinámicos para la generación selectiva de la huella, y un reporte adecuado para la información incompleta.

	\item \textbf{GUI informativa}: Debido a la eficiencia del procesamiento de consultas, TOD es utilizado para depurar una aplicación compleja como eclipse preservando su interactividad.

	\item \textbf{Componentes especializados de GUI}: Entregando una vista de alto nivel en huellas grandes de eventos para una navegación mucho más efectiva, como el mural de hilos.
\end{itemize}


		\subsection[Desafíos]{Desafíos de la depuración omnisciente}

	Se presentan las características principales de un depurador omnisciente comparado con los depuradores tradicionales, y el perfil de los desafíos de escalabilidad de la depuración omnisciente.

			\subsubsection[Características]{Características de un depurador omnisciente \label{caracteristicasDepurador}}

	Un debugger omnisciente(OD; DO) entrega cuatro características principales:
\begin{itemize}
	\item \textbf{Paso (stepping)}: En depuradores basados en punto de quiebre, stepping consiste en la ejecución del programa objetivo una instrucción a la vez.  Existen dos variaciones del stepping:
	\begin{itemize}
		\item Step over ejecuta el método sin estar esperando dentro del llamado del mismo, mientras que el 
		\item Step into espera a la primera instrucción (comienzo) de la llamada del método.	
	\end{itemize}	
	
	\item \textbf{Estado de reconstitución}: Reconstitución del estado consiste en ir entregando al programador un objeto de estado inspector cuando el programa objetivo está esperando.		
	\item \textbf{Reconstitución del control del flujo}: Reconstitución del control de flujo permite obtener una vista en la llamada de la pila actual del programa, con ligadura a variables y objetos.	
	\item \textbf{Encontrar la causa principal}: OD's extiende estas tres características con completa libertad en relación al tiempo:  stepping puede ser realizado tanto hacia adelante como hacia atrás, los programadores pueden inspeccionar el estado de objetos como estaban en cualquier punto del tiempo, y pueden libremente navegar por el árbol de control.	
	
\end{itemize}
La última es una característica única de los depuradores omniscientes, mientras que las otras son características de los depuradores típicos.

	Finalmente, una de las características más usadas de OD's es su habilidad para encontrar \textit{dónde} y \textit{en qué contexto}, a un campo o variable en particular le fue entregado un determinado valor.  Frecuentemente los bugs se manifiestan mucho después de suceder su causa principal.  Para ejemplo, tratar de referirnos a una referencia \textit{NULL} obtenida desde un campo dado causa una caída, esto es el síntoma del bug.  La información que el programador necesita saber es dónde el campo fue definido con el valor \textit{NULL}.  Con un depurador basado en punto de quiebre, incluso si la ejecución es pausada justo antes del imperfecto referido, la causa raíz del bug pudo haberse perdido.  Ejemplo:  Porque el código que causó el problema ya no está más en la pila de llamadas.


			\subsubsection{Desafío de escalabilidad \label{escalabilidad}}

Destacando las características presentadas sobre la necesidad de generar y registrar las huellas de ejecución.  El potencial crecimiento de estas huellas plantean diversos desafíos de escalabilidad, cuando son la principal razón que afecta a la calidad de producción de OD's.

Los eventos deben ser grabados rápidamente, preferentemente en tiempo real, como que (a) la depuración puede comenzar inmediatamente después que el programa objetivo haya terminado o caído, y (b) el desbordamiento en tiempo de ejecución es minimizado para preservar sobre todo el desempeño del programa depurado y la interactividad cuando se necesite.

El depurador puede causar una interferencia mínima al programa objetivo en el sentido de no afectar su comportamiento.  En particular, la administración del espacio de direcciones y de memoria del proceso objetivo no puede ser alterado.

La capacidad del almacén de eventos de un depurador omnisciente debe estar alineado con un número esperado de eventos dentro del uso total de la huella; en procesadores con capacidad de procesamiento de GHZ, cientos de millones de eventos pueden ser generados en solamente pocos minutos de ejecución.

\begin{figure}[hpb]
	\centering
	\includegraphics[scale=0.5]{images/TOD/TODArchitecture.eps}
	\caption{Arquitectura de alto nivel de TOD}
	\label{TODArchitecture}
\end{figure}

Consultas dentro la huella de ejecución deben ejecutarse a una velocidad compatible con la interacción del usuario; por ejemplo: en décimas de segundos para operaciones como el stepping.
La información debe ser presentada de una manera que trata que la carga cognoscitiva de la navegación a través de la enorme huella de los eventos sea la menor posible, permitiendo una rápida identificación de los errores.

 	Este trabajo se encamina en el uso optimizado de las representaciones de los eventos e indexación agresiva, un modelo simple de consulta, soporte para una una base distribuida, soporte para huellas parciales y componentes de presentación e interacción especializados.

		\subsection{Acerca de TOD}

TOD es un depurador omnisciente orientado a la huella para Java, que se dirige sobre la identificación del uso de la escalabilidad.  El objetivo es dirigir esos usos en el orden para obtener un depurador omnisciente que es prácticamente aplicable.  Esta sección da un panorama de TOD en el sentido de su arquitectura, el modelo de evento, y los componentes de la GUI.

			\subsubsection{Arquitectura}

TOD es diseñado basándose en dos ideas centrales:

\begin{itemize}
	\item Desacoplar el núcleo del depurador desde el programa objetivo en ejecución.
	\item Ser portable.  
\end{itemize}

Esto es hecho sobre un árbol de componentes (Figura \ref{TODArchitecture}):  el objetivo (JVM) en el cual el programa depurado se ejecuta y emite eventos, el núcleo del depurador que implementa las principales funcionalidades de TOD, y la interfaz del depurador a través del cual el usuario a la misma vez consulta y navega en la huella de ejecución.

La racionalidad para almacenar los eventos en una base de datos preferentemente que están en memoria como huellas en otros depuradores omniscientes \cite{odb, bitd, zstep} está precisamente dirigido a algunos de los desafíos discutidos en la sección \ref{escalabilidad}:  almacenar eventos en el espacio de dirección de la aplicación objetivo no es escalable para unos cuantos cientos de megabytes de información de la huella, e interfiere con el administrador de memoria, en particular con el colector de basura.  El costo de captura se incrementa por el uso de una base de datos que es compensado por una mejor escalabilidad y sin generar intrusión.  Como efecto secundario esto permite a los depuradores \textit{post-morten} tener la habilidad de serializar la huella de ejecución, lo que abre una interesante perspectiva para las compañías de software dispuesta a ofrecer software con alta calidad de soporte:  observando el costo de almacenamiento, una huella de ejecución navegable es una información lejos mucho más relevante para reportar un bug que un texto descriptivo apropiado. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/TOD/EventsAttributes.eps}
	\caption{Eventos y sus atributos}
	\label{EventsAttributes}
\end{figure}

De la figura debemos destacar que la cabecera de las filas son tipos de eventos y la cabecera de las columnas son posibles argumentos (ts: tiempo, tid: identificador del hilo, depth: llamada a la pila en profundidad, pev: puntero al padre del evento, LOC: localidad del código fuente, fid: identificador de celda, bid: identificador del método, vid: identificador de variable local, idx: índice, val: valor, ret: valor de retorno, tgt: objetivo, vxc: excepción; args: argumentos).

Durante la ejecución, la aplicación objetivo emite eventos que son enviados al núcleo del depurador, donde ellos son grabados e indexados en una base de datos de eventos.  El tema de los eventos que son emitidos es discutido posteriormente.  La base de datos de los eventos contiene las particularidades del curso del evento y el conjunto restrictivo de posibles consultas que entrega, entre el alto rendimiento de grabación y el buen desempeño de las consultas.  El núcleo del depurador contiene otra base de datos, la base de datos estructural, que contiene información estática sobre la aplicación objetivo.  En particular realiza un seguimiento de identificadores de 32 bits que son asignados a elementos estructurales del programa objetivo (por ejemplo: clases, métodos y campos(celdas)).  Las consultas son efectuadas por el usuario basándose entre el evento y la base de datos estructural.

			\subsubsection{Representación y emisión de eventos}

Introducimos ahora a la representación de los eventos y las huellas de estos, así como también los eventos son emitidos por la aplicación depurada en TOD.

\begin{itemize}

	\item \textbf{Modelo de evento y huella}: Un evento es una estructura caracterizada por un número de atributos elegidos entre el conjunto $A={a_0,\dots ,a_k}$. Observemos $e.a_j$ el valor del atributo $a_j$ del evento $e$.  Para cada $j$ perteneciente $[0\dots k]$, dejamos $D_j$ como el dominio de $a_j$, por ejemplo el conjunto de todos los valores distintos que pueden ser tomados por $a_j$, para cualquier evento dentro de la huella.  Una huella del evento $T=<e_{1},\dots ,e_{n}>$ es una secuencia ordenada de $n$ eventos heterogéneos.

El atributo $a_{0}$ corresponde a la marca de tiempo del evento; este es caracterizado por el hecho que (a) todos los eventos tienen un valor para $a_{0}$, (b) allí existe un completo orden sobre $D_{0}$ y (c) los eventos en $T$ están ordenados por sus valores de $a_{0}$. La figura \ref{EventsAttributes} muestra cuales eventos concretamente son capturados y cuáles son sus atributos.

	\item \textbf{Emisión de los eventos} El núcleo del depurador de TOD captura los eventos emitidos por la aplicación objetivo (Figura \ref{TODArchitecture}).  Existen tres vías en las cuales los eventos pueden ser emitidos:  puertos especializados de la huella del hardware \cite{rtmdt},  máquina virtual o interpretador de instrumentación \cite{rooi}, y aplicación de instrumentación \cite{odb,zstep}.  TOD utiliza la última, aunque no es tan rápida como las pruebas de hardware y significativamente utiliza más espacio que el nivel de instrumentación de máquina virtual, en términos de tamaño de código, la instrumentación de aplicación es mucho más portable y fácil de implementar.

En TOD, la JVM\footnotemark[1] que está alojada en la aplicación objetivo está configurada para usar el agente  JVMTI\footnotemark[2] .  El agente intercepta los eventos cargados por la clase y reemplaza las definiciones originales por la versión instrumentada.  La Instrumentación es realizada por el tejedor en el núcleo del depurador:  
\footnotetext[1]{Maquina Virtual de Java}
\footnotetext[2]{Interfaz de herramienta de la máquina virtual de Java, parte de la plataforma de Java 5.}
\begin{itemize}
	\item El agente envía el bytecode original al núcleo  
	\item El tejedor implementa la clase y almacena estructuradamente la información en la base de datos estructural
	\item La clase modificada es enviada nuevamente a la JVM objetivo donde es eventualmente cargada (Figura \ref{TODArchitecture}).  El agente toma la clase instrumentada del disco duro para reducir el número de turnos de los procesos internos.  Esto es  particularmente usado por el uso frecuente de las clases como algunas en el JDK.
\end{itemize}


La instrumentación se efectúa utilizando la librería de bytecode ASM \cite{asm}:  el código de captura del evento es añadido antes y/o después de un patrón específico de bytecode en el código original, tal como un campo de escritura o una llamada a un método.  Cuando el código instrumentado es ejecutado, los eventos son construidos a partir de sus atributos, serializados en un formato binario personalizado, y enviados a través de un socket a la base de datos de eventos.

	\item \textbf{Sincronización no ambigua del evento}: Aunque las marcas de tiempo del evento son obtenidos a través del servicio de precisión en nano segundos de Java, es potencialmente carente de exactitud, haciendo posible que varios eventos del mismo hilo tengan el mismo valor de marca de tiempo.  Como esto es incompatible con el esquema de indexación usado por TOD, se cambió el valor original del timestamp por unos bits a la izquierda y se usan los bits libres para diferenciar eventos del mismo hilo que sea parte de la misma marca de tiempo.  Cuando se compara la marca de tiempo de los eventos de diferentes hilos, se usa la marca de tiempo original para preservar el orden de los hilos internos(inter-thread).

	\item \textbf{Alcance de la captura de huella}: El esquema de instrumentación descrito anteriormente es selectivo, esto es, posible de proveer filtros definidos para los usuarios que limite el número de eventos emitidos.

	\item \textbf{Identificación del objeto}: El agente JVMTI de TOD asigna un único identificador para cada objeto en la aplicación objetivo.  Como una excepción a este mecanismo las instancias de los objetos que representan valores primitivos (por ejemplo entero, decimal, etc) tales como las cadenas y excepciones son pasadas por valor.
\end{itemize}

			\subsubsection[Bajo nivel de consultas]{Bajo nivel de consultas: cursores y contadores}

	Todas las características presentadas en la sección \ref{caracteristicasDepurador} (paso a paso, reconstitución de estado, reconstitución del control de flujo y encontrar la causa raíz) pueden ser expresados en términos de dos niveles de consultas de bajo nivel:  cursores y contadores, que se introduce a continuación.  Ambos basados en el filtrado de eventos de la huella de acuerdo a algunas condiciones de sus atributos.  Condiciones que pueden ser cualquier combinación booleana de simples predicados de la forma $attribute = value$, donde $value$ es una constante.  Para la instancia $(kind = FW$ o $kind = BC)$ o $target = obj145$.  Si $Q$ es una condición y $e$ es un evento, definimos el predicado de la función $Q(e)$ cuyo valor es verdadero si $e$ verifica la condición $Q$.

\begin{figure}[hpb]
	\centering
	\includegraphics[scale=0.4]{images/TOD/CursorExample.eps}
	\caption{Navegación entre la unión de los eventos y el predicado del cursor}
	\label{cursorExample}
\end{figure}

De la imagen se debe notar que la posición actual del cursor está representado por la línea negra entre los eventos cuatro y cinco.  Los Eventos que juntan el predicado del cursor están en gris.  Se llaman sucesivamente a \textit{next()} retornando los eventos 5,6,11 y 14;  llamando \textit{posNext(11)} la posición del cursor estará entre los eventos 10 y 11; llamando \textit{posPrev(11)} las posiciones estarán entre los eventos 11 y 12.

\begin{table}[!h]
\begin{center}
\begin{tabular}{| r | l |}
\hline
\rowcolor[gray]{0.9}Operación & Semántica (significado)\\
\hline
next() / prev() & Retorna el siguiente/previo unión de eventos y mueve el \\
                       & cursor hacia adelante/atrás.\\
\hline
posNext(t) / posPrev(t) & Mueve de modo que la siguiente llamada a \textit{next()}/\textit{prev()}\\
                                     & retorna el primero/ultimo evento cuya marca de tiempo \\
                                     & es mejor/peor que o igual que \textit{t}.\\
\hline
posNext(ev) / posPrev(ev) & Mueve de modo que la siguiente llamada a next()/prev()\\
                                           & retorne el evento dado.\\
\hline
\end{tabular}
\caption{Operaciones de los cursores}
\label{operacionesCursores}
\end{center}
\end{table}


\begin{itemize}
	\item \textbf{cursores} Definimos cursor($Q$) como un iterador sobre los eventos que reúnen la condición $Q$ (Figura \ref{cursorExample}).  Los cursores tienen una posición actual que está situada entre dos eventos consecutivos (o hacia el principio o el término de la huella).  Un cursor soporta un número de operaciones de navegación, como las mostradas en la tabla \ref{operacionesCursores}.

	\item \textbf{contadores} Entregan un intervalo de tiempo $[t1,t2]$ dividido en $s$ porciones de largo $\delta t = (t1,t2)/s$ cada uno, y una condición $Q$ para los atributos del evento, una consulta de contador retorna un arreglo de $s$ enteros tales que $s[i] = | {e \in T: dentro(e, t1 + i*\delta t) \wedge Q(e)} |$ donde $dentro(e,t) < = > e.ts > = t  \wedge e.ts < t + \delta t$.   Cada posición del arreglo contiene el número de eventos unidos $Q$ que ocurrieron durante la correspondiente porción de tiempo.
\end{itemize}

			\subsubsection{Alto nivel de consultas}

A continuación se explica como los cursores y los contadores son combinados algoritmicamente para implementar el alto nivel de las características descritas anteriormente.

\begin{itemize}
	\item \textbf{Stepping}: Definimos stepper como un objeto que tiene un evento actual $ev$ y soporta operaciones paso hacia adelante y hacia atrás, paso dentro y paso sobre.  Por ejemplo, paso hacia adelante dentro es definido como sigue:

	$c \leftarrow cursor(thread = ev.thread)$\\
	$c.posPrev(ev); ev \leftarrow c.next()$

Paso hacia adelante sobre, cambia la condición del cursor $a: thread = ev.thread \wedge depth = ev.depth$.  Paso atrás es simétrico al paso hacía adelante.

	\item \textbf{Reconstitución de estado}: El valor $v$ de una celda $f$ de un objeto en particular $o$ con tiempo $t$ puede ser recuperado como sigue:

	$c \leftarrow cursor(kind = FW  \wedge fid = f \wedge target = o)$\\
	$c.posPrev(t); v \leftarrow c.prev().val$

El estado de un objeto puede ser recuperado realizando la misma operación para cada uno de los campos.  La pila de marcos son reconstituidos en una manera similar, usando eventos de escritura variables instanciados de la celda de eventos escritos.

	\item \textbf{Reconstitución del control de flujo}: Los eventos que ocurren en el alto nivel del control de flujo de una llamada dada del método $e$ son recuperados de la siguiente manera:

	$c \leftarrow cursor(thread = e.thread  \wedge depth = e.depth + 1)$\\
	$c.posPrev(e.ts); cflow = <>$\\
	\textbf{repeat}\\
	$ev = c.next(); cflow \leftarrow cflow  \sqcup <ev>$\\
	\textbf{until} $ev.kind = BEx$\\

	\item \textbf{Buscador de la causa inicial}: Determinando como a un campo ha sido asignado un valor indeseado, es tan directo como la consulta de la reconstrucción del estado:  en lugar de obtener el valor del evento de la celda escrita que asignó el valor al campo, el evento por sí mismo se hace el actual, dando acceso para el contexto en ese momento.  La exploración atrás en el tiempo es la causa que pueda ir sobre esto, encima de la causa inicial.
	
\end{itemize}

			\subsubsection{Componentes de la interfaz gráfica}

La interfaz de TOD puede ser usada independiente o como una añadidura para el IDE de Java llamado Eclipse (Figura \ref{screenShotCFlow}).  El navegador de usuario entre diferentes vistas utiliza las ampliamente conocidas metáforas de los navegadores Web (hiper vínculos, botón hacia atrás, etc).  Las vistas disponibles son:  inspector de objetos, control de flujo, y mural.  

\begin{itemize}	
	
	\item \textbf{Vista de inspección de objetos}: Muestra la reconstitución de objetos, y permite encontrar la causa inicial por valor de celdas a través de un conveniente ¿por qué? link a cada campo siguiente. 
	
	\item \textbf{Vista de control de flujo}: Muestra una constitución del flujo de control y permite las operaciones de stepping así como encontrar la raíz de la causa para valores de variables locales.

	\item \textbf{Murals}: Las descripciones del nivel alto son útil para marcar patrones anormales del comportamiento.  Sin embargo representando un número fuerte de eventos en un limitado número de píxeles es difícil.  Jerding y Stasko introdujeron la información del mural \cite{mural} como una \textit{reducción de la representación de la información del espacio entero a uno que se ajusta completamente dentro de una ventana mostrada}.  Las características de los eventos murals de TOD, los cuales son gráficas que muestran la evolución de la densidad del evento, o un número de eventos por unidad de tiempo, en un periodo dado.  Por ejemplo, TOD puede mostrar la densidad del evento por cada uno de los hilos para el conjunto de ejecución de la aplicación objetivo (Figura \ref{threadMurals}), o la densidad de llamadas a métodos de un objeto en particular.  Las densidades son obtenidas a través  de los contadores, donde el largo de las tajadas de tiempo correspondiente al espacio utilizado por un simple pixel de la barra en el mural.  El usuario puede hacer un acercamiento y ver el mural;  cuando el nivel de acercamiento permite distinguir los eventos individuales del usuario y puede seleccionar un evento y ver el contexto dentro de una vista de paso.  El mural de hilos tiene distintas aplicaciones, por ejemplo: Entender la interoperación entre los hilos.
	
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{images/TOD/ScreenShotCFlow.eps}
	\caption{Navegación con TOD en Eclipse}
	\label{screenShotCFlow}
\end{figure}

De la figura anterior se debe notar que el botón (A) lanza el programa con la traza registrando la huella.  El usuario navega en el control de flujo (B) utilizando los botones de paso (C), o por medio de un click sobre el evento.  La línea correspondiente al evento actual está resaltada en la ventana del código (D).  El estado de la pila de marcos y el objeto actual es mostrado en la ventana (E).  El usuario puede saltar de una instrucción que defina el valor actual de una variable o campo por medio de un click en \textit{¿Por qué?} siguiendo a este.


		\subsection{Soporte para base de datos de alta velocidad}

Ahora se describe y se analiza el esquema de indexación de TOD, el cual permite la ejecución eficiente de consultas mientras es lo suficientemente rápida para permitir un alto rendimiento de grabación.

La necesidad de desarrollar un cimiento de base de datos especializada para TOD fue motivado por el bajo rendimiento del uso profundo de la administración de sistemas de base de datos para los propósitos de TOD: PostgreSQL y Oracle sólo soportan almacenar eventos a una taza de 50 y 500 eventos por segundo respectivamente, mientras que en los registros de TOD la taza es del orden de los cientos de millones de eventos por segundo \cite{cots}.  Este alto rendimiento especializado en los cimientos de la base de datos permiten las siguientes especificaciones para el flujo del evento de una huella de ejecución: (a) el flujo del evento es de sólo lectura, (b) los eventos al llegar son ordenados a partir de su marca de tiempo y (c) las consultas son limitadas por el filtrado.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/TOD/ThreadMural.eps}
	\caption{Mural de threads}
	\label{threadMurals}
\end{figure}

El gráfico muestra la densidad de los eventos a lo largo del eje del tiempo.

			\subsubsection{Jerarquía de indexación de los eventos}

TOD adopta un esquema de indexación jerárquica que permite recuperar al evento juntando un predicado en orden según su marca de tiempo sin tener que acceder realmente a los eventos en si, reduciendo así los costos del procesamiento de consultas.

\begin{itemize}
	\item \textbf{Indices en los valores de los atributos}: Usando la notación definida anteriormente, se define el índice de $T$ en $a_j$ como una función $I_j: D_j \rightarrow (D_o,N)^*$ para $j \in [1..k]$ de modo que ningún mapa $I_j$ tenga cualquier posible valor $v$ de $a_j$ una secuencia de índices de entrada de la forma $(ts,i)$.  Una entrada se encuentra en el índice $I_j(v) \Leftrightarrow e_i.a_j = v \wedge e_i.a_0 = ts$, donde $e_i$ es el i-esimo evento de $T$.  Adicionalmente, las entradas son ordenadas por $ts$.  Estos índices pueden ser usados directamente para recuperar todos los eventos que correspondan a una consulta simple de la forma $attribute = value$.
	
	\item \textbf{Jerarquía de indexación por marca de tiempo}: Debido a que las consultas en TOD no consisten sólo en encontrar eventos correspondientes que ocurrieron antes o después de un momento, los índices son ordenados por sus valores de \textit{ts}, entonces es posible presentarlos en una búsqueda binaria para encontrar la marca de tiempo deseada.

Esto es siempre mucho más eficiente para extender el índice de estructura en una manera jerárquica (Figura \ref{hierarchicalIndexes}).  Cada índice jerárquico para el valor $v$ del atributo $a_j$ contiene un número de niveles;  El índice $I_j(v)$ describe sobre la constitución del nivel 0.  La entrada $(ts, i)$ índice del nivel 0 son almacenados en el disco duro en pequeñas páginas, donde cada una contiene un número de entradas pertenecientes al mismo índice.  Cuando una página está llena, una entrada de la forma $(ts,pid)$ es creada en el índice del nivel $1: ts$ es tomado desde la primera entrada $(ts,i)$ de la reciente página llena, y $pid$ es un puntero a esa página.  Las entradas del Nivel 1 están acumuladas en una página; cuando una página del Nivel 1 es llenada, una entrada en el Nivel 2 es creada, y así sucesivamente.  

El nivel más alto siempre contiene una pagina sencilla, llamada la página raíz.  El número de niveles sobre el Nivel 0 de un índice es llamado la altura del índice.  
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.8]{images/TOD/hierarchicalIndexes.eps}
	\caption{Jerarquía de los índices}
	\label{hierarchicalIndexes}
\end{figure}


			\subsubsection{Costo de la creación de un índice}

Los experimentos realizados en el desarrollo de TOD muestran que el tamaño promedio de un evento es $\parallel e \parallel= 50$ bytes.  El tamaño de una entrada de Nivel 0 es $(ts,i) = 16$ bytes (dos enteros de 64 bits).  El tamaño de las entradas de nivel superior es $(ts,pid) = 12$ bytes ($pid$ está en 32 bits).  Las experiencias realizadas en el desarrollo de TOD han determinado que el tamaño de una página óptima es $P = 4096$ bytes, por lo tanto los índices de las páginas de Nivel 0 contienen 256 entradas, en los niveles superiores las páginas contienen 341 entradas y las paginas de eventos contienen 81 eventos en promedio.  La altura $h$ de los índices es logarítmica con respecto al número de entradas y en la práctica nunca excedieron 5 (un índice de altura 5 permite para $341^{5} \approx 4\cdot10^{12}$ entradas)  Asumiendo que la actual página de eventos puede residir en memoria, la página de eventos sólo causa una página escrita cada 81 eventos.

Para cada evento que entre a la base de datos a lo más existirá $k = \mid A\mid-1$ índices que actualizar (como no hay índice separado en $a_{0}$).  Los experimentos indican que el promedio $k = 10$.  Dado ciertos eventos que llegan en orden con respecto $a_{0}$, actualizando un índice sólo pensando en añadir una entrada en el final de la página en el Nivel 0, y en el final de las páginas de nivel superior sólo cuando una página de nivel inferior es llenada.  La entrada/salida y costos de memoria de esta operación son los siguientes:

\begin{itemize}
	\item Si la página de índices actual para cada nivel puede residir en memoria, un costo de E/S es realizado sólo cuando una página está llena.  El número promedio de páginas accesadas por el evento entrante es:
		\begin{displaymath}
{\parallel e \parallel \over P} + k \cdot \sum_{i=1}^{h}{\parallel(ts,i)\parallel \over P}\cdot \left({\parallel(ts,i)\parallel \over P}\right)^i\backsimeq 0.05
		\end{displaymath}

	\item Si sólo la página de índices está en el nivel 0 puede ser mantenida en memoria, cuando una página es llenada debe ser escrita, El nivel de la página leída es el 1, actualizado y escrito en el disco.  Analizando, el nivel más alto, tiene aproximadamente $0.13$ accesos por evento.  

	\item Si la pagina no puede ser mantenida en memoria, cualquier actualización implicará las tres operaciones anteriores, entregando $20$ accesos por evento.
\end{itemize}

	La cantidad de memoria dedicada al buffering de página es por lo tanto lo más importante:  Hay una diferencia de 400 directorios entre la situaciones extremas anteriores.

	Ahora se estima el número total de índices, $\sum_{j=1}^k{\mid D_j\mid}$, en orden de determinar cuántas páginas de buffer de memoria se necesita para permanecer en el caso donde al menos la página actual del nivel 0 para que cada índice quepa en memoria.  Los atributos de los eventos pueden ser divididos en dos categorías.  El dominio de los atributos estáticos (por ejemplo: behavior id, field id, type id, ubicación, etc.) depende solamente de la estructura del programa, no del tamaño de la huella.  En las pruebas con la captura de las huellas en Eclipse, se observó que estos acumulan cerca de 200.000 distintos valores.  Hay dos atributos dinámicos: thread id y object id.  Su dominio puede ser enorme dado que el programa objetivo puede repetitivamente crear y destruir objetos e hilos durante su ejecución.  Sin embargo, sólo una fracción de ellos puede ser usado en cualquier punto dado en el tiempo:  Todos los objetos que viven deben ajustarse dentro de la JVM's objetivo que está disponible en memoria y todos los hilos que viven deben ser razonablemente ejecutados por la CPU.  Así es solamente necesario tener un espacio para el índice del buffer de la pagina para los objetos e hilos usados actualmente.

	El dominio de los  object id's claramente domina todos los dominios acumulados.  Si la aplicación objetivo regularmente usa un millón de objetos, cerca $P\cdot10^6 = 4$ GB de espacio es necesario para el buffer.


			\subsubsection{Costo de recuperación del evento}

	Ahora se presenta los algoritmos que permiten recuperar eventos buscando un predicado arbitrario en la línea de tiempo con respecto al tamaño de los índices involucrados.  Los algoritmos son recuperados en orden respecto a su marca de tiempo; la recuperación al revés tiene el mismo costo.

\begin{itemize}
	\item \textbf{condiciones simples}: Para una condición simple de la forma $a_j = C$ donde $C$ es una constante, podemos recuperar eventos buscados ordenados por marca de tiempo, simplemente obteniendo las entradas $(ts,i)$ desde $I_j(C)$.  Si el evento actual es requerido (por ejemplo: por los cursores), estos son directamente recuperados desde la huella como $e_i$; si no (por ejemplo: para los contadores) el evento no necesita ser accesado.  En cualquier caso, todas las entradas pueden ser recuperadas en la línea de tiempo, debido a que el índice se explora simplemente una vez.

	\item \textbf{condiciones conjuntivas}: Para una conjunción booleana de una condición simple de la forma $a_{j_{1}} = C_1 \wedge \dots \wedge a_{j_{m}} = C_m$, se utiliza una variante del algoritmo sort merge join \cite{sard}, extensamente utilizado en la administración de los sistemas de bases de datos, para identificar los eventos buscados sin accesarlos (Algoritmo \ref{mergeJoin}):  obtenemos el $I_{j_l} (C_l)$ para cada una de las condiciones simples, y por cada uno mantenemos un puntero a la entrada actual $(ts_l,i_l)$.  Entonces iteramos: en cada paso verificamos si todos los $i_l$ son iguales, en este caso añadimos cualquier resultado a las entradas actuales:  El hecho que todos ellos hacen referencia al mismo evento significa que el evento coincide con todas las condiciones.  Entonces se avanza el puntero de índice cuya entrada actual tenga el mínimo valor para la marca de tiempo.  Como cada índice es revisado una sola vez y no existen ciclos anidados, merge join corre en tiempo lineal con respecto a la suma de los tamaños de los índices considerados.

\algsetup{
linenosize=\scriptsize,
linenodelimiter=
}
\begin{algorithm}
\begin{footnotesize}
\begin{algorithmic}
\REQUIRE $(S, j_{1},\dots,j_{m},C_{1},\dots,C_{m})$
\STATE $result \leftarrow 0$
\FOR{$l= 1$ to $m$}
\STATE $index[l] \leftarrow I_{j_{l}}(C_{1}), pos[l] \leftarrow 1$
\ENDFOR
\WHILE{there are more elements}
	\STATE $match \leftarrow \TRUE, ref I \leftarrow -1$
	\STATE $minL \leftarrow -1, minTS \leftarrow +\infty$
	\FOR{$l=1$ to $m$}
	\STATE $(curTS, curI) \leftarrow index[l][pos[l]]$
	\IF{$refI = -1$}
	\STATE $refI \leftarrow curI$
	\ELSIF{$curI \not= refI$}
		\STATE $match \leftarrow \FALSE$
	\ENDIF
	\IF{curTS < minTS}
	\STATE $minTS \leftarrow curTS, minL \leftarrow l$
	\ENDIF
	\ENDFOR
	\IF{$match$}
	\STATE $result \leftarrow result \cup \{s_{ref_{I}}\}$
	\ENDIF
	\STATE $pos[minL] \leftarrow pos[minL] + 1$
\ENDWHILE
\end{algorithmic}
\end{footnotesize}
\caption{MERGE-JOIN}
\label{mergeJoin}
\end{algorithm}


\end{itemize}

		\subsection{Medidas de rendimiento}

Se presentan reportes sobre el primer conjunto de medidas de rendimientos evaluando diferentes aspectos de TOD:

\begin{itemize}
	\item Base de datos distribuida, en términos de registro de eventos y evaluación de consultas.
	\item Sobrecarga efectuada por la emisión de eventos en la aplicación depurada.
\end{itemize}

			\subsubsection{Desempeño de la base de datos}


Para evaluar el rendimiento de la base de datos distribuida de TOD, se han realizado varias mediciones de rendimientos en relación al registro y consultas bajo distintas configuraciones.  Se capturó una gran huella de ejecución de una sesión de Eclipse donde el usuario realizó un simple secuencia de pasos: Abrió un archivo escrito en Java, lo editó utilizando completación automática, creando una nueva clase y la editó. La huella capturada comprende aproximadamente 516 millones de eventos y pesa 20GB.  Luego se importó esta huella dentro de la base de datos de TOD, que utiliza 16 nodos dedicados dentro de un cluster.  En este experimento hasta 10 nodos estaban para ser utilizados como nodos de base de datos, y 1 como disparador y agregador de consultas.  Cada nodo es un Intel Itanium de 1.60GHZ con 2GB de RAM y 7GB espacio disponible en el disco duro local, corriendo un kernel Linux 2.6.9 y BEA JRockit 1.5.0 06 JVM.  Los nodos están conectados a través de un adaptador de red de 1Gbps.  Desafortunadamente esta no es una configuración ideal para TOD.

La primera medida de rendimiento es el tiempo tomado para importar la huella de ejecución dentro de la base de datos.  La segunda medida de rendimiento es la taza en la cual los eventos individuales coinciden con una condición arbitraria pueden ser recuperados utilizando un cursor, y la tercera medida de rendimiento es el tiempo tomado para computar los contadores de eventos de estos mismos para la duración completa de la huella.

\begin{itemize}
	\item \textbf{Registro}: Primero se determinó la tasa de transferencia máxima del disparador mediante la desactivación del procesador de eventos en relación a los nodos de la base de datos:  El disparador puede manejar hasta 200.000 eventos por segundo, independientemente del número de nodos (Figura \ref{BenchDispatch})  Los resultados actuales muestran que una nodo de base de datos es capas de manejar aproximadamente 50.000 eventos/segundo, y que con 10 nodos se obtiene limitar al disparador cerca de los 170.000 eventos/segundo (Figura \ref{DB}).  El rendimiento incrementa con el uso de más nodos, aunque no muy linealmente.  La comparación es sin embargo basada por el hecho que con pocos nodos, menos eventos fueron importados.  Se puede conjeturar que el rendimiento obtenido con pocos nodos habría sido menor si se hubiera sido capas de importar la huella completa.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{images/TOD/BenchDispatch.eps}
	\caption{Rendimiento del lanzador}
	\label{BenchDispatch}
\end{figure}		

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{images/TOD/BenchDBThroughput.eps}
	\caption{Rendimiento del registro}
	\label{DB}
\end{figure}

	\item \textbf{Cursores de consultas} : Se midió la velocidad de ejecución de dos tipos de cursores de consultas stepping-related:  seek y step.  Ambas están basadas sobre en una condición compuesta generada aleatoriamente que se ajusta con eventos de determinado hilo de ejecución y profundidad de la llamada.  La búsqueda de las peticiones de las consultas de un cursor con una condición, posiciona una marca de tiempo elegida al azar en el lapso de ejecución de la traza y obtiene el siguiente evento que corresponda.  La operación es repetida 1.000 veces, cada tiempo con diferentes condiciones y marcas de tiempos.  Las consultas de paso (step) además solicitan un cursor similar y se ubican en una marca de tiempo aleatoria, para luego traer los siguientes 1.000 eventos correspondientes.  La operación es repetida ciento de veces.
	
Los resultados se muestran en Tabla \ref{cursorQueries}.  En este experimento se utilizaron un tamaño fijo de eventos de huellas de 80 millones de eventos las cuales pueden ser importadas en una base de datos usando 3 de los 10 nodos.  La eficiencia de consultas de búsqueda no mejora, e incluso decrece, cuando más nodos de base de datos son utilizados.  Este es porque cada consulta de búsqueda recupera sólo un evento, el cual obviamente está presente en un solo nodo.  El tiempo de buscar ese evento es por lo tanto igual al máximo del tiempo tomado por cada nodo para encontrar el siguiente evento que corresponda, entregando la condición de la consulta y la marca de tiempo. Las consultas de paso son un poco más rápidas cuando más nodos son utilizados pero sorprendentemente la mejora está lejos de ser lineal.  Aún no se ha encontrado una explicación para este resultado inesperado.  A pesar de una débil capacidad de ampliación, la posición del cursor de consultas se ejecuta en décimas de segundos, lo suficientemente rápido para ser utilizado interactivamente a través de la interfaz de depuración de TOD.
		
	\item \textbf{Contadores de consultas}:  Se midió la velocidad de ejecución de los contadores de consultas y se compararon dos métdos: merge counts y fast counts.  Se utilizó una porción de la huella de ejecución de Eclipse descrita anteriormente, que contenía 80 millones de eventos distribuidos en 27 hilos de ejecución.  Se solicitaron al contador de eventos por cada hilo sobre el lapso de la huella, dividiendo $n =$ 1.000 subintervalos.  Los resultados son entregados en Tabla \ref{countQueries}.  Varios puntos que son importantes de destacar:

		\begin{itemize}
			\item Contadores rápidos proveen una aproximación bastante precisa, con una distorsión por bajo del 2\% de comparación con los resultados reunidos de los contadores.

			\item Contadores rápidos son mucho más rápido que los contadores de fusión, pero no mejoran en relación al aumento de nodos en la base de datos, debido a que cada nodo registra menos eventos, el algoritmo de contador rápido debe recurrir frecuentemente a indices de niveles inferiores.
 
			\item Los contadores de fusión escalan linealmente, en términos de números de nodos.
		\end{itemize}
\end{itemize}

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c |}
\hline
\rowcolor[gray]{0.9}Nodes & seek(q/s) & step(q/s)\\
\hline
3 & 6.85 & 267\\
\hline
6 & 6.05 & 273\\
\hline
8 & 5.29 & 299\\
\hline
10 & 5.04 & 353\\
\hline
\end{tabular}
\caption{Consultas de cursores}
\label{cursorQueries}
\end{center}
\end{table}


\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}Nodes & merge(s) & fast(s) & speedup & dist.(\%)\\
\hline
3 & 527.2 & 9.6 & 54.9x & 0.4\\
\hline
5 & 288.6 & 9.7 & 29.8x & 0.7\\
\hline
8 & 177.1 & 10.8 & 16.4x & 1\\
\hline
10 & 133.8 & 8.9 & 15x & 1.21\\
\hline
\end{tabular}
\caption{Consultas de contadores}
\label{countQueries}
\end{center}
\end{table}

			\subsubsection{Sobrecarga por emisión de eventos}

En el sentido de evaluar la sobrecarga de la emisión de los eventos, se compara el tiempo de ejecución de un programa (a) independiente, (b) con TOD y (c) con ODB, otro depurador omnisciente para Java.  Como en esta medida de rendimiento se desea medir la sobrecarga por emisión de eventos cuasado por TOD y no el rendimiento de su base de datos, los eventos simplemente son escritos en el disco sin indexación.

El programa objetivo es un programa de prueba que hace uso intensivo de CPU, el cual crea 100 instancias de objetos y luego itera 10 millones de veces en un ciclo que toma uno de estos objetos de forma aleatoria y le pasa un método que efectúa una simple operación aritmética sobre su código hash.  El programa no llama a ningún método no instrumentado y por eso que cada operación emite un evento.
 
Esta prueba de rendimiento fue realizada en un Pentium M de 2GHz notebook con 1GB de ram corriendo el kernel 2.6.17 de Linux y la JVM 1.5.0 08 de Sun.  Los resultados son presentados en la Tabla \ref{overheadEvents}.  Como los eventos en ODB son almacenados en la pila de la JVM del programa objetivo; los eventos antiguos son eliminados cuando la pila está llena.  Se realizaron dos pruebas con ODB, cambiando el tamaño de la pila de la JVM.  Con 500MB la pila fue capas de registrar 5 millones de eventos de 110 millones emitidos durante la ejecución del programa.  Con 64MB se pudo registrar solo 500.000 eventos.  Por otra parte con TOD se fue capas de registrar 90 millones de eventos emitidos sin interferir con la pila de la JVM.  La huella de ejecución generada pesa 3.6GB.  La sobrecarga de la emisión de eventos es similar en TOD y en ODB: alrededor de 115 veces la de TOD, donde los eventos son serializados y escritos en disco.

Se debe hacer notar que esta medida de rendimiento representa el peor escenario.  Se midió la sobrecarga de uso intensivo de CPU, instrumentando completamente un programa, mientras que en las situaciones típicas de depuración algunas partes de los programas son excluidos de la instrumentación, como se expondrá posteriormente.

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}Setup & RAM & time & emit. & rec. & rate & ovh.\\
\hline
None & 16 & 1.53 & N/A & N/A & N/A & 1x\\
\hline
ODB1 & 500 & 179 & 110m & 5m & 614k & 116x\\
\hline
ODB2 & 64 & 188 & 110m & 530k & 585k & 122x\\
\hline
TOD & 16 & 173 & 90m & 90m & 520k & 113x\\
\hline
\end{tabular}
\caption{Sobrecarga en la emisión de eventos}
\label{overheadEvents}
\end{center}
\end{table}

			\subsubsection{Discusión}

Los resultados experimentales presentados anteriormente muestran que es factible registrar y consultar grandes huellas de ejecución para el propósito de la depuración omnisciente.  Se fue capas de registrar una huella de ejecución de 20GB correspondiente a una sesión de trabajo en Eclipse, un IDE bastante complejo orientado a Java, y se importó sobre los 400 millones de eventos de esa huella en la base de datos distribuidas para eventos a una tasa de 170.000 eventos/segundo, cercano a tres veces más lento que la tasa máxima de eventos observada, 520.000 eventos/segundo.  La base de datos fue también capas de servir entre 5 y 350 cursores de consultas por segundo y producir contadores globales de consultas para 27 hilos de ejecución en menos de 10 segundos; cada tiempo de respuesta es compatible con los requerimientos de interactividad de la interfaz de usuario del depurador.  Se utilizó la base de datos distribuida sobre un cluster dedicado y realizando medidas utilizando 1 hasta 10 nodos de la base de datos.  La base de datos demostró escalabilidad por cada evento registrado y consultas, pero no tanto para los cursores de las consultas. Por lo que respecta a la emisión de eventos la sobrecarga es preocupante, se observó que un intensivo uso de CPU, de un programa completamente instrumentado ejecutado bajo TOD disminuye alrededor de 115 veces y emite alrededor de 520.000 de eventos/segundo.  Este caso es similar al obtenido con ODB, un depurador omnisciente que almacena eventos en un espacio de direcciones en el programa objetivo y de esta forma no es tan escalable.  En esta implementación el disparador de eventos impone un embotellamiento de 200.000 eventos/segundo; Una mejor implementación del disparador (presumiblemente en C) es necesario si las huellas de ejecución son grabadas en tiempo real.


		\subsection{Trabajando con huellas parciales}

	Aunque TOD está diseñado para soportar grandes huellas de ejecución, no siempre es practicable grabar cada evento:  El tiempo de ejecución mayor de una captura de evento es importante, como también lo son los requerimientos de almacenamiento.  La idea de las huellas parciales es que se puede afirmar el echo que durante el desarrollo de una pieza de software, algunos componentes son confiables, por ejemplo: maduros y bien probados, y por esto no es necesario generar y almacenar eventos para las actividades internas de esos componentes.  Esta sección muestra como el alcance de la captura de la huella puede facilitar la depuración y como TOD hace posible el trabajo con huellas parciales.

			\subsubsection[Ejemplo de motivación]{Ejemplo de motivación: Depurando el plugin de TOD en eclipse}

Consideremos como un ejemplo de depuración el mismo plugin de TOD en eclipse.  Este ejemplo es bastante representativo de un componente de desarrollo existente, probado, frameworks o arquitecturas de plugin.  Aquí, se está fuertemente interesado en dos tipos de bugs:  aquellos que son internos del plugin y aquellos relacionados con la interacción entre el plugin y la plataforma.  En el primer caso, no se necesita capturar eventos que ocurren dentro de la plataforma ECLIPSE porque eso es considerado como probado.  En el segundo caso, se tiene que grabar eventos que ocurren dentro de la plataforma, pero no necesariamente todos:  puede que sean bastantes los eventos que se deban grabar de la Java Tooling(JDT), o solamente alguna parte de ella, por ejemplo la interfaz de usuario.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/TOD/RuntimeOverhead.eps}
	\caption{Eventos emitidos y sobrecarga en tiempo de ejecución.}
	\label{RuntimeOverhead}
\end{figure}

Figura \ref{RuntimeOverhead} muestra el impacto de diferentes alcances de estrategias de la huella en comparación con el número de eventos emitidos y el exceso del tiempo de ejecución, durante diferentes etapas de la ejecución del plugin de TOD.  En este pequeño experimento se puede ver que por apropiado que sea el alcance de la captura de la huella, existe sobre cinco ordenes de magnitud de diferencia en el número de eventos emitidos, y que los aumentos en el exceso del tiempo de ejecución puede ser sobre 20 tiempos, realza enormemente la aplicabilidad de TOD.

			\subsubsection{Tratando con información incompleta}

El inconveniente de ignorar algunos eventos es que la captura de la huella de ejecución es incompleta, y por lo tanto, alguna información es precaria para reconstruir la historia completa del programa.  El soporte para huellas parciales de ejecución en TOD es conseguida mediante reportes sistemáticos, sobre la información perdida, al usuario para que el pueda razonar sólidamente acerca de la información disponible.  La información perdida se manifiesta en dos áreas: cuando el código no instrumentado es llamado desde un código instrumentado, y en el turno de las llamadas de código instrumentado, alguna información sobre el flujo de control es perdida; en este caso TOD entrega indicadores visuales en los lugares apropiados, como se muestra en la Figura \ref{IndirectCFlow}  Segundo, en el estado de reconstitución: si una clase tiene un atributo no privado que es escrito por código no instrumentado, el valor de este campo en un punto determinado del tiempo no puede ser determinado de forma exacta.  TOD representa estos campos con un color distinto en las correspondientes vistas.

Los pequeños puntos indican que la información del flujo de control pudo ser perdida: El método Collections.sort no está instrumentado pero llama al método de comparación de la clase instrumentada Comp durante su ejecución


\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/TOD/IndirectCFlow.eps}
	\caption{Reportando una información de flujo de control potencialmente incompleta.}
	\label{IndirectCFlow}
\end{figure}


\chapter{pyTOD}
	\section{Arquitectura de pyTOD}
		\subsection{Modelo de componentes}

Para tener una mejor perspectiva de los componentes que componen pyTOD, es que se utiliza el diagrama de componentes del lenguaje unificado de modelamiento UML.  Es importante señalar que este diagrama en ningún caso es un diagrama de bajo nivel.		
\begin{figure}[hpb]
	\centering
	\includegraphics[scale=0.5]{images/componentModelHunterTrace.eps}
	\caption{Diagrama de componente del capturador de huella}
\end{figure}	
		
		
		\subsection{Wrapper}
		
Por un asunto de usabilidad, se ha construido un wrapper con el objetivo que el programador no deba modificar ninguna linea de los script que desee depurar.  A continuación su muestran dos ejemplos, el primero sin utilizar el wrapper y el segundo utilizando el wrapper.

\begin{itemize}
	\item Código sin wrapper
\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys
sys.path.append('/Volumes/archivos/eclipse/workspace/python-project/src')
from debugger.pytod.core.hunterTrace import hT

class miClase(object):
    def __init__(self, y):
        self.condicion = True
        self.cantidad = 1
        self.metodo(self.z, 1, 2, 3)
        return
    
    def metodo(self, h, i, j, k):
        self.cantidad = 1 + h
\end{lstlisting}
\end{singlespace}

Como se puede observar el programador añadió tres lineas (lineas desde la uno hasta la tres) a su código, tema que se vuelve tedioso al momento de modificar cientos de archivos en los cuales está distribuido su software.  Para evitar esto es que se construyó el wrapper, el cual evita que el programador tenga que introducir lineas de código ajenas a su programa.  

	\item Código con wrapper

El programador sólo escribe su programa, sin tener que adaptarlo para que funcione con el depurador.

\begin{singlespace}
\begin{lstlisting}[style=Python]
class miClase(object):
    def __init__(self, y):
        self.condicion = True
        self.cantidad = 1
        self.metodo(self.z, 1, 2, 3)
        return
    
    def metodo(self, h, i, j, k):
        self.cantidad = 1 + h       
\end{lstlisting}
\end{singlespace}

A continuación se muestra el código fuente del wrapper:
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys
from debugger.pytod.core.hunterTrace import hT

print "PyTOD wrapper v1"
if __name__ == '__main__':
    execfile('\%s'\%(sys.argv[1]),locals(),globals())
\end{lstlisting}
\end{singlespace}

Wrapper implementa las líneas que en el caso anterior el programador tuvo que agregar a su script, además de esto, wrapper se encarga de ejecutar el script del programador.  Wrapper es utilizado en el plugin construido para Eclipse.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[scale=1]{images/wrapper.eps}
	\caption{Diagrama de composición wrapper}
\end{figure}

La figura anterior describe de que forma \textit{wrapper} se posiciona en la arquitectura del depurador.
		
		%\subsection{Diagrama general}
	
	\section{Diseño de pyTOD}
	
En esta sección se muestra una perspectiva del diseño de pyTOD, separando los componentes entre \textit{Máquina virtual}, \textit{Base de datos} y \textit{Vista final del usuario}

\begin{figure}[hpb]
	\centering
	\includegraphics[scale=0.4]{images/disenopyTOD.eps}
	\caption{Diagrama de diseño de pyTOD}
\end{figure}


	\section{Implementación de pyTOD}
		\subsection{Capturador de huella}
		
El capturador de huella es el encargado de: 

\begin{itemize}
	\item Registrar la estructura del programa objetivo (clases, métodos, funciones, atributos de instancia, atributos de clase, variables locales, threads, probes)
	\item Capturar los eventos que el programa objetivo genere en tiempo de ejecución (Llamadas a métodos/funciones, asignaciones/modificaciones, instanciaciones, retornos de métodos/funciones, excepciones). 
\end{itemize}

El capturador de huella tiene una dependencia directa con la función \textit{settrace} \cite{settrace} perteneciente al módulo estándar \textit{sys}.  Esta función por definición fue creada para facilitar la creación de depuradores de código.

Por lo anterior, en el presente trabajo de memoria se utilizó esta función para satisfacer ciertos requerimientos de registro estructural del programa objetivo.  Es importante señalar que la función \textit{settrace} no cubre todas las necesidades de este trabajo de memoria, ejemplo: no es posible estar enterado de la creación o modificación de una variable de instancia o una variable de clase.

A continuación se muestra un ejemplo a nivel introductorio como esta función trabaja:

\begin{itemize}
	\item{Programación estructurada}

\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys

def trace(aFrame, aEvent, aArg):
    if aEvent == 'call':
        print "Llamada a", aFrame.f_code.co_name
        return trace
    elif aEvent == 'line':
        print "Ejecutando linea", aFrame.f_lineno, 
        return trace
    elif aEvent == 'return':
        print "Saliendo de", aFrame.f_code.co_name, 
        print "con valor", aArg
    elif aEvent == 'exception':
        pass

sys.settrace(trace)

def miFuncion(aPrimero, aSegundo):
    if aPrimero > aSegundo:
        theResultado = aPrimero + aSegundo
    else:
        theResultado = aPrimero - aSegundo
    return theResultado

if __name__ == '__main__':
    theResultado = miFuncion(10,5)
    print "Mi resultado es:", theResultado
\end{lstlisting}
\end{singlespace}

El resultado obtenido al ejecutar este código es:
\begin{singlespace}
\begin{lstlisting}[style=consola, numbers=none]
peregrino:~ minostro$ python miTrace.py
Llamada a miFuncion
Ejecutando linea 20
Ejecutando linea 21
Ejecutando linea 24
Saliendo de miFuncion con valor 15
Mi resultado es: 15
\end{lstlisting}

	\item{Programación Orientada a Objetos}
\begin{lstlisting}[style=Python]
import sys

def trace(aFrame, aEvent, aArg):
    if aEvent == 'call':
        print "Llamada a", aFrame.f_code.co_name
        return trace
    elif aEvent == 'line':
        print "Ejecutando linea", aFrame.f_lineno, 
        print "indice bytecode", aFrame.f_lasti
        return trace
    elif aEvent == 'return':
        print "Saliendo de", aFrame.f_code.co_name, 
        print "con valor", aArg
    elif aEvent == 'exception':
        pass

sys.settrace(trace)

class miClase(object):

    def __init__(self):
        pass
    
    def miMetodo(self, aPrimero, aSegundo):
        if aPrimero > aSegundo:
            theResultado = aPrimero + aSegundo
        else:
            theResultado = aPrimero - aSegundo
        return theResultado

if __name__ == '__main__':
    theClase = miClase()
    theResultado = theClase.miMetodo(5, 10)
    print "Mi resultado es:", theResultado
\end{lstlisting}
\end{singlespace}

El resultado obtenido al ejecutar este código es:
\begin{singlespace}
\begin{lstlisting}[style=consola, numbers=none]
peregrino:~ minostro$ python miTrace.py
Llamada a miClase
Ejecutando linea 18
Ejecutando linea 20
Ejecutando linea 23
Saliendo de miClase con valor {'miMetodo': <function miMetodo at 0x82eb0>, '__module__': '__main__', '__init__': <function __init__ at 0x82e70>}
Llamada a __init__
Ejecutando linea 21
Saliendo de __init__ con valor None
Llamada a miMetodo
Ejecutando linea 24
Ejecutando linea 27
Ejecutando linea 28
Saliendo de miMetodo con valor -5
Mi resultado es: -5
\end{lstlisting}
\end{singlespace}
\end{itemize}

El ejemplo anterior nos muestra que es importante dejar en claro la diferencia entre los sucesos estructurales y los eventos.  A continuación se detalla cada uno de éstos, se explica su implementación y ejecución dentro del capturador de huella:

			\subsubsection{Sucesos estructurales}
			
				\paragraph{Registro de clase \label{registroClase}}

El objeto clase se registra junto a sus métodos en el momento que el programador termina de definirla.  El capturado de huella al detectar el evento \textit{return}, consultará en el diccionario \textit{frame.locals} si es que la función \textit{\_\_init\_\_} está presente como atributo en este diccionario, de ser así, el capturador de huella registrará la definición de la clase.  Ejemplo:

\begin{singlespace}
\begin{lstlisting}[style=Python]
class miClase(object):

    def __init__(self):
        pass
    
    def miMetodo(self, aPrimero, aSegundo):
        if aPrimero > aSegundo:
            theResultado = aPrimero + aSegundo
        else:
            theResultado = aPrimero - aSegundo
        return theResultado
\end{lstlisting}
\end{singlespace}

Es importante señalar que la clase se registra cuando existe un evento \textit{return} debido a que Python al momento de finalizar la construcción de la clase, carga todo el diccionario del \textit{frame} en el atributo \textit{aArg} del evento \textit{return} \cite{bytecode} 

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
"""
Contenido de aArg
"""
{
	'miMetodo': <function miMetodo at 0x82eb0>, 
	'__module__': '__main__',
	'__init__': <function __init__ at 0x82e70>
}

\end{lstlisting}
\end{singlespace}

Como se puede observar en esta estructura de datos se encuentran todos los métodos de la clase que serán ligadas el objeto en el momento de instanciación.  Luego de registrar la clase en el diccionario de la clase \textit{hunterTrace}, se envía un mensaje a través de un socket a la base estructural de TOD para crear un registro relacionado con la clase:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando clase miClase
\end{lstlisting}
\end{singlespace}

Continuando con el registro completo de la clase se guardan los métodos definidos en ella.  Los métodos son almacenados en una estructura de datos especial perteneciente a la clase \textit{objectClass}.

Finalmente, se registran los atributos de clase de la misma forma que se registran los métodos.  Estos atributos son guardados en una estructura de dato especial de la clase \textit{objectClass}.  Este caso se trata con mayor complejidad que el anterior, debido a que la estructura de la base de datos TOD no permite registrar un atributo de clase que esté fuera de un método de la clase, situación que en Python es posible dado que se definen como atributos de la clase a cualquier variable que esté dentro del cuerpo de la definición de la clase y fuera del cuerpo de los métodos definidos para ésta.  Bajo esta situación se tomó la decisión de crear en la parte Java de pyTOD un método artificial llamado \textit{\textbf{clase}StaticMethod}, al cual se le asociarán todos los atributos de clase que se encuentren en la situación descrita anteriormente.


				\paragraph{Registro de método}

El registro de método se realiza en el momento que se detecta un evento del tipo \textit{call}.  Se busca en el diccionario \textit{locals} del frame la llave \textit{self}, si está en el diccionario, se utiliza para obtener la clase a la cual pertenece el método.  Para obtener la clase asociada al método se realiza lo siguiente:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
type(self).__name__
\end{lstlisting}
\end{singlespace}


Con este nombre se busca la clase en \textit{hunterTrace} y se obtiene el identificador único del método para poder registrarlo en la base de datos estructural de TOD:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando el metodo miMetodo id = 105
\end{lstlisting}
\end{singlespace}

Es importante señalar que al momento de registrar un método en la base de datos estructural, se deben enviar los argumentos de éste.  Por definición Python pone como primer argumento la referencia a la instancia, la forma estándar de nombrarlo es \textit{self}, este argumento no es registrado como argumento en la base de datos estructural.

Los argumentos son registrados utilizando como identificador la posición que ocupan en \textit{frame.f\_code.co\_varnames}, que por definición son siempre los primeros elementos que contiene esta estructura de datos.

				\paragraph{Registro de método especial}

De la misma forma que se registra un método, se registra este método especial.  Como anteriormente se señala este método artificial se utiliza al momento de registrar un atributo de clase.  Este método siempre se encontrará por el nombre \textit{\textbf{Clase}SpecialMethod} siendo \textit{\textbf{Clase}} el nombre de la clase a la cual pertenece.

A este método no se le registran argumentos ni variables locales.  Este método es registrado en la base de datos estructural de TOD la primera vez que se registra un atributo de clase.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando el metodo especial miClaseStaticMethodid = 106
\end{lstlisting}
\end{singlespace}

				
				\paragraph{Registro de función}
				
En el caso de este registro se busca en \textit{locals} el atributo \textit{self}, de no encontrarse se verifica que el objeto sea una función utilizando la función \textit{isfunction} del módulo \textit{inspect}.  De ser una función esta se registra en la base de datos de TOD.			

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando la funcion miFuncion id = 115
\end{lstlisting}
\end{singlespace}

Respecto a los atributos la única diferencia es que no se tiene que omitir el atributo \textit{self} ya que para funciones este no existe.


				\paragraph{Registro de atributo de instancia\label{registerField}}

La función de sistema \textit{settrace} no entrega ningún mecanismo para estar notificado de la creación de un atributo de instancia.  Es por esto que se utiliza el mecanismo llamado \textit{\_\_setattr\_\_} que es un método interno de Python \cite{setattr} que permite estar notificado en el momento que se asigna un valor o se modifica una variable de instancia.  Lo que se hace es sobrescribir este método para todas las clases que el programador haya escrito.

Se muestra un ejemplo de funcionamiento de este método:

\begin{singlespace}
\begin{lstlisting}[style=Python]
class Descriptor(object):
    def __setattr__(self, aName, aValue):
        """
        Metodo de interes que permite auditar los movimientos
        de las variables de instancia
        """
        if aName in self.__dict__:
            print "Modificacion de", aName, "por el valor", aValue
        else:
            print "Registro de", aName, "con el valor", aValue
        object.__setattr__(self, aName, aValue)

class miClase(Descriptor):
    
    def __init__(self):
        self.itsEdad = 15
        self.itsSexo = "Masculino"
        self.itsColor = ("Amarillo", "Verde", "Azul")
    
    def modificaEdad(self, aEdad):
        self.itsEdad += aEdad

if __name__ == "__main__":
    theClase = miClase()
    theClase.modificaEdad(20)
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución es la siguiente:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miDescriptor.py
Registro de itsEdad con el valor 15
Registro de itsSexo con el valor Masculino
Registro de itsColor con el valor ('Amarillo', 'Verde', 'Azul')
Modificacion de itsEdad por el valor 35
\end{lstlisting}
\end{singlespace}

Como se puede ver funciona todo de forma correcta, pero se detectó un problema de usabilidad de cara al programador.  Cada vez que el programador defina una clase deberá heredar de Descriptor, cosa que para un par de clases no es molesto pero cuando este número se incrementa puede llegar a ser incomodo para el programador.

Como solución a lo anterior se agrega directamente al diccionario local de la clase escrita por el programador, en el momento de la definición, el método \textit{\_\_setattr\_\_} de la clase \textit{Descriptor}

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
theLocals.update(
    {
        '__setattr__':Descriptor.__dict__['__setattr__']
    }
)
\end{lstlisting}
\end{singlespace}

Finalmente el atributo de instancia es registrado en la base de datos.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - fieldWrite   (thread: 101, p.ts: 1217048770743326976, depth: 2, ts: 1217048770744072960, fid: 118 (x), target: UID: 117, val: 6
\end{lstlisting}
\end{singlespace}


				\paragraph{Registro de atributo de clase\label{registerStaticField}}

Para realizar este registro se deben diferenciar dos situaciones importantes:
\begin{enumerate}
	\item Si el atributo de clase se encuentra definido en el cuerpo de la clase pero fuera del cuerpo de los métodos, se utilizará el mecanismo de registro señalado para esta situación en el registro de clase \ref{registroClase}.
	\item Si el atributo de clase está definido dentro de un método de la clase, se utilizará el paradigma de metaprogramación.
\end{enumerate}

Se muestra un ejemplo para mostrar su funcionamiento:

\begin{itemize}
	\item Atributo de clase definido dentro del cuerpo de la clase pero fuera del cuerpo de los métodos
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
class MetaDescriptor(type):

    def __setattr__(self, aName, aValue):
        """
        Metodo de interes que permite auditar los movimientos
        de las variables de clase
        """    
        if aName in self.__dict__:
            print "Modificacion de", aName, "por el valor", aValue
        else:
            print "Registro de", aName, "con el valor", aValue
        super(MetaDescriptor, self).__setattr__(aName, aValue)
        
        
class miClase:
    
    __metaclass__ = MetaDescriptor
    
    temperatura = 75
    
    def __init__(self):
        self.__class__.itsEdad = 73
        self.__class__.itsColor = "Rojo"
    

if __name__ == "__main__":
    theClase = miClase()
    miClase.theSexo = "Femenino"
    miClase.itsEdad += 1
\end{lstlisting}

El resultado de la ejecución del código es el siguiente:

\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miMetaDescriptor.py
Registro de temperatura con el valor 75
Registro de itsEdad con el valor 73
Registro de itsColor con el valor Rojo
Registro de theSexo con el valor Femenino
Modificacion de itsEdad por el valor 74
\end{lstlisting}

\end{singlespace}
	
	
	\item Atributo de clase definido dentro del cuerpo de los métodos

\begin{singlespace}
\begin{lstlisting}[style=Python]
class MetaDescriptor(type):

    def __setattr__(self, aName, aValue):
        """
        Metodo de interes que permite auditar los movimientos
        de las variables de clase
        """    
        if aName in self.__dict__:
            print "Modificacion de", aName, "por el valor", aValue
        else:
            print "Registro de", aName, "con el valor", aValue
        super(MetaDescriptor, self).__setattr__(aName, aValue)
        
        
class miClase:
    
    __metaclass__ = MetaDescriptor
    
    def __init__(self):
        self.__class__.itsEdad = 73
        self.__class__.itsColor = "Rojo"
    

if __name__ == "__main__":
    theClase = miClase()
    miClase.theSexo = "Femenino"
    miClase.itsEdad += 1
\end{lstlisting}

El resultado de la ejecución del código es el siguiente:

\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miMetaDescriptor.py
Registro de itsEdad con el valor 73
Registro de itsColor con el valor Rojo
Registro de theSexo con el valor Femenino
Modificacion de itsEdad por el valor 74
\end{lstlisting}

\end{singlespace}

Al igual que en el caso del registro de atributos de instancia es incomodo para el programador personalizar su clase para que pueda comportarse de la manera que se desea, es por esto que en el momento de definir la clase se agrega al diccionario locals el atributo \textit{\_\_metaclass\_\_} con valor MetaDescriptor.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
theLocals.update(
    {
        '__metaclass__':MetaDescriptor
    }
)
\end{lstlisting}
\end{singlespace}
\end{itemize}
Es importante que para ambas situaciones se logra registrar el atributo de clase en la base estructural de TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando un atributo estatico con id 108
\end{lstlisting}
\end{singlespace}


				\paragraph{Registro de variable local\label{registerLocal}}
				
El registro de una variable local puede realizarse en dos situaciones:

\begin{enumerate}
	\item Si el programador escribe la instrucción \textit{return} en el método o en la función, todos los registros de las variables locales se realizarán cuando suceda el evento \textit{line}.
	\item Si el programador no escribe la instrucción \textit{return}, en el método o en la función, los registros de las variables locales se realizarán cuando sucedan los eventos \textit{line} y \textit{return} \cite{bytecode}.
\end{enumerate}

En ambos casos se asegura el registro de la variable local en la base de datos estructural de TOD.

\begin{singlespace}
\begin{lstlisting}[style=Python]
Registrando variable local: y
\end{lstlisting}
\end{singlespace}

La forma de capturar la creación de una variable local, es inspeccionando el bytecode de Python en búsqueda de la instrucción \textit{STORE\_FAST}. \cite{bytecode}

Es importante señalar que al momento de registrar el método o la función se crea un \textit{lnotab} \cite{lnotab} propio, que es una estructura de datos que indica los rangos de los indices del bytecode, para luego ser consultados al momento de inspeccionar el bytecode.  Esto se realiza para hacer un poco más eficiente el proceso de búsqueda dentro del bytecode.

Se muestra un ejemplo introductorio para graficar la forma en que se registran los variables locales.

\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys
import dis

class miTrace:
    def __init__(self):
        self.itsLnotab = None

    def __createlnotab__(self, aCode):
        theLnotab = {}
        if hasattr(aCode, 'co_lnotab'):
            table = aCode.co_lnotab
            index = 0
            last_index = None
            for i in range(0, len(table), 2):
                index = index + ord(table[i])
                if last_index == None:
                    last_index = index
                else:
                    theLnotab.update({index:tuple([last_index,index-1])})                
                    last_index = index
            theLnotab.update(
             {
               len(aCode.co_code)-1:tuple(
                  [last_index,len(aCode.co_code)-1])
             })                
        return theLnotab 
    
    def __getpartcode__(self, aCode, aLimits):
        theLower = aLimits[0]
        theUpper = aLimits[1]
        theCode = aCode.co_code
        theStoreFast = {}    
        while theLower < theUpper:
            theOp = ord(theCode[theLower])
            theNameOp = dis.opname[theOp]
            theLower = theLower + 1
            if theOp >= dis.HAVE_ARGUMENT:
                theValue = ord(theCode[theLower])
                theValue += ord(theCode[theLower+1])*256
                theLower = theLower + 2
                if theOp in dis.haslocal and \
                theNameOp == 'STORE_FAST':
                    theArgumentValue = aCode.co_varnames[theValue]
                    theStoreFast.update({theArgumentValue:theValue})
        return theStoreFast

    def trace(self, aFrame, aEvent, aArg):
        theCode = aFrame.f_code
        if aEvent == 'call':
            print "Llamada a", aFrame.f_code.co_name
            print "Byte Code asociado:"
            dis.disassemble(theCode)
            print "1. Generando lnotab = ",
            self.itsLnotab = self.__createlnotab__(theCode)
            print self.itsLnotab
            print "2. Comienza inspeccion"
            return self.trace
        elif aEvent == 'line':
            if self.itsLnotab.has_key(aFrame.f_lasti):
                theByteCodeLocals = self.__getpartcode__(theCode,self.itsLnotab[aFrame.f_lasti])
                print "[line] Examinando rango:", self.itsLnotab[aFrame.f_lasti],
                print ", resultado de inspeccion:", theByteCodeLocals
            return self.trace
        elif aEvent == 'return':
            if self.itsLnotab.has_key(aFrame.f_lasti):
                theByteCodeLocals = self.__getpartcode__(theCode,self.itsLnotab[aFrame.f_lasti])
                print "[return] Examinando rango:", self.itsLnotab[aFrame.f_lasti],
                print ", resultado de inspeccion:", theByteCodeLocals        
            print "Saliendo de", aFrame.f_code.co_name, 
            print "con valor", aArg
        elif aEvent == 'exception':
            pass

sys.settrace(miTrace().trace)
\end{lstlisting}
\end{singlespace}

Código donde el programador escribe la instrucción \textit{return}:

\begin{singlespace}
\begin{lstlisting}[style=Python]
def miFuncion():
    thePrimera = 10
    theSegunda = 35
    return theSegunda

if __name__ == '__main__':
    miFuncion()
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución de este código es el siguiente:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miCapturadorLocales.py
Llamada a miFuncion

Byte Code asociado:
 85           0 LOAD_CONST               1 (10)
              3 STORE_FAST               0 (thePrimera)

 86           6 LOAD_CONST               2 (35)
              9 STORE_FAST               1 (theSegunda)

 87          12 LOAD_FAST                1 (theSegunda)
             15 RETURN_VALUE        

1. Generando lnotab =  {12: (6, 11), 6: (0, 5), 15: (12, 15)}
2. Comienza inspeccion
    [line] Examinando rango: (0, 5) , resultado de inspeccion: {'thePrimera': 0}
    [line] Examinando rango: (6, 11) , resultado de inspeccion: {'theSegunda': 1}
    [return] Examinando rango: (12, 15) , resultado de inspeccion: {}
    
Saliendo de miFuncion con valor 35
\end{lstlisting}
\end{singlespace}

Código donde el programador no escribe la instrucción \textit{return}:

\begin{singlespace}
\begin{lstlisting}[style=Python]
def miFuncion():
    thePrimera = 10
    theSegunda = 35

if __name__ == '__main__':
    miFuncion()
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución de este código es el siguiente:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miCapturadorLocales.py
Llamada a miFuncion

Byte Code asociado:
 85           0 LOAD_CONST               1 (10)
              3 STORE_FAST               0 (thePrimera)

 86           6 LOAD_CONST               2 (35)
              9 STORE_FAST               1 (theSegunda)
             12 LOAD_CONST               0 (None)
             15 RETURN_VALUE        

1. Generando lnotab =  {6: (0, 5), 15: (6, 15)}
2. Comienza inspeccion
    [line] Examinando rango: (0, 5) , resultado de inspeccion: {'thePrimera': 0}
    [return] Examinando rango: (6, 15) , resultado de inspeccion: {'theSegunda': 1}
    
Saliendo de miFuncion con valor None
\end{lstlisting}
\end{singlespace}



El método \textit{\_\_getpartcode\_\_} entrega las variables locales que han sido definidas en un trozo de bytecode determinado, las que luego en este ejemplo su muestran por salida estándar.

				\paragraph{Registro de thread}
				
El registro de thread se realiza al momento de entrar a \textit{settrace}. Para conocer la identificación de thread se utiliza el método \textit{get\_ident} del módulo \textit{thread}.  Si se detecta que el thread no ha sido registrado en la estructura interna de \textit{hunterTrace}, este se registra y se envía a la base de datos estructural de TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando thread id 101
\end{lstlisting}
\end{singlespace}
				
				\paragraph{Registro de probe}
				
El registro de probe ocurre en cualquier momento antes que se produzca un evento.  Probe se comporta como una sonda la cual nos indica en que método o en que función sucedió el evento, el índice del bytecode y número de linea del código donde se encuentra la instrucción del evento ocurrido.

Por ejemplo para una asignación de atributo de instancia se tendrá el siguiente registro de probe en la base de datos estructural de TOD:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando probe id 116
\end{lstlisting}
\end{singlespace}

				\paragraph{Registro de objeto}
				
El registro de objeto ocurre en cualquier momento antes que se produzca un evento que involucre la utilización de:
\begin{itemize}
	\item argumentos de funciones o métodos
	\item variables locales
	\item atributos de instancia o atributos de clase.  
\end{itemize}

Este registro se realiza para optimizar el paquete de datos que se envía a través del socket cuando ocurre un evento.

El registro de objeto consiste en tomar el valor correspondiente del objeto (señalado anteriormente), asignarle un identificador único el cual es generado por la función \textit{id} de Python y registrar el objeto en la base de datos estructural de TOD con su valor original.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Registrando un nuevo objeto UID 10956000 valor "integer division or modulo by zero"
\end{lstlisting}
\end{singlespace}

Al momento de utilizar el valor de uno de estos objetos en un evento sólo se envía el identificador del objeto y no su valor original.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - exception    (thread: 101, p.ts: 1217118691038720000, depth: 3, ts: 1217118691041134080, pid: 116, exc.: UID: 10956000)
\end{lstlisting}
\end{singlespace}

			\subsubsection{Eventos}
				
				\paragraph{Llamada método/función}
				
Este evento ocurre cuando el capturador de huella detecta el evento \textit{call}.  Se envía a la base de datos de eventos la información que identifica a esta llamada de método o de función.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - methodCall   (thread: 101, p.ts: 1217207598479134208, depth: 2, ts: 1217207598480425984, direct: true, c.bid: -1, e.bid: 104 (miClase.miMetodo), target: UID: 117, args: null)
\end{lstlisting}
\end{singlespace}

A continuación se muestran dos ejemplos en los cuales las llamadas son capturadas:

\begin{itemize}
	\item{Llamada a función}

\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys

def trace(aFrame, aEvent, aArg):
    if aEvent == 'call':
        print "Llamada a", aFrame.f_code.co_name
        return trace
    elif aEvent == 'line':
        return trace
    elif aEvent == 'return':
	pass
    elif aEvent == 'exception':
        pass

sys.settrace(trace)

def miFuncion(aPrimero, aSegundo):
    if aPrimero > aSegundo:
        theResultado = aPrimero + aSegundo
    else:
        theResultado = aPrimero - aSegundo
    return theResultado

if __name__ == '__main__':
    theResultado = miFuncion(10,5)
    print "Mi resultado es:", theResultado
\end{lstlisting}
\end{singlespace}


El resultado de la ejecución de este código es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miLlamadaFuncion.py
Llamada a miFuncion
Mi resultado es: 15
\end{lstlisting}
\end{singlespace}

	
	\item{Llamada a método}

\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys

def trace(aFrame, aEvent, aArg):
    if aEvent == 'call':
        print "Llamada a", aFrame.f_code.co_name
        return trace
    elif aEvent == 'line':
        return trace
    elif aEvent == 'return':
        pass
    elif aEvent == 'exception':
        pass

sys.settrace(trace)

class miClase(object):
    
    def __init__(self):
        pass
    
    def miMetodo(self, aPrimero, aSegundo):
        if aPrimero > aSegundo:
            theResultado = aPrimero + aSegundo
        else:
            theResultado = aPrimero - aSegundo
        return theResultado

if __name__ == '__main__':
    theClase = miClase()
    theResultado = theClase.miMetodo(5, 10)
    print "Mi resultado es:", theResultado
\end{lstlisting}
\end{singlespace}

	
El resultado de la ejecución de este código es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miLlamadaMetodo.py
Llamada a miClase
Llamada a __init__
Llamada a miMetodo
Mi resultado es: -5
\end{lstlisting}
\end{singlespace}

Es importante señalar que \textit{miClase} no es un método sino que un objeto del tipo \textit{class}, asunto que para este ejemplo no se discrimina para no complicar innecesariamente el código de la implementación de \textit{trace}.
	
\end{itemize}				
				
				\paragraph{Asignación/modificación}
					\subparagraph{Atributo de instancia}
					
De igual forma que en el registro de atributo de instancia \ref{registerField}, se utiliza el método \textit{\_\_setattr\_\_} para estar notificados de todos los cambios de estos atributos.  En el momento que el programador modifique el valor de un atributo de instancia el capturador de huella llamará al método \textit{\_\_addAttribute\_\_} de la estructura de datos interna \textit{itsClass}, la cual se encarga de manejar los cambios en los atributos de instancia.

\begin{singlespace}
\begin{lstlisting}[style=Python]
class Descriptor(object):
    def __setattr__(self, aName, aValue):
        if aName in self.__dict__:
            print "Modificacion de", aName, "por el valor", aValue
        else:
            print "Registro de", aName, "con el valor", aValue
        object.__setattr__(self, aName, aValue)

class miClase(Descriptor):
    
    def __init__(self):
        self.itsEdad = 15
        self.itsSexo = "Masculino"
        self.itsColor = ("Amarillo", "Verde", "Azul")
    
    def modificaEdad(self, aEdad):
        self.itsEdad += aEdad
    
    def modificaSexo(self, aSexo):
        self.itsSexo = aSexo

if __name__ == "__main__":
    theClase = miClase()
    theClase.modificaEdad(20)
    theClase.modificaSexo("Femenino")
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución de este código es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miModificacionAtributoInstancia.py
Registro de itsEdad con el valor 15
Registro de itsSexo con el valor Masculino
Registro de itsColor con el valor ('Amarillo', 'Verde', 'Azul')
Modificacion de itsEdad por el valor 35
Modificacion de itsSexo por el valor Femenino
\end{lstlisting}
\end{singlespace}

Por simplicidad no se ha utilizado el método  \textit{\_\_addAttribute\_\_} y la estructura \textit{itsClass}, pero el ejemplo presentado anteriormente grafica con toda claridad lo que se realiza al momento de detectar la modificación de una variable de instancia.

Finalmente, se registra la modificación del valor en la base de datos de eventos de TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - fieldWrite   (thread: 101, p.ts: 1217207598470598912, depth: 2, ts: 1217207598471888896, fid: 118 (itsEdad), target: UID: 117, val: 6
\end{lstlisting}
\end{singlespace}

					
					\subparagraph{Atributo de clase}

De la misma forma que en el registro de los atributos de clase (incluyendo los dos casos) \ref{registerField}, se realiza el registro de modificación de éstos.  En el momento que el programador modifique el valor de un atributo de clase el capturador de huella llamará al método \textit{\_\_addStaticAttribute\_\_} de la estructura de datos interna \textit{itsClass}, la cual se encarga de manejar los cambios en los atributos de clase.

\begin{singlespace}
\begin{lstlisting}[style=Python]
class MetaDescriptor(type):
    def __setattr__(self, aName, aValue):
        if aName in self.__dict__:
            print "Modificacion de", aName, "por el valor", aValue
        else:
            print "Registro de", aName, "con el valor", aValue
        super(MetaDescriptor, self).__setattr__(aName, aValue)
        
        
class miClase:
    
    __metaclass__ = MetaDescriptor
    
    def __init__(self):
        self.__class__.itsEdad = 73
        self.__class__.itsColor = "Rojo"
    

if __name__ == "__main__":
    theClase = miClase()
    miClase.theSexo = "Femenino"
    miClase.itsEdad += 1
    miClase.itsColor = "Azul"
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución de este código es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
peregrino:~ minostro$ python miModificacionAtributoClase.py
Registro de itsEdad con el valor 73
Registro de itsColor con el valor Rojo
Registro de theSexo con el valor Femenino
Modificacion de itsEdad por el valor 74
Modificacion de itsColor por el valor Azul
\end{lstlisting}
\end{singlespace}

Por simplicidad no se ha utilizado el método  \textit{\_\_addStaticAttribute\_\_} y la estructura \textit{itsClass}, pero el ejemplo presentado anteriormente grafica con toda claridad lo que se realiza al momento de detectar la modificación de una variable de clase.

Finalmente, se registra la modificación del valor en la base de datos de eventos de TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - fieldWrite   (thread: 101, p.ts: 1217207598468965888, depth: 1, ts: 1217207598469940992, fid: 115 (itsEdad), target: null, val: 6
\end{lstlisting}
\end{singlespace}

Aparentemente este registro es igual al de los atributos de instancia, pero la diferencia está en que este registro tiene su \textit{target} con valor \textit{null}
	
					\subparagraph{Variable local}

El registro de la modificación del valor de una variable local se realiza de la misma forma que el registro de la misma \ref{registerLocal}.

Al momento de detectar un evento del tipo \textit{line} el método del capturador de huella \textit{\_\_localWrite\_\_} se encarga de buscar a 	que objeto (método/función) pertenece la variable local y luego envía la información necesaria para crear el registro asociado a esta modificación en la base de datos de eventos de TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - localWrite (thread: 101, p.ts: 1217207598474802944, depth: 3, ts: 1217207598477009920, vid: 4, val: 3)
\end{lstlisting}
\end{singlespace}					

A continuación se muestra como se realiza la captura de la modificación del valor de una variable local:

\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys
import dis

class miTrace:
    def __init__(self):
        self.itsLnotab = None
        self.itsLocals = {}

    def __createlnotab__(self, aCode):
        theLnotab = {}
        if hasattr(aCode, 'co_lnotab'):
            table = aCode.co_lnotab
            index = 0
            last_index = None
            for i in range(0, len(table), 2):
                index = index + ord(table[i])
                if last_index == None:
                    last_index = index
                else:
                    theLnotab.update({index:tuple([last_index,index-1])})                
                    last_index = index
            theLnotab.update(
                        {
                         len(aCode.co_code)-1:tuple(
                                            [last_index,len(aCode.co_code)-1]
                                                    )
                         })                
        return theLnotab 
    
    def __getpartcode__(self, aCode, aLimits):
        theLower = aLimits[0]
        theUpper = aLimits[1]
        theCode = aCode.co_code
        theStoreFast = {}    
        while theLower < theUpper:
            theOp = ord(theCode[theLower])
            theNameOp = dis.opname[theOp]
            theLower = theLower + 1
            if theOp >= dis.HAVE_ARGUMENT:
                theValue = ord(theCode[theLower]) + ord(theCode[theLower+1])*256
                theLower = theLower + 2
                if theOp in dis.haslocal and theNameOp == 'STORE_FAST':
                    theArgumentValue = aCode.co_varnames[theValue]
                    theStoreFast.update({theArgumentValue:theValue})
        return theStoreFast
    
    def __localWrite__(self, aByteCodeLocals, aLocals):
        for theKey, theValue in aByteCodeLocals.iteritems():
            print "Modificando variable local", theKey,
            print "con el valor", aLocals[theKey]

    def __registerLocals__(self, aByteCodeLocals):
        for theKey, theValue in aByteCodeLocals.iteritems():
            if not self.itsLocals.has_key(theKey):
                print "Registrando variable local", theKey
                self.itsLocals.update({theKey:theValue})

    def trace(self, aFrame, aEvent, aArg):
        theCode = aFrame.f_code
        if aEvent == 'call':
            print "Llamada a", aFrame.f_code.co_name
            print "Byte Code asociado:"
            dis.disassemble(theCode)
            self.itsLnotab = self.__createlnotab__(theCode)
            return self.trace
        elif aEvent == 'line':
            if self.itsLnotab.has_key(aFrame.f_lasti):
                theByteCodeLocals = self.__getpartcode__(
                                                theCode,
                                                self.itsLnotab[aFrame.f_lasti]
                                                        )
                self.__registerLocals__(theByteCodeLocals)
                self.__localWrite__(theByteCodeLocals, aFrame.f_locals)
            return self.trace
        elif aEvent == 'return':
            if self.itsLnotab.has_key(aFrame.f_lasti):
                theByteCodeLocals = self.__getpartcode__(
                                                theCode,
                                                self.itsLnotab[aFrame.f_lasti]
                                                        )
                self.__registerLocals__(theByteCodeLocals)
                self.__localWrite__(theByteCodeLocals, aFrame.f_locals)
            print "Saliendo de", aFrame.f_code.co_name, 
            print "con valor", aArg
        elif aEvent == 'exception':
            pass


sys.settrace(miTrace().trace)
    
def miFuncion():
    thePrimera = 10
    theSegunda = 35
    thePrimera = 24
    theSegunda = 54
    return theSegunda

if __name__ == '__main__':
    miFuncion()
\end{lstlisting}
\end{singlespace}

Al ejecutar este código da como resultado:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Llamada a miFuncion
Byte Code asociado:
100           0 LOAD_CONST               1 (10)
              3 STORE_FAST               0 (thePrimera)

101           6 LOAD_CONST               2 (35)
              9 STORE_FAST               1 (theSegunda)

102          12 LOAD_CONST               3 (24)
             15 STORE_FAST               0 (thePrimera)

103          18 LOAD_CONST               4 (54)
             21 STORE_FAST               1 (theSegunda)

104          24 LOAD_FAST                1 (theSegunda)
             27 RETURN_VALUE        
Registrando variable local thePrimera
Modificando variable local thePrimera con el valor 10
Registrando variable local theSegunda
Modificando variable local theSegunda con el valor 35
Modificando variable local thePrimera con el valor 24
Modificando variable local theSegunda con el valor 54
Saliendo de miFuncion con valor 54
\end{lstlisting}
\end{singlespace}			
					
				\paragraph{Instanciación}	
				
El evento de instanciación ocurre en el momento que el programador crea un objeto de instancia (instancia de una clase).  En el evento de tipo \textit{call} el capturador de huella consulta por el método \textit{\_\_init\_\_}, si es la llamada de este método, se registra la instanciación de clase en la base de datos de eventos TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - instantiation(thread: 101, p.ts: 0, depth: 1, ts: 1217207598470598912, direct: true, c.bid: -1, e.bid: 105 (miClase.__init__), target: UID: 117, args: [Ljava.lang.Object;@8a2006])
\end{lstlisting}
\end{singlespace}					
				
				
	 			      \paragraph{Retorno de método/función}
				      
El evento de retorno de método o función sucede cuando ocurre un evento del tipo \textit{return} dentro del capturador de huella.  El evento de retorno ocurre independientemente si el programador escribe la instrucción \textit{return} dentro del cuerpo del método/función.			

\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys

def trace(aFrame, aEvent, aArg):
    if aEvent == 'call':
        return trace
    elif aEvent == 'line':
        return trace
    elif aEvent == 'return':
        print "Saliendo de", aFrame.f_code.co_name, 
        print "con valor", aArg
    elif aEvent == 'exception':
        pass

sys.settrace(trace)

def miFuncion(aPrimero, aSegundo):
    if aPrimero > aSegundo:
        theResultado = aPrimero + aSegundo
    else:
        theResultado = aPrimero - aSegundo
    return theResultado

if __name__ == '__main__':
    theResultado = miFuncion(10,5)
    print "Mi resultado es:", theResultado
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución de este código es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Saliendo de miFuncion con valor 15
Mi resultado es: 15
\end{lstlisting}
\end{singlespace}	


Finalmente se registra la salida del método/función en la base de datos de eventos de TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - behaviorExit (thread: 101, p.ts: 1217207598474802944, depth: 3, ts: 1217207598478802944, bid: 102 (miClase.miMetodo), thrown: false, ret: 3)
\end{lstlisting}
\end{singlespace}	

				      
				\paragraph{Excepción \label{excepcion}}
				
El evento excepción es registrado por el capturador de huella cuando este detecta el evento del tipo \textit{exception}.  Es importante señalar que existen dos situaciones en donde puede ocurrir una excepción:

\begin{itemize}
	\item Excepción sin bloque \textit{try/except}

Cuando ocurre una excepción en el código del programador, ésta debe ser propagada por todos los niveles de la pila de frames.  En este caso, como el programador no ha manejado la excepción, propagarla por todos los niveles de la pila es lo más sensato.

\begin{singlespace}
\begin{lstlisting}[style=Python]
def miPrimeraFuncion():
    miSegundaFuncion()
    
def miSegundaFuncion():
    miTerceraFuncion()

def miTerceraFuncion():
    miCuartaFuncion()

def miCuartaFuncion():
    y = 1/0

if __name__ == '__main__':
    miPrimeraFuncion()
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución de este código es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Saliendo de miCuartaFuncion con excepcion integer division or modulo by zero
Saliendo de miTerceraFuncion con excepcion integer division or modulo by zero
Saliendo de miSegundaFuncion con excepcion integer division or modulo by zero
Saliendo de miPrimeraFuncion con excepcion integer division or modulo by zero
Traceback (most recent call last):
  File "/Volumes/archivos/eclipse/workspace/python-project/src/testcase/memoryTrace.py", line 49, in <module>
    miPrimeraFuncion()
  File "/Volumes/archivos/eclipse/workspace/python-project/src/testcase/memoryTrace.py", line 37, in miPrimeraFuncion
    miSegundaFuncion()
  File "/Volumes/archivos/eclipse/workspace/python-project/src/testcase/memoryTrace.py", line 40, in miSegundaFuncion
    miTerceraFuncion()
  File "/Volumes/archivos/eclipse/workspace/python-project/src/testcase/memoryTrace.py", line 43, in miTerceraFuncion
    miCuartaFuncion()
  File "/Volumes/archivos/eclipse/workspace/python-project/src/testcase/memoryTrace.py", line 46, in miCuartaFuncion
    y = 1/0
ZeroDivisionError: integer division or modulo by zero
\end{lstlisting}
\end{singlespace}	


	\item Excepción con bloque \textit{try/except} 

En este caso no tiene sentido propagar la excepción por todos los niveles de la pila de frame, ya que el programador ha manejado correctamente la excepción, esto implica que sólo debe propagarse hasta el nivel en donde se ha realizado el manejo de excepción.	

\begin{singlespace}
\begin{lstlisting}[style=Python]
def miPrimeraFuncion():
    try:
        miSegundaFuncion()
    except:
        y = 5
    return y
    
def miSegundaFuncion():
    miTerceraFuncion()

def miTerceraFuncion():
    miCuartaFuncion()

def miCuartaFuncion():
    y = 1/0

if __name__ == '__main__':
    miPrimeraFuncion()
\end{lstlisting}
\end{singlespace}

El resultado de la ejecución de este código es:

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
Saliendo de miCuartaFuncion con excepcion integer division or modulo by zero
Saliendo de miTerceraFuncion con excepcion integer division or modulo by zero
Saliendo de miSegundaFuncion con excepcion integer division or modulo by zero
Saliendo de miPrimeraFuncion con valor 5
\end{lstlisting}
\end{singlespace}	

Los casos anteriores son implementados de la siguiente manera en el capturador de huellas:

\begin{singlespace}
\begin{lstlisting}[style=Python]
import sys
import dis

class miTrace(object):
    def __init__(self):
        self.FLAG_THROWN = False
        
    def trace(self, aFrame, aEvent, aArg):
        theCode = aFrame.f_code
        if aEvent == 'call':
            return self.trace
        elif aEvent == 'line':
            return self.trace
        elif aEvent == 'return':
            if self.FLAG_THROWN == True:
                self.FLAG_THROWN = False
                return            
            print "Saliendo de", aFrame.f_code.co_name, 
            print "con valor", aArg
        elif aEvent == 'exception':
            for theTuple in dis.findlinestarts(theCode):
                if aFrame.f_lineno in theTuple:
                    theIndex = theTuple[0]
            theOp = ord(theCode.co_code[theIndex-3])
            theInstruction = dis.opname[theOp]
            if theInstruction == 'SETUP_EXCEPT':
                return self.trace
            print "Saliendo de",aFrame.f_code.co_name,
            print "con excepcion", aArg[1]
            self.FLAG_THROWN = True         

sys.settrace(miTrace().trace)
\end{lstlisting}
\end{singlespace}	
\end{itemize}		

Finalmente, la excepción es registrada en la base de datos de eventos de TOD.

\begin{singlespace}
\begin{lstlisting}[style=consola,numbers=none]
h0 - exception    (thread: 101, p.ts: 1217207598480425984, depth: 3, ts: 1217207598480540928, pid: 115, exc.: UID: 10955936)
\end{lstlisting}
\end{singlespace}	

		\subsection{Protocolo Comunicación de pyTOD}

Se utilizó sockets para comunicar pyTOD con TOD.  Se confeccionaron mensajes para cada tipo de registro y para cada tipo de evento que se genera en el programa objetivo.

Es importante señalar que se utilizó la librería \textit{XDRLib} \cite{xdrlib} de python, basada en el estándar xdrlib\cite{xdrlibestandar}, para construir el protocolo de comunicación entre el lenguaje de programación Python y Java.

A continuación se detalla el protocolo de comunicación creado.

			\subsubsection{Identificadores}

				\paragraph{Sucesos}

La siguiente tabla muestra que cada suceso tiene un identificador en el sistema de capturación de huella.
\begin{table}[!h]
\begin{center}
\begin{tabular}{|l | c |}
\hline
\rowcolor[gray]{0.9}Suceso & Identificador\\
\hline
Registro & 0\\
\hline
Llamada & 1\\
\hline
Asignación & 2\\
\hline
Retorno & 3\\
\hline
Instanciación & 4\\
\hline
\end{tabular}
\caption{Identificadores de sucesos} 
\end{center}
\end{table}

				\paragraph{Objetos}
La siguiente tabla muestra que cada objeto tiene un identificador en el sistema de captura de huella.


\begin{table}[!h]
\begin{center}
\begin{tabular}{| l | c |}
\hline
\rowcolor[gray]{0.9}Id Objeto & Identificador\\
\hline
Clase & 0\\
\hline
Método & 1\\
\hline
Atributo & 2\\
\hline
Función & 3\\
\hline
Variable local & 4\\
\hline
Probe & 5\\
\hline
Thread & 6\\
\hline
Atributo de clase & 7\\
\hline
Objeto & 8\\
\hline
Excepción & 9\\
\hline
Método estático & 10\\
\hline 
\end{tabular}
\caption{Identificadores de objetos} 
\end{center}
\end{table}


				\paragraph{Tipo de datos}
La siguiente tabla muestra que cada tipo de datos tiene un identificador en el sistema de captura de huella.
\begin{table}[!h]
\begin{center}
\begin{tabular}{|l | c |}
\hline
\rowcolor[gray]{0.9}Tipo & Identificador\\
\hline
int & 0\\
\hline
str & 1\\
\hline
float & 2\\
\hline
long & 3\\
\hline
bool & 4\\
\hline
tuple & 5\\
\hline
list & 6\\
\hline
dict & 7\\
\hline
\end{tabular}
\caption{Identificadores de tipo de datos} 
\end{center}
\end{table}

			\subsubsection{Registro de objetos}

A continuación se muestra el formato que tienen el registro de los diferentes objetos dentro del capturador de huellas:\\

				\paragraph{Función}
Se describe el registro del objeto función:\\

\begin{table}[!h]
\begin{small}
\begin{center}
\begin{tabular}{| c | c | c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & functionId & functionName & argsCount & \{argName\textit{{\scriptsize  i}} & argId\textit{{\scriptsize  i}}\} & fileName\\
\hline
int & int & int & str & int & str & int & str\\
\hline
\end{tabular}
\caption{Registro del objeto función} 
\end{center}
\end{small}
\end{table}

				\paragraph{Variable local}
Se describe el registro del objeto variable local:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & localId & parentId & localName\\
\hline
int & int & int & int & str\\
\hline
\end{tabular}
\caption{Registro del objeto variable local} 
\end{center}
\end{table}

				\paragraph{Clase}
Se describe el registro del objeto clase:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & classId & className & classBases\\
\hline
int & int & int & str & --\footnotemark[1]\\
\hline
\end{tabular}
\caption{Registro del objeto clase} 
\end{center}
\end{table}

\footnotetext[1]{No se registran las super clases que pueda tener la clase.}

				\paragraph{Método}
Se describe el registro del objeto método:\\

\begin{table}[!h]
\begin{center}
\begin{footnotesize}
\begin{tabular}{| c | c | c | c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & methodId & classId & methodName & argsCount & \{argName\textit{{\scriptsize  i}} & argId\textit{{\scriptsize  i}}\} & fileName\\
\hline
int & int & int & int & str & int & str & int & str\\
\hline
\end{tabular}
\caption{Registro del objeto método} 
\end{footnotesize}
\end{center}
\end{table}

				\paragraph{Atributo de instancia}
Se describe el registro del objeto atributo de instancia:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & attributeId & parentId & attributeName\\
\hline
int & int & int & int & str\\
\hline
\end{tabular}
\caption{Registro del objeto atributo de instancia} 
\end{center}
\end{table}

				\paragraph{Atributo de clase}
Se describe el registro del objeto atributo de clase:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & attributeId & parentId & attributeName\\
\hline
int & int & int & int & str\\
\hline
\end{tabular}
\caption{Registro del objeto atributo de clase} 
\end{center}
\end{table}

				\paragraph{Thread}
Se describe el registro del objeto thread: \\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & threadId & sysId\\
\hline
int & int & int & int\\
\hline
\end{tabular}
\caption{Registro del objeto thread} 
\end{center}
\end{table}

				\paragraph{Probe}

Se describe el registro del objeto probe: \\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & Id & parentId & currentLasti & currentLineno \\
\hline
int & int & int & int & int & int\\
\hline
\end{tabular}
\caption{Registro del objeto probe} 
\end{center}
\end{table}
\ \newline

				\paragraph{Objeto}

Se describe el registro del objeto objeto:
\newline

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & typeId & Id & currentTimestamp\\
\hline
int & int & int & double & double\\
\hline
\end{tabular}
\caption{Registro del objeto objeto} 
\end{center}
\end{table}
				\paragraph{Excepción}

Se describe el registro del objeto excepción: \\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & typeId & theValue\\
\hline
int & int & int & value or valueId\footnotemark[1]\\
\hline
\end{tabular}
\caption{Registro del objeto excepción} 
\end{center}
\end{table}

%\footnotetext[1]{Si el objeto es un entero o un booleano se pasa por valor, de caso contrario se pasa el id del objeto registrado anteriormente}


			\subsubsection{Llamada de objetos}

A continuación se muestra el formato que tienen las llamadas de los objetos función y método dentro del capturador de huellas:\\

				\paragraph{Función}
Se describe la llamada al objeto función:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & functionId & argsCount & \{typeId\textit{{\scriptsize  i}} & argValue\textit{{\scriptsize  i}}\}\\
\hline
int & int & int & int & int & value or valueId\footnotemark[1]\\
\hline
\end{tabular}
\caption{Llamada al objeto función} 
\end{center}
\end{table}

				\paragraph{Método}

Se describe la llamada al objeto método:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & methodId & targetId & argsCount & \{typeId\textit{{\scriptsize  i}} & argValue\textit{{\scriptsize  i}}\}\\
\hline
int & int & int & int & int & int & value or valueId\footnotemark[1]\\
\hline
\end{tabular}
\caption{Llamada al objeto método} 
\end{center}
\end{table}

\footnotetext[1]{Si el objeto es un entero o un booleano se pasa por valor, de caso contrario se pasa el id del objeto registrado anteriormente}

Es importante señalar que todas estas llamadas estan acompañadas de los siguientes datos que se describen a continuación:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}probeId & parentTimeStampFrame & depth & currentTimeStamp & threadId\\
\hline
int & double & int & double & int \\
\hline
\end{tabular}
\caption{Coordenadas} 
\label{Coordenadas}
\end{center}
\end{table}

			\subsubsection{Instanciación de clase}

A continuación se muestra el formato que tiene la instanciación de clase dentro del capturador de huellas:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & behaviorId & targetId & argsCount & \{typeId\textit{{\scriptsize  i}} & argValue\textit{{\scriptsize  i}}\}\\
\hline
int & int & int & int & int & value or valueId\footnotemark[1]\\
\hline
\end{tabular}
\caption{Instanciación de clase} 
\end{center}
\end{table}

Es importante señalar que la instanciación está acompañada de los siguientes datos Tabla \ref{Coordenadas}.


			\subsubsection{Asignación - Modificación de objetos}
A continuación se muestra el formato que tienen las asignaciones/modificaciones de los objetos variable local, atributo de instancia y atributo de clase dentro del capturador de huellas:\\

				\paragraph{Variable local}

Se describe la asignación/modificación al objeto variable local:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & localId & typeId & value\\
\hline
int & int & int & int & value or valueId\footnotemark[1]\\
\hline
\end{tabular}
\caption{Registro del objeto variable local} 
\end{center}
\end{table}
\footnotetext[1]{Si el objeto es un entero o un booleano se pasa por valor, de caso contrario se pasa el id del objeto registrado anteriormente}

				\paragraph{Atributo de instancia}

Se describe la asignación/modificación al objeto atributo de instancia:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & attributeId & targetId & typeId & value\\
\hline
int & int & int & int & int & value or valueId\footnotemark[1]\\
\hline
\end{tabular}
\caption{Registro del objeto atributo de instancia} 
\end{center}
\end{table}


				\paragraph{Atributo de clase}

Se describe la asignación/modificación al objeto atributo de clase:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & objectId & staticFieldId & typeId & value\\
\hline
int & int & int & int & value or valueId\footnotemark[1]\\
\hline
\end{tabular}
\caption{Registro del objeto atributo de clase} 
\end{center}
\end{table}

Es importante señalar que todas estas asignaciones/modificaciones están acompañadas de los siguientes datos Tabla \ref{Coordenadas}.

			\subsubsection{Return}

A continuación se muestra el formato que tiene el return dentro del capturador de huellas:\\

Se describe return:\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{| c | c | c | c | c | c |}
\hline
\rowcolor[gray]{0.9}eventId & behaviorId & typeId & value & hasThrown & probeId \\
\hline
int & int & int & value or valueId\footnotemark[1] & bool & int\\
\hline
\end{tabular}
\caption{Registro de return} 
\end{center}
\end{table}

Es importante señalar return está acompañado de los siguientes datos \ref{Coordenadas}.

\footnotetext[1]{Si el objeto es un entero o un booleano se pasa por valor, de caso contrario se pasa el id del objeto registrado anteriormente}
		
		
		
		\subsection{Estructuras y Clases de pyTOD}
		
		
		  	\subsubsection{Estructura}

Para mostrar la estructura de pyTOD se utiliza un diagrama de clases resumido en el cual sólo se muestran las relaciones entre las clases, métodos y atributos más importantes de esta.  Lo anterior con el fin de mostrar una estructura clara y concisa.  En la sección posterior se individualizará cada una de las clases aquí mostradas. 
			
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.6]{images/classModelHunterTrace.eps}
	\caption{Diagrama de clase del capturador de huella}
\end{figure}			
			
			\subsubsection{Clases}
			
En esta sección se muestran todos los atributos y métodos de las clases que intervienen en pyTOD.  Se explica cual es su uso y se explica sus métodos y métodos más importantes.			

				\paragraph{hunterTrace}
				
Esta es la clase principal de pyTOD ya que contiene referencias a las demás clases y es la clase que contiene al método \textit{\_\_trace\_\_}

					\subparagraph{Atributos}
					
Entre los atributos más importantes se tienen:
\begin{itemize}
	\item \textbf{itsClass :} Diccionario que contiene a todas las clases escritas por el programador.
	\item \textbf{itsFunction :} Diccionario que contiene a todas las funciones escritas por el programador.
	\item \textbf{itsMethod :} Diccionario que contiene a todos los métodos escritos por el programador.
	\item \textbf{itsProbe :} Diccionario que almacena todos los probes que se generan en el depurador.  El objetivo de cada probe es identificar un lugar específico dentro del código depurado en donde ha ocurrido un evento.
	\item \textbf{itsEvent :} Diccionario que contiene todos los eventos que suceden dentro del depurador:
	\begin{itemize}
		\item register
		\item call
		\item return
		\item instantiation
	\end{itemize}
	
	\item \textbf{itsObjects :} Diccionario que contiene todos los tipos de objetos que pueden encontrarse dentro del programa depurado:
	\begin{itemize}
		\item class
		\item method
		\item attribute
		\item function
		\item local
		\item probe
		\item thread
		\item classAttribute
		\item object
		\item exception
		\item specialMethod
	\end{itemize}	
	
	\item \textbf{itsPackXDR :} Diccionario que es utilizado para reconocer el tipo de datos de un objeto.  Al momento que el tipo de datos es reconocido se devuelve el identificador para que la libería XDRLib sepa con que tipo de objeto está tratando.  El contenido de este diccionario es:
	\begin{itemize}
		\item int
		\item string
		\item float
		\item double
		\item bool	
	\end{itemize}
	
	\item \textbf{itsDataTypes :} Diccionario que se utiliza para identificar el tipo de dato que se está enviando desde Python hacia Java, que es donde se almacenan en la base de datos de TOD.  El contenido de este diccionario es:
	\begin{itemize}
		\item int.\_\_name\_\_
		\item str.\_\_name\_\_
		\item float.\_\_name\_\_
		\item long.\_\_name\_\_
		\item bool.\_\_name\_\_
		\item tuple.\_\_name\_\_
		\item list.\_\_name\_\_
		\item dict.\_\_name\_\_
	\end{itemize}
	
	\item \textbf{FLAG\_DEBUGG :} Atributo utilizado para mostrar cierta información de los eventos o de las registraciones, cuando su valor es \textit{True}.
	
	\item \textbf{FLAG\_THROWN :} Atributo utilizado para controlar la propagación de excepciones.  La utilización de este es explicado en la sección \ref{excepcion}.
	
	\item \textbf{itsCurrentDepth :} Atributo utilizado para guardar el nivel actual de llamadas, se utiliza para el evento de modificación de un atributo de clase.
\end{itemize}			
					
					\subparagraph{Métodos}
					
Entre los métodos más importantes se tienen:
\begin{itemize}
	\item \textbf{\_\_createlnotab\_\_ :} Método que crea una estructura de datos la cual almacena la estructura de bytecode del objeto que se está registrando en el depurador.  Este método sólo se aplica a los objetos \textit{class}, \textit{method} y \textit{function}.

	\item \textbf{\_\_getPartCode\_\_ :} Método que se utiliza para inspeccionar el bytecode por bloques (inicio, fin) con el objetivo de extraer todas las variables locales definidas en este bloque.
	
	\item \textbf{\_\_trace\_\_ :} Método más importante de la clase y de pyTOD.  Éste permite estar notificados de los siguientes eventos dentro de un programa Python:
	\begin{itemize}
		\item call
		\item line
		\item return
		\item exception
	\end{itemize}
En este método se centra la mayoría de los movimientos para la captura de la huella de ejecución.  Es importante señalar que por si sólo este método no tiene ninguna utilidad, ya que debemos indicar a Python que asigne \textit{\_\_trace\_\_} como función al módulo \textit{sys} mediante su método \textit{settrace}.
\end{itemize}

\begin{figure}
\centering
\begin{minipage}[c]{5.5cm}
\includegraphics[scale=0.6]{images/Clases/hunterTraceAttr.eps}
\end{minipage}
\begin{minipage}[c]{5.5cm}
\includegraphics[scale=0.6]{images/Clases/hunterTraceMethods.eps}
\end{minipage}
\caption{Diagrama de clase de hunterTrace}
\end{figure}

					
				\paragraph{generatorId}

Esta clase sirve para implementar todos los generadores de identificadores que se requieren para que el depurador funcione correctamente.

					\subparagraph{Atributos}

\begin{itemize}
	\item \textbf{Id :} Atributo que mantiene el valor actual del identificador.  El rango al que el identificador pertenece es [$101 \dots n$].  Esto debido a que TOD tiene reservado el rango [$1 \dots 100$] para objetos internos.
\end{itemize}					
					
					\subparagraph{Métodos}						

\begin{itemize}
	\item \textbf{\_\_get\_\_ :} Retorna el valor actual del atributo \textit{Id}.
	\item \textbf{\_\_next\_\_ :} Método que aumenta en una unidad el atributo \textit{Id}.
\end{itemize}					

					
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{images/Clases/generatorId.eps}
	\caption{Diagrama de clase de generatorId}
\end{figure}
					
				\paragraph{Class}
				
Esta clase representa a cada una de las clases que ha definido el programador en su script.				
				
					\subparagraph{Atributos}

Los atributos más importantes son:

\begin{itemize}
	\item \textbf{staticField:} Diccionario que guarda todos los atributos estáticos que pertenecen a la clase.
	\item \textbf{code :} Atributo que guarda el objeto code \cite{code} de la clase original que definió el programador.
	\item \textbf{specialBehaviorId :} Atributo que sirve como contador para identificar a cada método estático registrado en la clase
\end{itemize}					
					
					\subparagraph{Métodos}	

\begin{itemize}
	\item \textbf{\_\_getLnotab\_\_ :} Retorna el \textit{lnotab} correspondiente de la clase.
	\item \textbf{\_\_addAttribute\_\_ :} Agrega un nuevo atributo de instancia a la clase.
	\item \textbf{\_\_addMethod\_\_ :} Agrega un nuevo método a la clase.
\end{itemize}					

				
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.6]{images/Clases/Class.eps}
	\caption{Diagrama de clase de Class}
\end{figure}
					
				\paragraph{Method}
				
Esta clase representa a cada método que el programador haya definido en cualquiera de sus clases.				
				
					\subparagraph{Atributos}
					
\begin{itemize}
	\item \textbf{locals :} Diccionario que representa a todas las variables locales definidas en el método.
	\item \textbf{argument :} Diccionario que representa todos los argumentos que tiene el método.
	\item \textbf{idClass :} Atributo que indica a que clase pertenece el método.
\end{itemize}					
					
					\subparagraph{Métodos}						
					
\begin{itemize}
	\item \textbf{\_\_getLocals\_\_ :} Método que retorna todas las variables locales del método.
	\item \textbf{\_\_getArgValues\_\_ :} Retorna el valor de todos los argumentos que se encuentran en \textit{frame.f\_locals}.
\end{itemize}					
					
				
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.6]{images/Clases/Method.eps}
	\caption{Diagrama de clase de Method}
\end{figure}
					
				\paragraph{Function}

Esta clase representa a cada función que el programador haya definido en cualquiera de sus clases.				
				
					\subparagraph{Atributos}
					
\begin{itemize}
	\item \textbf{locals :} Diccionario que representa a todas las variables locales definidas en la función.
	\item \textbf{argument :} Diccionario que representa todos los argumentos que tiene la función.
\end{itemize}					
					
					\subparagraph{Métodos}						
					
\begin{itemize}
	\item \textbf{\_\_getLocals\_\_ :} Método que retorna todas las variables locales de la función.
	\item \textbf{\_\_getArgValues\_\_ :} Retorna el valor de todos los argumentos que se encuentran en \textit{frame.f\_locals}.
\end{itemize}					
					
				
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.6]{images/Clases/Function.eps}
	\caption{Diagrama de clase de Function}
\end{figure}
					
				\paragraph{Dictionary}
				
Esta clase hereda del objeto nativo de Python \textit{dict}.  Esta clase se utiliza para almacenar los atributos de instancia, atributos de clase y variables locales de métodos y funciones.										
					\subparagraph{Atributos}
					
\begin{itemize}
	\item \textbf{hT :} Atributo que hace referencia al \textit{hunterTrace} que pertenece. 
\end{itemize}					
					
					
					\subparagraph{Métodos}						
					
\begin{itemize}
	\item \textbf{\_\_update\_\_ :}  Método que actualiza los elementos del diccionario, si el elemento no existe notifica a la base de datos estructural de TOD su creación y si el elemento existe notifica a la base de datos de eventos de TOD la modificación.
\end{itemize}					
					
				
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.6]{images/Clases/Dictionary.eps}
	\caption{Diagrama de clase de Dictionary}
\end{figure}
					
		
		
		\subsection{Código Principal de pyTOD}
		
En esta sección se mostrará el código principal de pyTOD utilizando el lenguaje de pseudocódigo, para facilitar el entendimiento de este.  El código que se muestra son sólo las partes más importantes dentro del método \textit{\_\_trace\_\_}, detallando los eventos del tipo \textit{call}, \textit{line}, \textit{return} y \textit{exception}.
\algsetup{
linenosize=\scriptsize,
linenodelimiter=
}
\begin{algorithm}
\begin{footnotesize}
\begin{algorithmic}[1]
\REQUIRE $aFrame, aEvent, aArg$
\STATE $theCode \Leftarrow aFrame.f\_code$
\STATE $theLocals \Leftarrow aFrame.f\_locals$
\STATE $theGlobals \Leftarrow aFrame.f\_globals$
\STATE $aFrame \Leftarrow \_\_markTimestampFrame\_\_()$
\IF{$aEvent == 'call'$}
	\IF{$self \in theLocals$ }
		\STATE $\_\_registerMethod\_\_()$
		\IF {$theCode.co\_name == '\_\_init\_\_'$}
			\STATE asignar identificador unico a instancia de clase
			\STATE $\_\_registerInstantiation\_\_()$
		\ELSE
			\STATE $\_\_methodCall\_\_()$
		\ENDIF
	\ELSE
		\IF{$theObject$ es del tipo $function$}
			\STATE $\_\_functionCall\_\_()$
		\ENDIF
	\ENDIF
	\RETURN $\_\_trace\_\_$
\ELSIF{$aEvent == 'line'$}
	\STATE $theObject \Leftarrow \_\_getObject\_\_()$
	\STATE $theLnotab \Leftarrow \_\_getLnotab\_\_()$
	\IF{$aFrame.f\_lasti \in theLnotab$}
		\STATE $theByteCodeLocals \Leftarrow \_\_getPartCode\_\_()$
		\STATE $\_\_registerLocals\_\_()$
		\STATE $\_\_localWrite\_\_()$
	\ENDIF
	\RETURN $\_\_trace\_\_$
\ELSIF{$aEvent == 'return'$}
	\IF{$'\_\_init\_\_' \in theLocals$}
		\IF{$code \not\in class$}
			\STATE $\_\_registerClass\_\_()$
		\ENDIF
	\ELSE
		\STATE $theObject \Leftarrow \_\_getObject\_\_()$
		\IF{$FLAG\_THROWN == \TRUE$}
			\STATE $FLAG\_THROWN \Leftarrow$ \FALSE
		\ENDIF

		\STATE $theObject \Leftarrow \_\_getObject\_\_()$
		\STATE $theLnotab \Leftarrow \_\_getLnotab\_\_()$
		\IF{$aFrame.f\_lasti \in theLnotab$}
			\STATE $theByteCodeLocals \Leftarrow \_\_getPartCode\_\_()$
			\STATE $\_\_registerLocals\_\_()$
			\STATE $\_\_localWrite\_\_()$
		\ENDIF
		\STATE $\_\_behaviorExit\_\_()$	
	\ENDIF
\ELSIF{$aEvent == 'exception'$}
	\STATE $\_\_registerException\_\_()$
	\IF{excepción es manejada en el bloque == \TRUE}
		\RETURN $\_\_trace\_\_$
	\ENDIF
	\STATE $\_\_behaviorExit\_\_()$
	\STATE $FLAG\_THROWN \Leftarrow \TRUE$
\ENDIF
\end{algorithmic}
\end{footnotesize}
\caption{Código principal de pyTOD}
\end{algorithm}

\newpage	
		\subsection{Interfaces principales de pyTOD}
		
Esta sección describe las interfaces principales que encontrará el usuario en pyTOD.  Se describe desde arrancar el depurador hasta como interactuar con éste.

			\subsubsection{Arrancar el depurador}	

Luego de abrir una sesion en Eclipse se debe arrancar el depurador:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/interfacesPlugin/arrancarTOD.eps}
	\caption{Botón para arrancar el depurador}
\end{figure}

Al momento de presionar este botón se mostrará un proceso hijo de Eclipse, el cual contiene al ambiente completo para comenzar a realizar la depuración.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/interfacesPlugin/arrancarTOD-2.eps}
	\caption{Proceso Eclipse hijo lanzado}
\end{figure}

Al terminar la carga completa del proceso Eclipse hijo, se muestra la perspectiva para realizar depuración.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/interfacesPlugin/arrancarTOD-3.eps}
	\caption{Perspectiva inicial para depuración}
\end{figure}

			\subsubsection{Realizando depuración}
			
El usuario después de escribir su código lo puede depurar presionando el siguiente botón:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/interfacesPlugin/depuracionTOD.eps}
	\caption{Botón de depuración}
\end{figure}

Después de ejecutar el depurador se le mostrará la siguiente interfaz al usuario:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/interfacesPlugin/depuracionTOD-2.eps}
	\caption{Interfaz inicial luego de haber depurado el código del usuario}
\end{figure}

Lo que se muestra aquí son todos los eventos ocurridos en el script del programador, quien haciendo doble click se encuentra con la siguiente interfaz:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/interfacesPlugin/depuracionTOD-3.eps}
	\caption{Control de flujo}
\end{figure}

Como se puede observar en esta figura se ha seleccionado la linea en la que el método \textit{f4} lanza una excepción.  Como se puede observar en la siguiente figura, en el momento que el usuario selecciona la línea el depurador inmediatamente ubica en el código fuente la linea que se está examinando.

 \begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/interfacesPlugin/depuracionTOD-4.eps}
	\caption{Línea inspeccionada}
\end{figure}

	\section{Aspectos Básicos de Funcionamiento de pyTOD}
	
En esta sección se detallarán los pasos necesarios a seguir para obtener el depurador TOD y pyTOD.	
		\subsection{Usuario final}
		
Usuario final se refiere al usuario que sólo realizará depuración omnisciente en sus scripts y no tendrá la intención de realizar mejoras o implementar nuevas características.  Este usuario sólo debe visitar \href{http://pleiad.dcc.uchile.cl/files/tod/releases/}{http://pleiad.dcc.uchile.cl/files/tod/releases/} y descargar la última versión liberada.  Es importante señalar que los únicos requerimientos que se necesitan son:
\begin{itemize}
	\item Eclipse 3.2 o superior.
	\item Java 1.5 o superior.
	\item Python 2.5.
	 \item Sistema operativo basado en el kernel de Linux 2.6.x
\end{itemize}	

Para mayor información puede visitar \href{http://pleiad.dcc.uchile.cl/tod/download.html}{http://pleiad.dcc.uchile.cl/tod/download.html}.
		
		\subsection{Desarrollador}
		
Para que el desarrollador pueda trabajar comodamente y pueda aportar mejoras e implementar nuevas características, debe seguir los siguentes pasos para instalar la versión de desarrollo:

\begin{itemize}
	\item Instalar Eclipse 3.2 o superior.
	\item Instalar Java 1.5 o superior.
	\item Instalar Python 2.5
	 \item Descargar mediante svn los siguientes proyectos:
	 \begin{itemize}
		\item http://stgo.dyndns.org/svn/gpothier/devel/zz.utils
		\item http://stgo.dyndns.org/svn/gpothier/devel/zz.eclipse.utils
		\item http://pleiad.dcc.uchile.cl/svn/tod/pytod/trunk/java-proyect
		\item http://pleiad.dcc.uchile.cl/svn/tod/dbgrid/trunk
		\item http://pleiad.dcc.uchile.cl/svn/tod/agent/trunk
		\item http://pleiad.dcc.uchile.cl/svn/tod/tod.plugin.pytod/trunk
		\item http://pleiad.dcc.uchile.cl/svn/tod/tod.plugin.ajdt
		\item http://pleiad.dcc.uchile.cl/svn/tod/tod.plugin/trunk
		\item http://pleiad.dcc.uchile.cl/svn/tod/core/trunk
		\item http://pleiad.dcc.uchile.cl/svn/tod/pytod/trunk/python-project
		\item http://pleiad.dcc.uchile.cl/svn/tod/evdb1/trunk
	 \end{itemize}
\end{itemize}

Dentro de eclipse se debe modificar las configuraciones de ejecución de los siguientes archivos:

\begin{itemize}
	\item \textbf{GridMaster}
	\begin{itemize}
		\item \textit{Argumentos}

Para ejecutar este programa Java se debe notar que existen dos tipos de argumentos: los argumentos del programa y los argumentos de la maquina virtual.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/aspectoFuncionamiento/argsGridMaster.eps}
	\caption{Argumentos de GridMaster}
\end{figure}		
		
		\item \textit{Classpath}
		
Es importante tener bien configurada esta sección ya que varios proyectos dependen de otros y si no se establecen las relaciones entre ellos, el depurador no funcionará.
		
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/aspectoFuncionamiento/ClasspathGridMaster.eps}
	\caption{Classpath de Gridmaster}
\end{figure}		
\ \newline

	\end{itemize}
	\item \textbf{StandaloneUI}
	\begin{itemize}
		\item \textit{Argumentos}
		
Para ejecutar este programa Java se debe notar que existen dos tipos de argumentos: los argumentos del programa y los argumentos de la maquina virtual.
		
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/aspectoFuncionamiento/argsStandaloneUI.eps}
	\caption{Argumentos de StandaloneUI}
\end{figure}		
		
		\item \textit{Classpath}

Es importante tener bien configurada esta sección ya que varios proyectos dependen de otros y se no se establecen las relaciones entre ellos, el depurador no funcionará.
	
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/aspectoFuncionamiento/ClasspathStandaloneUI.eps}
	\caption{Classpath de StandaloneUI}
\end{figure}		
\ \newline

	\end{itemize}
	\item \textbf{Plugin}
	\begin{itemize}
		\item \textit{Argumentos}

Para ejecutar este programa Java se debe notar que existen dos tipos de argumentos: los argumentos del programa y los argumentos de la maquina virtual.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/aspectoFuncionamiento/argsTODPlugin.eps}
	\caption{Argumentos de TOD Plugin}
\end{figure}
	\end{itemize}	
\end{itemize}
	
	\section{Medidas de rendimiento de pyTOD}
	
Para medir la sobrecarga que realiza pyTOD sobre los scripts depurados se ha medido el tiempo de ejecución de los scripts sin depurar y luego el resultado del tiempo de ejecución cuando son depurados.  Los tiempos que se muestran a continuación son los mejores tiempos obtenidos de cinco tiempos de ejecución de cada script.  Las características del computador en el que se realizaron las mediciones son: Procesador de 2.4 GHz Intel Core 2 Duo, memoria ram de 2 GB 667 MHz DDR2, sistema operativo de Ubuntu 8.04.

El primer algoritmo en el cual se realizaron mediciones es el de \textit{ordenamiento por burbuja}:

\begin{singlespace}
\begin{lstlisting}[style=Python]
class Sort(object):
    
    def __init__(self, aArreglo=None):
        if aArreglo is None:
            aArreglo = []
        self.aArreglo = aArreglo
    
    def burble(self):
        for i in range(len(self.aArreglo)):
            for j in range(i, len(self.aArreglo)):
                if self.aArreglo[i] > self.aArreglo[j]:
                    theAux = self.aArreglo[i]
                    self.aArreglo[i] = self.aArreglo[j]
                    self.aArreglo[j] = theAux
    
if __name__ == '__main__':
    theArreglo = list(range(5000))
    theSort = Sort(theArreglo)
    theSort.burble()
\end{lstlisting}
\end{singlespace}	

El mejor tiempo de ejecución para este script sin el depurador fue de $4,77015805244$ segundos, y el mejor tiempo de ejecución con el depurador $1$.$878,3465$.  Presentando una sobrecarga aproximada de $393$ veces. Es importante señalar que el depurador en este caso ha registrado el total de $12$.$507$.$506$ eventos.

El segundo algoritmo en el cual se realizaron mediciones es en \textit{fibonacci}:

\begin{singlespace}
\begin{lstlisting}[style=Python]
class Fibonacci(object):
    
    def __init__(self):
        self.resultado = -1
        
    def fibonacci(self, n):
        if n == 1 or n == 2:
            self.resultado = 1
        elif n > 2:
            self.resultado = self.fibonacci(n-1) + self.fibonacci(n-2)
        return self.resultado

if __name__ == '__main__':
    theNumero = 32
    theFibonacci = Fibonacci()
    print theFibonacci.fibonacci(theNumero)
\end{lstlisting}
\end{singlespace}	

El mejor tiempo de ejecución para este script sin el depurador fue de $3,5871169$ segundos, y el mejor tiempo de ejecución con el depurador $2$.$846,12946486$.  Presentando una sobrecarga aproximada de $793$ veces.  Es importante señalar que el depurador en este caso ha registrado el total de $13$.$069$.$854$ eventos.
	
\chapter{Evaluación de pyTOD en casos de pruebas}
	\section{Selección de casos de uso}

En esta sección se seleccionan tres casos de uso: división por cero, fibonacci y manejador de archivo.  El primero se utilizar para mostrar el registro correcto de excepciones sin manejar por parte del programador, el segundo se utiliza para mostrar la capacidad de pyTOD para la captura de huella y posterior navegación en ella y el tercero para mostrar la capacidad de pyTOD para encontrar excepciones manejadas por parte del programador y encontrar la causa inicial del problema.

\begin{itemize}
	\item \textit{\textbf{División por cero:}} Este es un sencillo script que toma un valor $a$ de forma aleatoria, utilizando la función \textit{random} de la librería \textit{random}, luego toma este valor e itera en el rango $[1,\dots,100]$ dividiendo al numerador por la sustracción $rango_{i} - a$.
	
	El algoritmo que se utiliza es el siguiente:
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

from random import random

class Division(object):
    
    def __init__(self, aRandomValue):
        self.theRandomValue = aRandomValue
    
    def division(self):
        for theIndex in range(1,101):
            theResult = 1/(theIndex - self.theRandomValue)
            pass
        
if __name__ == '__main__':
    theDivision = Division(int(random() * 100))
    theDivision.division()
\end{lstlisting}
\end{singlespace}		
	
	\item \textit{\textbf{Fibonacci :}} Este algoritmo, ampliamente conocido en el ámbito de la computación, construye una serie aritmética sumando los términos $t_{i-1}$ y $t_{i-2}$ para formar el término i-ésimo de la serie.  Para la implementación utilizada $i \in [2,\dots,n]$ y los términos $t_{0}$ y $t_{1}$ tienen los valores $1$ y $1$ respectivamente.
	
	El algoritmo que se utiliza es el siguiente:
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

import sys

class Fibonacci(object):
    
    def __init__(self):
        self.resultado = -1
        
    def fibonacci(self, n):
        if n == 0 or n == 1:
            self.resultado = 1
        elif n > 1:
            self.resultado = self.fibonacci(n-1) + self.fibonacci(n-2)
        return self.resultado

if __name__ == '__main__':   
    theNumero = 5
    theFibonacci = Fibonacci()
    print theFibonacci.fibonacci(theNumero)
\end{lstlisting}
\end{singlespace}	
	
	\item \textit{\textbf{Manejador de archivos :}} Este algoritmo toma tres nombres de archivos, con un directorio dado.  Los nombres son tomados uno por uno, el algoritmo abre el archivo y lo renombra para luego guardarlo en el mismo directorio.  Claramente este algoritmo fue mal diseñado por el desarrollador, ya que, en el manejo de excepciones deja que silenciosamente estas no sean mostradas al usuario final, dando la impresión que la tarea ha sido completada con éxito.

	El algoritmo que se utiliza es el siguiente:
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-
class ExampleFile(object):
    
    def __init__(self):
        self.theDirectory = 'images'
    
    def abrir(self, aName):
        try:
            theFile = open(self.theDirectory + '/' + aName)
            theNewFile = open(self.theDirectory + '/' + 'NEW' +aName,'w+')
            theNewFile.close()
        except:
            return -1
    
    def converter(self, aFile):
        im = self.abrir(aFile)
        
if __name__ == '__main__':
    theExample = ExampleFile()
    theNames = ['tree_branches_and_roots_01.png',
                'acorn_jonathan_dietrich_01.png',
                'claveles.png']
    for theName in theNames:
        try:
            theExample.converter(theName)
        except:
            pass
\end{lstlisting}
\end{singlespace}	
	
	
\end{itemize}	
	
	\section{Resultados obtenidos con pyTOD}

En esta sección se muestran los resultados de depuración obtenidos de los tres casos de uso seleccionados.

		\subsection{División por cero}
		
En el momento de ejecutar este script, Eclipse lanza la siguiente excepción:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/division/Exception.eps}
	\caption{Excepción lanzada por el script division.py}
\end{figure}

De lo único que se puede estar enterado es que el script falló en la lína 10, cosa que es útil pero no es de gran ayuda.

En la misma ejecución del script se puede ingresar a la perspectiva de pyTOD.  Lo primero que se vera es el mural de hilos de ejecución con sus eventos respectivos.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/division/threadMurals.eps}
	\caption{Eventos sucedidos para el script division.py}
\end{figure}

Al presionar dos veces el mural en el hilo que nos interesa o al presionar el botón \textit{ver control de flujo} se mostrarán todas las llamadas a métodos e instanciaciones a objetos.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.8]{images/division/controlFlow.eps}
	\caption{Control de flujo para el script division.py}
\end{figure}

Se puede observar dos cosas de gran interés: (A) la clase fue instanciada con el valor $25$ y (B) el método \textit{division} tiene como valor de salida la excepción \textit{integer division or modulo by zero}.

Al presionar dos veces el método \textit{division} se mostrarán todos los eventos ocurridos dentro de este.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.45]{images/division/events.eps}
	\caption{Eventos ocurridos dentro del método division}
\end{figure}

Por comodidad se muestran los últimos eventos en donde se puede ver que el último valor para \textit{theIndex} fue $25$.  Sabiendo que el valor con que la clase fue construida, por simple inspección se sabe que el valor para el cual el método lanza la excepción es el valor $25$.

Además el programador puede verificar la estructura de su clase presionando el botón \textit{ver clases}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/division/structure.eps}
	\caption{Estructura de script division.py}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/division/structureDivision.eps}
	\caption{Método division con sus variables locales}
\end{figure}

		\subsection{Fibonacci}
		
Al momento de ejecutar este script, termina de forma correcta, esto debido a que sólo se quiere mostrar la capacidad de captura de huella de pyTOD.  La salida que se muestra es la siguiente:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/fibonacci/Exception.eps}
	\caption{Resultado de ejecución para el script fibonacci.py}
\end{figure}		

Inspeccionando el mural de hilos de ejecución se pueden ver todos los eventos generados.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{images/fibonacci/threadMurals.eps}
	\caption{Eventos sucedidos para el script fibonacci.py}
\end{figure}

Al presionar dos veces sobre el mural de hilos de ejecución se muestra el flujo de control principal.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/fibonacci/controlFlow.eps}
	\caption{Control de flujo para el script fibonacci.py}
\end{figure}

Lo que es de mayor interés para este caso es que la llamada al método \textit{fibonacci} con valor $5$ para su argumento, retorna el valor $8$.

Se muestra el siguiente árbol de ejecución para este algoritmo, con el fin de verificar posteriormente el resultado de pyTOD.
\begin{center}
\pstree
{\Toval{$f(5)$} }
	{
		\pstree
		{\Toval{$f(4)$}}
		{
			\pstree
			{\Toval{$f(3)$}}
			{
				\pstree
				{\Toval{$f(2)$}}
				{
					\Tcircle{$f(0)$}
					\Tcircle{$f(1)$}
				}
				\Tcircle{$f(1)$}
			}
			\pstree
			{\Toval{$f(2)$}}
			{
				\Tcircle{$f(0)$}
				\Tcircle{$f(1)$}			
			}
		}
		\pstree
		{\Toval{$f(3)$}}
		{
			\pstree
			{\Toval{$f(2)$}}
			{
				\Tcircle{$f(0)$}
				\Tcircle{$f(1)$}
			}
			\Tcircle{$f(1)$}
		}
}
\end{center}

Se sabe que $f(0)$ y $f(1)$ devuelven el valor $1$ respectivamente.

\newpage

Al ingresar al llamado de \textit{fibonacci(5)} se tiene:

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{images/fibonacci/fibonacci5.eps}
	\caption{Control de flujo para fibonacci(5)}
\end{figure}

Por un tema de facilidad sólo se mostrará el recorrido inorden del árbol anteriormente mostrado.

Se ingresar a \textit{fibonacci(4)} que como se puede observar retorna el valor $5$.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{images/fibonacci/fibonacci4.eps}
	\caption{Control de flujo para fibonacci(4)}
\end{figure}

Se ingresar a \textit{fibonacci(3)} que como se puede observar retorna el valor $3$.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{images/fibonacci/fibonacci3.eps}
	\caption{Control de flujo para fibonacci(3)}
\end{figure}

Se ingresar a \textit{fibonacci(2)} que como se puede observar retorna el valor $2$.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{images/fibonacci/fibonacci2.eps}
	\caption{Control de flujo para fibonacci(2)}
\end{figure}

Como se puede observar pyTOD es capas de capturar correctamente la huella de ejecución.

El programador al igual que en el ejemplo anterior podrá ver la estructura del script, sus métodos y variables locales.

		\subsection{Manejador de archivo}

Al ejecutar este script la salida por consola indica que todo ha ido bien (no se muestran mensajes).

Inspeccionando el mural de hilos de ejecución se pueden ver todos los eventos.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/manejadorArchivo/threadMurals.eps}
	\caption{Eventos sucedidos para el script manejadorArchivo.py}
\end{figure}	

Al presionar dos veces en el mural de hilo de ejecución se muestra el control de flujo principal.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/manejadorArchivo/controlFlow.eps}
	\caption{Control de flujo para el script manejadorArchivo.py}
\end{figure}

A simple vista todas las llamadas a métodos han retornado un valor váido y ninguno ha levantado excepción alguna.  Sin embargo se sabe que la llamada a \textit{converter} con valor \textit{claveles.png} en su argumento debiera haber lanzado una excepción, ya que, este archivo no existe.

A continuación se inspecciona la llamada a este \textit{converter}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/manejadorArchivo/intoConverter.eps}
	\caption{Eventos dentro de la llamada de converter}
\end{figure}

En este nivel tampoco se observa directamente que algo ha ido mal.  Con el fin de seguir inspeccionando se ingres a la llamada del método \textit{abrir} con valor en su argumento de \textit{claveles.png}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{images/manejadorArchivo/Exception.eps}
	\caption{Excepción dentro del método abrir}
\end{figure}

Como se puede observar se ha encontrado una excepción con un valor \textit{No such file or directory}, en el momento que la variable local \textit{aName} tenía como valor \textit{claveles.png}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{images/manejadorArchivo/state.eps}
	\caption{Valores de variables cercanas a la excepción}
\end{figure}

El programador de la misma forma que los casos anteriores puede observar la estructura del programa.

\chapter{Conclusiones}

Las herramientas de depuración de código, son las herramientas que prestan más ayuda a los desarrolladores de software tanto en la etapa de desarrollo como en la etapa de puesta en marcha de un proyecto informático.  Es por esto que existía una gran motivación de encontrar un área, dentro de la depuración, en la cual se pudiera realizar un trabajo a nivel de ingeniería que fuera un aporte interesante.  En la actualidad la formación del Ingeniero Civil en Computación e Informática no contempla asignaturas en las que se enseñen los distintos enfoques y arquitecturas de los depuradores.  Debido a esto al comienzo del trabajo de memoria existía incertidumbre sobre los posibles problemas que se pudieran encontrar en esta área totalmente desconocida, incertidumbre que a través del desarrollo de este trabajo de título fue desapareciendo.

El análisis del marco teórico se volvió fundamental ya que sienta las bases para poder conocer las principales ventajas y desventajas de los tres distintos enfoques que existen para realizar depuración de código:

\begin{itemize}
	\item Basado en mensajes.
	\item Punto de quiebre.
	\item Omnisciente.
\end{itemize}

El resultado de este análisis condujo el presente trabajo por el enfoque de los depuradores omniscientes debido a sus características que superan a las de los depuradores de punto de quiebre y los basados en mensajes.  Esto a pesar de que este tipo de depuradores no ha podido posicionarse como el enfoque de facto para realizar depuración de software.  La pregunta principal que se planteó en ese momento fue \textit{¿Por qué los depuradores omniscientes no son los más utilizados?}.  

Con el objetivo de responder la pregunta anteriormente planteada, se decidió buscar y estudiar las implementaciones existentes del enfoque de depuración omnisciente.  La búsqueda de las implementaciones fue compleja y se encontró poca cantidad de implementaciones de este enfoque, comparado con la cantidad encontrada de implementaciones que tienen los enfoques de punto de quiebre y basado en mensajes.  El principal problema que se argumentaba dentro de los mismos desarrolladores de los depuradores omniscientes, era la gran capacidad de almacenamiento que se requería para almacenar la huella de ejecución completa de una sesión de depuración y el complejo manejo de los datos que esto implicaba. 

La poca cantidad de depuradores omniscientes desarrollados fue una señal potente de que implementar un depurador omnisciente no era una tarea fácil y menos una tarea que la pudiera desarrollar un individuo en si.  Entendiendo que no era posible desarrollar un depurador omnisciente desde cero, se enfocó el estudio en un depurador omnisciente llamado TOD.  Esta herramienta llamó particularmente la atención en el momento del estudio de implementaciones del enfoque de depuración omnisciente, debido a que era la única herramienta que en su definición ofrecía una estructura de base de datos que permitía almacenar por completo la huella de ejecución de una sesión de depuración sobre una arquitectura escalable, solucionando el principal problema que se le atribuyen a estos tipos de depuradores.

Al analizar las posibles contribuciones o mejoras que se pudieran realizar en TOD, se encontró un punto de principal interés.  TOD al ser un depurador para el lenguaje de programación Java, sólo realizaba depuración a un lenguaje de programación que es de tipado dinámico.  Esto por si solo dejó muchas interrogantes abiertas \textit{¿Cómo se comportaría TOD al realizar depuración a un lenguaje dinámico?}, \textit{¿Qué cambios habría que realizar en TOD para dar soporte a este tipo de lenguajes?}, \textit{¿Se pueden reutilizar algunos componentes de TOD para este objetivo?}, \textit{¿Cómo comunicar los componentes de TOD con la nueva arquitectura de depuración?}, entre otras.

A partir de todas estas interrogantes es que se tomó a TOD como base de estudio y plataforma de desarrollo para la construcción de pyTOD, un prototipo experimental para realizar depuración omnisciente a scripts escritos en el lenguaje de programación Python, lenguaje de tipado dinámico.


En la etapa de diseño del prototipo se consideró necesario que pyTOD estuviera compuesto por los siguientes elementos:

\begin{itemize}
	\item Capturador de huella.
	\item Protocolo de comunicación.
	\item Mecanismo de conexión a nivel de base de datos.
\end{itemize}

Una vez implementados estos elementos y realizando pequeñas modificaciones en algunos de los componentes de TOD, se pudo efectuar una sesión de depuración omnisciente a scripts escritos en un lenguaje de programación de tipado dinámico, logrando alcanzar con esto el objetivo general del presente trabajo de título.

Es importante señalar que además de demostrar que se pudo realizar depuración omnisciente a scripts escritos en un lenguaje de tipado dinámico utilizando como plataforma tecnológica a TOD, también permitió lo siguiente:

\begin{itemize}
	\item Notar que el diseño de base de datos de TOD no requirió de mayores modificaciones.
	\item Hacer más general el mecanismo de conexión a la base de datos de TOD.
	\item Demostrar que TOD es fácilmente extensible para realizar depuración omnisciente a otros lenguajes de programación.
	\item Ampliar el público objetivo de TOD, ya que ahora realiza depuración a más de un lenguaje de programación.
\end{itemize}

Al finalizar este trabajo de titulo se tiene la satisfacción de haber realizado una pequeña y real contribución en el área de la depuración, específicamente en la depuración omnisciente.  De la misma forma se está muy satisfecho de haber planteado y de haber dado solución a la situación de utilizar TOD como plataforma tecnológica para realizar depuración a scripts de lenguajes de tipado dinámico.

\chapter{Trabajo futuro}

Siendo pyTOD un prototipo experimental, su desempeño y prestaciones pueden ser mejoradas ampliamente, esto si se desea utilizarlo de forma real en la depuración de código.  

Principalmente lo que se puede optimizar bastante es el capturador de huella, ya que no se utilizó el enfoque clásico de instrumentación de código si no que se utilizó la captura de la huella de ejecución mediante un mecanismo propio del lenguaje de programación.  Cuando se habla de optimización no se refiere sólo a mejorar los tiempos de ejecución sino que también (a) Poder capturar objetos nativos de Python como son las tuplas, diccionarios, listas entre otras y capturar las llamadas a sus métodos internos (b) Implementar un sistema de identificadores únicos el cual sea aplicado a todos los objetos dentro del capturador de huella.  

Es importante además mejorar la adaptabilidad en los diferentes sistemas operativos, como también mejorar el soporte para depuración de múltiples hilos de ejecución. 

\newpage


\begin{thebibliography}{30}

\bibitem[1]{cost} A study of the effect of  imperfect debugging on software development cost.\\
John Shafer, Rakesh Agrawal, Manish Mehta, 1996.

\bibitem[2]{tod} TOD, a scalable Omniscient Debugger\\
Guillaume Pothier, Eric Tanter, Jose Piquer, 2007.

\bibitem[3]{ieee} IEEE Std, IEEE Software Engineering Standard: Glossary of Software Engineering Terminology.\\
IEEE Computer Society Press, 1993

\bibitem[4]{thePracticeOfProgramming} The Practice Of Programming, Addison-Wesley, Inc.\\
Brian W. Kernighan, Rob Pike, 1999. 

\bibitem[5]{log4j}\href{http://logging.apache.org/log4j/1.2/manual.html}{http://logging.apache.org/log4j/1.2/manual.html}

\bibitem[6]{django-logging}\href{http://www.djangoproject.com/}{http://www.djangoproject.com/}

\bibitem[7]{odb} Bil Lewis. Debugging backwards in time. In M. Ronsse and K. De Bosschere,
editors, Proceedings of the Fifth International Workshop on Automated Debugging
(AADEBUG 2003), Ghent, Belgium, 2003.

\bibitem[8]{EricRaymond} The New Hacker's Dictionary,  Third Edition. Eric. S.Raymond. \\
The MIT Press. 1996 (1993). ISBN: 0262680920. Inglés.

\bibitem[9]{EvansDarlay} Evans, Thomas G., and D. Lucille Darlay, On-Line Debugging Techniques: A survey\\
AFIPS Conference Proceedings (1966 FJCC), Vol. 29, Spartan Books, Washington, D.C., 1966, pp.37-50

\bibitem[10]{ducasse} M. Ducassé. Opium: An Extendable trace analyser for Prolog.\\
The Journal of Logic programming, 39:177-223, 1999. Special issue on Synthesis, Transformation and Analysis of Logic Programs, A. Bossi and Y. Deville (eds).

\bibitem[11]{eclipse} Jim des Rivieres and John Wiegand. Eclipse: A platform for integrating development tools.\\
IBM Systems Journal, 43(2):371–383, 2004.

\bibitem[12]{bitd}Christoph Hofer, Marcus Denker, and Stéphane Ducasse. Implementing a backward-in-time debugger. \\
In Proceedings of NODe’06, volume P-88, pages 17–32. Lecture Notes in Informatics, 2006.

\bibitem[13]{zstep}Henry Lieberman and Christoper Fry. ZStep 95: A reversible, animated source code stepper. \\
In John Stasko, John Domingue, Marc H. Brown, and Blaine A. Price, editors, Software Visualization — Programming as a Multimedia Experience, pages 277–292, Cambridge, MA-London, 1998. The MIT Press.

\bibitem[14]{rtmdt}Charles R. Hill. A real-time microprocessor debugging technique. \\
In SIGSOFT ’83: Proceedings of the symposium on High-level debugging, pages 145–148, New York, NY, USA, 1983. ACM Press.

\bibitem[15]{rooi}Henry Lieberman. Reversible object-oriented interpreters. \\
In Jean Bézivin, Jean-Marie Hullot, Pierre Cointe, and Henry Lieberman, editors, ECOOP, volume 276 of Lecture Notes in Computer Science, pages 11–19. Springer, 1987.

\bibitem[16]{asm} Éric Bruneton, Romain Lenglet, and Thierry Coupaye. ASM: a code manipulation tool to implement adaptable systems. \\
In Proceedings of the ASF (ACM SIGOPS France) Journées Composants 2002: Adaptable and extensible component systems, November 2002.

\bibitem[17]{mural} Dean F. Jerding and John T. Stasko. The information mural: A technique for displaying and navigating large information spaces.\\
IEEE Trans. Vis. Comput. Graph., 4(3):257–271, 1998.

\bibitem[18]{cots} Guillaume Pothier. Benchmarks of COTS database management systems. \\
Technical Report TR/DCC-2006-16, University of Chile, October 2006.

\bibitem[19]{sard}M. Blasgen and K. Eswaran. Storage and access in relational databases. \\
IBM Systems Journal, 16(4):363, 1977.

\bibitem[20]{settrace}\href{http://docs.python.org/lib/debugger-hooks.html}{http://docs.python.org/lib/debugger-hooks.html}

\bibitem[21]{bytecode}\href{http://docs.python.org/lib/bytecodes.html}{http://docs.python.org/lib/bytecodes.html}

\bibitem[22]{setattr}\href{http://docs.python.org/ref/attribute-access.html}{http://docs.python.org/ref/attribute-access.html}

\bibitem[23]{lnotab}\href{http://docs.python.org/ref/types.html\#l2h-143}{http://docs.python.org/ref/types.html\#l2h-143}

\bibitem[24]{xdrlib}\href{http://docs.python.org/lib/module-xdrlib.html}{http://docs.python.org/lib/module-xdrlib.html}

\bibitem[25]{xdrlibestandar}\href{http://www.faqs.org/rfcs/rfc1832.html}{http://www.faqs.org/rfcs/rfc1832.html}

\bibitem[26]{code}\href{http://docs.python.org/ref/types.html#l2h-142}{http://docs.python.org/ref/types.html\#l2h-142}

%\bibitem[Cost, 1996]{cost} A study of the effect of  imperfect debugging on software development cost.\\
%John Shafer, Rakesh Agrawal, Manish Mehta, 1996.

%\bibitem[TOD, 2007]{tod} TOD, a scalable Omniscient Debugger\\
%Guillaume Pothier, Eric Tanter, Jose Piquer, 2007.

%\bibitem[ODB, 2003]{odb} Bil Lewis. Debugging backwards in time. In M. Ronsse and K. De Bosschere,
%editors, Proceedings of the Fifth International Workshop on Automated Debugging
%(AADEBUG 2003), Ghent, Belgium, 2003.

%\bibitem[IEEE, 1993]{ieee} IEEE Std, IEEE Software Engineering Standard: Glossary of Software Engineering Terminology.\\
%IEEE Computer Society Press, 1993

%\bibitem[La Practica de la programación,1999]{thePracticeOfProgramming} thePracticeOfProgramming, Addison-Wesley, Inc.\\
%Brian W. Kernighan, Rob Pike, 1999. 

%\bibitem[Log4j, 2002]{log4j}\href{http://logging.apache.org/log4j/1.2/manual.html}{http://logging.apache.org/log4j/1.2/manual.html}

%\bibitem[django-logging, 2005]{django-logging}\href{http://www.djangoproject.com/}{http://www.djangoproject.com/}

%\bibitem[wikipedia, 2008]{lp}\href{http://es.wikipedia.org/wiki/Lenguaje_de_programación}{http://es.wikipedia.org/wiki/Lenguaje\_de\_programación}

%\bibitem[25]{lp}\href{http://es.wikipedia.org/wiki/Lenguaje_de_programación}{http://es.wikipedia.org/wiki/Lenguaje\_de\_programación}

%\bibitem[settrace, 2008]{settrace}\href{http://docs.python.org/lib/debugger-hooks.html}{http://docs.python.org/lib/debugger-hooks.html}

%\bibitem[Byte Code, 2008]{bytecode}\href{http://docs.python.org/lib/bytecodes.html}{http://docs.python.org/lib/bytecodes.html}

%\bibitem[setattr, 2008]{setattr}\href{http://docs.python.org/ref/attribute-access.html}{http://docs.python.org/ref/attribute-access.html}

%\bibitem[lnotab, 2008]{lnotab}\href{http://docs.python.org/ref/types.html\#l2h-143}{http://docs.python.org/ref/types.html\#l2h-143}

%\bibitem[XDRlib, 2008]{xdrlib}\href{http://docs.python.org/lib/module-xdrlib.html}{http://docs.python.org/lib/module-xdrlib.html}

%\bibitem[XDRlib, 1995]{xdrlibestandar}\href{http://docs.python.org/lib/module-xdrlib.html}{http://docs.python.org/lib/module-xdrlib.html}

%\bibitem[Ducassé, 1999]{ducasse} M. Ducassé. Opium: An Extendable trace analyser for Prolog.\\
%The Journal of Logic programming, 39:177-223, 1999. Special issue on Synthesis, Transformation and Analysis of Logic Programs, A. Bossi and Y. Deville (eds).

%\bibitem[]{bitd}Christoph Hofer, Marcus Denker, and Stéphane Ducasse. Implementing a backward-in-time debugger. \\
%In Proceedings of NODe’06, volume P-88, pages 17–32. Lecture Notes in Informatics, 2006.
\end{thebibliography}

\appendix
\appendixpage
\addappheadtotoc
\pagebreak
\chapter{Código fuente de pyTOD}

	\section{Código fuente de hunterTrace.py}
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = "Milton Inostroza Aguilera"
__email__ = "minoztro@gmail.com"
__all__ = ['hT']
th = True
import sys
import dis
import re
import types
import time
import thread
import xdrlib
import socket
import inspect
from constantsObjects import events, objects, dataTypes, packXDRLib
from generatorId import generatorId
from objectClass import Class
from objectMethod import Method
from objectFunction import Function
if th:
    from threading import settrace   

class hunterTrace(object):

    def __init__(self, aHost, aPort):
        self.itsClass = {}
        self.itsFunction = {}
        self.itsMethod = {}
        self.itsProbe = {}
        self.itsThread = {}
        self.itsSocket = None
        self.itsEvents = events
        self.itsObjects = objects
        self.itsDataTypes = dataTypes
        self.itsPackXDR = packXDRLib
        self.itsId = generatorId()
        self.itsProbeId = generatorId()
        self.itsThreadId = generatorId()
        self.itsPacker = xdrlib.Packer()
        self.itsHost = aHost
        self.itsPort = aPort
        self.FLAG_DEBUGG = False
        self.FLAG_THROWN = False
        self.itsMethodPattern = "\A__.*(__)$"
        #trick for MetaDescriptor's depth
        self.itsCurrentDepth = 0
        #trick for Objects {strings, tuple, dict, list}
        self.itsRegisterObjects = []
        self.__socketConnect__()

    def __addClass__(self, aId, aLnotab, aCode):
        objectClass = Class(self,aId,aCode,aLnotab)
        self.itsClass.update({aCode:objectClass})
        return objectClass

    def __addFunction__(self, aId, aLnotab, aCode, aArgs):
        self.itsFunction.update({aCode:Function(self,aId,aCode,aLnotab,aArgs)})

    def __addMethod__(self, aId, aLnotab, aCode, idClass, aArgs):
        self.itsMethod.update({aCode:Method(self,aId,aCode,aLnotab,idClass,aArgs)})

    def __addProbe__(self, aProbeId, currentLasti, parentId):
        self.itsProbe.update({(currentLasti,parentId):aProbeId})

    def __addThread__(self, aThreadId, aThreadSysId):
        self.itsThread.update({aThreadSysId:aThreadId})
                
    def __behaviorExit__(self,
                         aFrame,
                         aArg,
                         aDepth,
                         aParentTimestampFrame,
                         aThreadId,
                         aHasThrown):
        theBackFrame = aFrame.f_back
        theBackFrameCode = theBackFrame.f_code
        theParentId = self.__getObjectId__(theBackFrameCode)
        behaviorId = self.__getObjectId__(aFrame.f_code)
        theCurrentLasti = aFrame.f_lasti
        theDepth = aDepth + 1
        if not self.itsProbe.has_key((theCurrentLasti,theParentId)):
            theProbeId = self.__registerProbe__(theCurrentLasti,
                                                theParentId,
                                                aFrame.f_lineno)
        else:
            theProbeId = self.itsProbe[(theCurrentLasti,theParentId)]
        theCurrentTimestamp = self.__convertTimestamp__(time.time())
        if aHasThrown:                  
            self.__registerObject__(aArg,theCurrentTimestamp)
            self.itsPacker.reset()
            self.itsPacker.pack_int(self.itsEvents['return'])
            self.itsPacker.pack_int(behaviorId)
            theDataType = self.__getDataType__(aArg)
            self.itsPacker.pack_int(theDataType)
            self.itsPacker.pack_int(id(aArg))
            self.itsPacker.pack_int(1) #True
            self.itsPacker.pack_int(theProbeId)
            self.itsPacker.pack_hyper(aParentTimestampFrame)        
            self.itsPacker.pack_int(theDepth)
            self.itsPacker.pack_hyper(theCurrentTimestamp)
            self.itsPacker.pack_int(aThreadId)
        else:
            theDataType = self.__getDataType__(aArg)
            if theDataType == 1:
                if not id(aArg) in self.itsObjects:
                    self.__registerObject__(aArg,theCurrentTimestamp)
            self.itsPacker.reset()
            self.itsPacker.pack_int(self.itsEvents['return'])
            self.itsPacker.pack_int(behaviorId)
            self.itsPacker.pack_int(theDataType)
            if theDataType == 1:
                thePackValue = id(aArg)
                self.itsPacker.pack_int(id(aArg))
            else:
                thePackValue = self.__packValue__(theDataType, aArg)            
            self.itsPacker.pack_int(0) #False
            self.itsPacker.pack_int(theProbeId)
            self.itsPacker.pack_hyper(aParentTimestampFrame)        
            self.itsPacker.pack_int(theDepth)
            self.itsPacker.pack_hyper(theCurrentTimestamp)
            self.itsPacker.pack_int(aThreadId)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
        
    def __createlnotab__(self, aCode):
        theLnotab = {}
        if hasattr(aCode, 'co_lnotab'):
            table = aCode.co_lnotab
            index = 0
            last_index = None
            for i in range(0, len(table), 2):
                index = index + ord(table[i])
                if last_index == None:
                    last_index = index
                else:
                    theLnotab.update({index:tuple([last_index,index-1])})                
                    last_index = index
            theLnotab.update({len(aCode.co_code)-1:tuple([last_index,len(aCode.co_code)-1])})                
        return theLnotab        

    def __convertTimestamp__(self,aTimestamp):
        return long(aTimestamp*1000000000)

    def __depthFrame__(self, aFrame):
        theBackFrame = aFrame.f_back
        if theBackFrame.f_locals.has_key('__depth__'):
            theCurrentDepth = theBackFrame.f_locals['__depth__']
            aFrame.f_locals['__depth__'] = theCurrentDepth + 1
        else:
            aFrame.f_locals['__depth__'] = 1
        return aFrame.f_locals['__depth__']
    
    def __functionCall__(self, 
                         aCode, 
                         aFrame,
                         aDepth,
                         aCurrentTimestamp,
                         aParentTimestampFrame,
                         aThreadId):
        theObject = self.__getObject__(aCode)
        theFunctionId = theObject.__getId__()
        theArgsValue = theObject.__getArgsValues__(aFrame.f_locals)
        theBackFrame = aFrame.f_back
        theBackFrameLasti = theBackFrame.f_lasti
        theBackFrameCode = theBackFrame.f_code
        theParentId = self.__getObjectId__(theBackFrameCode)
        theCurrentLasti = aFrame.f_lasti
        if not self.itsProbe.has_key((theCurrentLasti,theParentId)):
            theProbeId = self.__registerProbe__(theCurrentLasti,
                                                theParentId,
                                                aFrame.f_lineno)
        else:
            theProbeId = self.itsProbe[(theCurrentLasti,theParentId)]
        for theValue in theArgsValue:
            if type(theValue) == types.StringType:
                if not id(theValue) in hT.itsRegisterObjects:
                    self.__registerObject__(theValue, aCurrentTimestamp)             
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['call'])
        self.itsPacker.pack_int(self.itsObjects['function'])
        self.itsPacker.pack_int(theFunctionId)
        self.itsPacker.pack_int(len(theArgsValue))
        thePrintArg = " "
        for theValue in theArgsValue:
            theDataType = self.__getDataType__(theValue)
            self.itsPacker.pack_int(theDataType)
            thePrintArg += str(theDataType)
            thePrintArg += " "
            if theDataType == 1:
                self.itsPacker.pack_hyper(id(theValue))
                thePrintArg += str(id(theValue))
                thePrintArg += " "
            else:
                thePrintArg += str(self.__packValue__(theDataType, theValue))
                thePrintArg += " "            
        self.itsPacker.pack_int(theProbeId)
        self.itsPacker.pack_hyper(aParentTimestampFrame)        
        self.itsPacker.pack_int(aDepth)
        self.itsPacker.pack_hyper(aCurrentTimestamp)
        self.itsPacker.pack_int(aThreadId)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass        
            
    def __getArgs__(self, aCode):
        return aCode.co_varnames[:aCode.co_argcount]

    def __getClassKey__(self, aNameClass):
        for theKey, theValue in self.itsClass.iteritems():
            if theKey.co_name == aNameClass:
                return theKey
        return None
    
    def __getObjectId__(self, aCode):
        if self.__isClassKey__(aCode):
            return self.itsClass[aCode].__getId__()
        elif self.__isFunctionKey__(aCode):
            return self.itsFunction[aCode].__getId__()
        elif self.__isMethodKey__(aCode):
            return self.itsMethod[aCode].__getId__()
        return -1

    def __getObject__(self, aCode):
        if self.__isFunctionKey__(aCode):
            return self.itsFunction[aCode]
        elif self.__isMethodKey__(aCode):
            return self.itsMethod[aCode]
        return None

    def __getThreadId__(self, aThreadSysId):
        if not hT.itsThread.has_key(aThreadSysId):
            theThreadId = self.__registerThread__(aThreadSysId)
        else:
            theThreadId = self.itsThread[aThreadSysId]
        return theThreadId

    def __getpartcode__(self, aCode, aLimits):
        theLower = aLimits[0]
        theUpper = aLimits[1]
        theCode = aCode.co_code
        theStoreFast = {}    
        while theLower < theUpper:
            theOp = ord(theCode[theLower])
            theNameOp = dis.opname[theOp]
            theLower = theLower + 1
            if theOp >= dis.HAVE_ARGUMENT:
                theValue = ord(theCode[theLower]) + ord(theCode[theLower+1])*256
                theLower = theLower + 2
                if theOp in dis.haslocal and theNameOp == 'STORE_FAST':
                    theArgumentValue = aCode.co_varnames[theValue]
                    theStoreFast.update({theArgumentValue:theValue})
        return theStoreFast

    def __getDepthFrame__(self, aFrame):
        try:
            return aFrame.f_locals['__depth__']
        except:
            return -1
    
    def __getDataType__(self, aValue):
        theDataType = 8
        try:
            if self.itsDataTypes.has_key(aValue.__class__.__name__):
                theDataType = self.itsDataTypes[aValue.__class__.__name__]
        except:
            return theDataType
        finally:
            return theDataType

    def __getTimestampFrame__(self, aFrame):
        if aFrame.f_locals.has_key('__timestampFrame__'):
            return aFrame.f_locals['__timestampFrame__']
        return 0

    def __getTimestampParentFrame__(self, aFrame):
        theBackFrame = aFrame.f_back 
        if theBackFrame.f_locals.has_key('__timestampFrame__'):
            return theBackFrame.f_locals['__timestampFrame__']
        return 0

    def __inClass__(self, aClass):
        if self.itsClass.has_key(aClass):
            return True
        return False

    def __inFunction__(self, aFunction):
        if self.itsFunction.has_key(aFunction):
            return True
        return False

    def __inMethod__(self, aMethod):
        if self.itsMethod.has_key(aMethod):
            return True
        return False

    def __isClassKey__(self, aClassCode):
        for theKey in self.itsClass.iterkeys():
            if theKey == aClassCode:
                return self.itsClass[theKey]
        return None

    def __isFunctionKey__(self, aFunctionCode):
        for theKey in self.itsFunction.iterkeys():
            if theKey == aFunctionCode:
                return self.itsFunction[theKey]
        return None

    def __isMethodKey__(self, aMethodCode):
        for theKey in self.itsMethod.iterkeys():
            if theKey == aMethodCode:
                return self.itsMethod[theKey]
        return None

    def __instantiation__(self, 
                          aCode, 
                          aFrame, 
                          aInstantiationId, 
                          aDepth, 
                          aCurrentTimestamp, 
                          aParentTimestampFrame, 
                          aThreadId):
        theBehavior = self.__getObject__(aCode)
        theBehaviorId = theBehavior.__getId__()
        theClassId = theBehavior.__getTarget__()
        theArgsValue = theBehavior.__getArgsValues__(aFrame.f_locals)
        theBackFrame = aFrame.f_back
        theFrameLasti = theBackFrame.f_lasti
        theBackFrameCode = theBackFrame.f_code
        theParentId = self.__getObjectId__(theBackFrameCode)
        theCurrentLasti = aFrame.f_lasti        
        if not self.itsProbe.has_key((theCurrentLasti,theParentId)):
            theProbeId = self.__registerProbe__(theCurrentLasti,
                                                theParentId,
                                                aFrame.f_lineno)
        else:
            theProbeId = self.itsProbe[(theCurrentLasti,theParentId)]
        for theValue in theArgsValue:
            if type(theValue) == types.StringType:
                if not id(theValue) in hT.itsRegisterObjects:
                    self.__registerObject__(theValue, aCurrentTimestamp)
        self.itsPacker.reset()       
        self.itsPacker.pack_int(self.itsEvents['instantiation'])
        self.itsPacker.pack_int(theBehaviorId)
        self.itsPacker.pack_int(aInstantiationId)
        self.itsPacker.pack_int(len(theArgsValue))
        thePrintArg = " "
        for theValue in theArgsValue:
            theDataType = self.__getDataType__(theValue)               
            self.itsPacker.pack_int(theDataType)
            thePrintArg += str(theDataType)
            thePrintArg += " "
            if theDataType == 1:
                self.itsPacker.pack_hyper(id(theValue))
                thePrintArg += str(id(theValue))
                thePrintArg += " "
            else:
                thePrintArg += str(self.__packValue__(theDataType, theValue))
                thePrintArg += " "
        self.itsPacker.pack_int(theProbeId)
        self.itsPacker.pack_hyper(aParentTimestampFrame)
        self.itsPacker.pack_int(aDepth)    
        self.itsPacker.pack_hyper(aCurrentTimestamp)
        self.itsPacker.pack_int(aThreadId)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
    
    def __localWrite__(self,
                       aCode,
                       aBytecodeLocal,
                       aLocals,
                       aObject,
                       aCurrentLasti,
                       aCurrentLineno,
                       aDepth,
                       aParentTimestampFrame, 
                       aThreadId):
        theLocalVariables = aObject.__getLocals__()
        print theLocalVariables
        theBehaviorId = self.__getObjectId__(aCode)
        theDepth = aDepth + 1
        for theValue in aBytecodeLocal.iterkeys():
            if not theLocalVariables.has_key(theValue) or \
               not aLocals.has_key(theValue):
                return
            if not self.itsProbe.has_key((aCurrentLasti,theBehaviorId)):
                theProbeId = self.__registerProbe__(aCurrentLasti,
                                                    theBehaviorId,
                                                    aCurrentLineno)
            else:
                theProbeId = self.itsProbe[(aCurrentLasti,theBehaviorId)]
            theCurrentTimestamp = self.__convertTimestamp__(time.time())
            if type(aLocals[theValue]) == types.StringType:
                if not id(aLocals[theValue]) in hT.itsRegisterObjects:
                    hT.__registerObject__(aLocals[theValue], theCurrentTimestamp)
                    self.itsPacker.reset()
                    self.itsPacker.pack_int(self.itsEvents['set'])
                    self.itsPacker.pack_int(self.itsObjects['local'])
                    self.itsPacker.pack_int(theLocalVariables[theValue])
                    self.itsPacker.pack_int(theBehaviorId)
                    theDataType = self.__getDataType__(aLocals[theValue])
                    self.itsPacker.pack_int(theDataType)
                    self.itsPacker.pack_hyper(id(aLocals[theValue]))
                    self.itsPacker.pack_int(theProbeId)
                    self.itsPacker.pack_hyper(aParentTimestampFrame)
                    self.itsPacker.pack_int(theDepth) 
                    self.itsPacker.pack_hyper(theCurrentTimestamp)
                    self.itsPacker.pack_int(aThreadId)
                    try:
                        self.itsSocket.sendall(self.itsPacker.get_buffer())
                    except:
                        pass                   
            else:    
                self.itsPacker.reset()
                self.itsPacker.pack_int(self.itsEvents['set'])
                self.itsPacker.pack_int(self.itsObjects['local'])
                self.itsPacker.pack_int(theLocalVariables[theValue])
                self.itsPacker.pack_int(theBehaviorId)
                theDataType = self.__getDataType__(aLocals[theValue])
                self.itsPacker.pack_int(theDataType)
                thePackValue = self.__packValue__(theDataType, aLocals[theValue])
                self.itsPacker.pack_int(theProbeId)
                self.itsPacker.pack_hyper(aParentTimestampFrame)
                self.itsPacker.pack_int(theDepth) 
                self.itsPacker.pack_hyper(theCurrentTimestamp)
                self.itsPacker.pack_int(aThreadId)
                try:
                    self.itsSocket.sendall(self.itsPacker.get_buffer())
                except:
                    pass            
    
    def __markTimestampFrame__(self, aFrame):
        if not aFrame.f_locals.has_key('__timestampFrame__'): 
            aFrame.f_locals['__timestampFrame__'] = self.__convertTimestamp__(time.time())
        return

    def __methodCall__(self,
                       aCode,
                       aFrame, 
                       aTargetId,
                       aDepth,
                       aCurrentTimestamp,
                       aParentTimestampFrame,
                       aThreadId):
        theObject = self.__getObject__(aCode)
        theMethodId = theObject.__getId__()
        theArgsValue = theObject.__getArgsValues__(aFrame.f_locals)
        theBackFrame = aFrame.f_back
        theBackFrameLasti = theBackFrame.f_lasti
        theBackFrameCode = theBackFrame.f_code
        theParentId = self.__getObjectId__(theBackFrameCode)
        theCurrentLasti = aFrame.f_lasti        
        if not self.itsProbe.has_key((theCurrentLasti,theParentId)):
            theProbeId = self.__registerProbe__(theCurrentLasti, theParentId, aFrame.f_lineno)
        else:
            theProbeId = self.itsProbe[(theCurrentLasti,theParentId)]
        for theValue in theArgsValue:
            if type(theValue) == types.StringType:
                if not id(theValue) in hT.itsRegisterObjects:
                    self.__registerObject__(theValue, aCurrentTimestamp)            
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['call'])
        self.itsPacker.pack_int(self.itsObjects['method'])
        self.itsPacker.pack_int(theMethodId)
        self.itsPacker.pack_int(aTargetId)
        self.itsPacker.pack_int(len(theArgsValue))
        thePrintArg = " "
        for theValue in theArgsValue:
            theDataType = self.__getDataType__(theValue)
            self.itsPacker.pack_int(theDataType)
            thePrintArg += str(theDataType)
            thePrintArg += " "
            if theDataType == 1:
                self.itsPacker.pack_hyper(id(theValue))
                thePrintArg += str(id(theValue))
                thePrintArg += " "
            else:
                thePrintArg += str(self.__packValue__(theDataType, theValue))
                thePrintArg += " "
        self.itsPacker.pack_int(theProbeId)
        self.itsPacker.pack_hyper(aParentTimestampFrame)
        self.itsPacker.pack_int(aDepth)    
        self.itsPacker.pack_hyper(aCurrentTimestamp)
        self.itsPacker.pack_int(aThreadId)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
    
    
    def __packValue__(self, aDataType, aValue):
        if self.itsPackXDR.has_key(aDataType):
            theMethodName = self.itsPackXDR[aDataType]
            if aDataType == 4:
                if aValue:
                    aValue = 1
                else:
                    aValue = 0
            if aDataType == 1:
                 self.itsPacker.pack_hyper(id(aValue))
                 return id(aValue)
            getattr(self.itsPacker,'pack_\%s'\%theMethodName)(aValue)
            return aValue            
        else:
            self.itsPacker.pack_int(aDataType)
            return aDataType

    def __printHunter__(self):
        self.itsSocket.close()
        print
        print 'clases'
        for theKey, theValue in hT.itsClass.iteritems():
            print theValue.__dict__
            print
        print '======='
        
        print 'metodos'
        for theKey, theValue in hT.itsMethod.iteritems():
            print v.__dict__
            print
        print '======='
        
        print 'funcion'
        for theKey, theValue in hT.itsFunction.iteritems():
            print theValue.__dict__
            print
        print '======='
        
    def __socketConnect__(self):
        self.itsSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        try:
            self.itsSocket.connect((self.itsHost, self.itsPort))
        except:
            pass
    
    def __register__(self, aObject, aLocals):
        aObject.__registerLocals__(aLocals)

    def __registerClass__(self, aCode, aLocals, aParentTimestamp, aDepth, aFrameLineNo):
        theClassId = self.itsId.__get__()
        theClassName = aCode.co_name
        theClassBases = None
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['class'])
        self.itsPacker.pack_int(theClassId)
        self.itsPacker.pack_string(theClassName)
        self.itsPacker.pack_int(0)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
        theObjectClass = self.__addClass__(
                                           theClassId,
                                           self.__createlnotab__(aCode),
                                           aCode)
        self.itsId.__next__()
        theObjectClass.__addMethod__(aCode,aLocals)
        theObjectClass.__register_set_StaticField__(aLocals,
                                                    aFrameLineNo,
                                                    aParentTimestamp,
                                                    aDepth,
                                                    aCode.co_filename)

    def __registerException__(self,
                              aFrame,
                              aArg,
                              aDepth,
                              aParentTimestampFrame,
                              aThreadId):
        theBackFrame = aFrame.f_back
        theBackFrameCode = theBackFrame.f_code
        theParentId = self.__getObjectId__(theBackFrameCode)
        theCurrentLasti = aFrame.f_lasti
        theDepth = aDepth + 1
        if not self.itsProbe.has_key((theCurrentLasti,theParentId)):
            theProbeId = self.__registerProbe__(theCurrentLasti,
                                                theParentId,
                                                aFrame.f_lineno)
        else:
            theProbeId = self.itsProbe[(theCurrentLasti,theParentId)]
        theCurrentTimestamp = self.__convertTimestamp__(time.time())       
        if not id(aArg) in self.itsObjects:
            self.__registerObject__(aArg,theCurrentTimestamp)            
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['exception'])       
        theDataType = self.__getDataType__(aArg)
        self.itsPacker.pack_int(theDataType)
        self.itsPacker.pack_hyper(id(aArg))
        self.itsPacker.pack_int(theProbeId)
        self.itsPacker.pack_hyper(aParentTimestampFrame)        
        self.itsPacker.pack_int(theDepth)
        self.itsPacker.pack_hyper(theCurrentTimestamp)
        self.itsPacker.pack_int(aThreadId)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass

    def __registerFunction__(self, aCode):
        theFunctionId = self.itsId.__get__()
        aArgs = self.__getArgs__(aCode)
        theLineNumbers = 0
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['function'])
        self.itsPacker.pack_int(theFunctionId)
        self.itsPacker.pack_string(aCode.co_name)
        self.itsPacker.pack_int(len(aArgs))
        thePrintArg = " " 
        for theValue in range(len(aArgs)):
            if not aArgs[theValue] == 'self':
                thePrintArg += str(aArgs[theValue])
                thePrintArg += " "
                self.itsPacker.pack_string(aArgs[theValue])
                thePrintArg += str(theValue)
                thePrintArg += " "
                self.itsPacker.pack_int(theValue)
        self.itsPacker.pack_string(aCode.co_filename)
        for theTuple in dis.findlinestarts(aCode):
            theLineNumbers += 1
        self.itsPacker.pack_int(len(aCode.co_code))        
        self.itsPacker.pack_int(theLineNumbers)
        thePrintLines = " "
        for theStartPc, theLineNumber in dis.findlinestarts(aCode):
            thePrintArg += str(theStartPc)
            thePrintArg += " "            
            self.itsPacker.pack_int(theStartPc)
            thePrintArg += str(theLineNumber)
            thePrintArg += " "            
            self.itsPacker.pack_int(theLineNumber)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass       
        self.__addFunction__(
                             theFunctionId,
                             self.__createlnotab__(aCode),
                             aCode,
                             aArgs)
        self.itsId.__next__()


    def __registerMethod__(self, aCode, aMethodId, aClassId, aArgs):
        theLineNumbers = 0
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['method'])
        self.itsPacker.pack_int(aMethodId)
        self.itsPacker.pack_int(aClassId)
        self.itsPacker.pack_string(aCode.co_name)
        self.itsPacker.pack_int(len(aArgs)-1)
        thePrintArg = " "
        for theValue in range(len(aArgs)):
            if not aArgs[theValue] == 'self':
                thePrintArg += str(aArgs[theValue])
                thePrintArg += " "
                self.itsPacker.pack_string(aArgs[theValue])
                thePrintArg += str(theValue)
                thePrintArg += " "
                self.itsPacker.pack_int(theValue)
        self.itsPacker.pack_string(aCode.co_filename)
        for theTuple in dis.findlinestarts(aCode):
            theLineNumbers += 1
        self.itsPacker.pack_int(len(aCode.co_code))        
        self.itsPacker.pack_int(theLineNumbers)
        thePrintLines = " "
        for theStartPc, theLineNumber in dis.findlinestarts(aCode):
            thePrintArg += str(theStartPc)
            thePrintArg += " "            
            self.itsPacker.pack_int(theStartPc)
            thePrintArg += str(theLineNumber)
            thePrintArg += " "            
            self.itsPacker.pack_int(theLineNumber)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
        self.__addMethod__(
                           aMethodId,
                           self.__createlnotab__(aCode),
                           aCode,
                           aClassId,
                           aArgs)
        
        
    def __registerSpecialMethod__(self, aName, aMethodId, aClassId, aFileName):
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['specialMethod'])
        self.itsPacker.pack_int(aMethodId)
        self.itsPacker.pack_int(aClassId)
        self.itsPacker.pack_string(aName)
        self.itsPacker.pack_string(aFileName)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
        
    def __registerObject__(self, aValue, aCurrentTimestamp):
        self.itsRegisterObjects.append(id(aValue))
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['object'])
        self.itsPacker.pack_int(1) #string
        self.itsPacker.pack_hyper(id(aValue))
        self.itsPacker.pack_string(aValue)
        self.itsPacker.pack_hyper(aCurrentTimestamp)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
    
    def __registerProbe__(self, aCurrentLasti, aBehaviorId, aCurrentLineno):
        theProbeId = self.itsProbeId.__get__()
        self.__addProbe__(theProbeId,aCurrentLasti,aBehaviorId)
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['probe'])
        self.itsPacker.pack_int(theProbeId)
        self.itsPacker.pack_int(aBehaviorId)
        self.itsPacker.pack_int(aCurrentLasti)
        self.itsPacker.pack_int(aCurrentLineno)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
        self.itsProbeId.__next__()
        return theProbeId
    
    def __registerThread__(self, aThreadSysId):
        theThreadId = self.itsThreadId.__get__()
        self.__addThread__(theThreadId,aThreadSysId)
        self.itsPacker.reset()
        self.itsPacker.pack_int(self.itsEvents['register'])
        self.itsPacker.pack_int(self.itsObjects['thread'])
        self.itsPacker.pack_int(theThreadId)
        self.itsPacker.pack_int(aThreadSysId)
        try:
            self.itsSocket.sendall(self.itsPacker.get_buffer())
        except:
            pass
        self.itsThreadId.__next__()
        return theThreadId

    def __trace__(self, aFrame, aEvent, aArg):
        if aFrame.f_back == None:
            sys.settrace(None)
            return
        theCode = aFrame.f_code
        if theCode.co_name == '<module>':
            return
        theLocals = aFrame.f_locals
        theGlobals = aFrame.f_globals
        theDepth = self.itsCurrentDepth = self.__depthFrame__(aFrame)
        self.__markTimestampFrame__(aFrame)
        theThreadId = self.__getThreadId__(thread.get_ident())
        if aEvent == "call":
            if re.search(self.itsMethodPattern,theCode.co_name):
                if not theCode.co_name == '__init__':
                    return
            theParentTimestampFrame = self.__getTimestampParentFrame__(aFrame)
            if theCode.co_name == '__init__':
                if 'self' in theLocals:
                    print type(theLocals['self']).__bases__
            if theLocals.has_key('self'):
                if not self.__inMethod__(theCode):
                    theKey = type(theLocals['self']).__name__
                    theKey = hT.__getClassKey__(theKey)
                    if theKey == None:
                        return
                    if not hT.itsClass.has_key(theKey):
                        return
                    theClassId = hT.itsClass[theKey].__getId__()
                    if not hT.itsClass[theKey].method.has_key(theCode.co_name):
                        return
                    theMethodId = hT.itsClass[theKey].method[theCode.co_name]
                    theArgs = self.__getArgs__(theCode)
                    self.__registerMethod__(theCode,theMethodId,theClassId,theArgs)
                theCurrentTimestamp = aFrame.f_locals['__timestampFrame__']
                if theCode.co_name == '__init__':
                    Id = self.itsId.__get__()
                    if not hasattr(theLocals['self'],'__dict__'):
                        return
                    theLocals['self'].__dict__.update({'__pyTOD__':Id})
                    self.itsId.__next__()
                    self.__instantiation__(theCode,
                                           aFrame,
                                           theLocals['self'].__pyTOD__,
                                           theDepth,
                                           theCurrentTimestamp,
                                           theParentTimestampFrame,
                                           theThreadId)

                else:
                    self.__methodCall__(theCode,
                                        aFrame,
                                        theLocals['self'].__pyTOD__,
                                        theDepth,
                                        theCurrentTimestamp,
                                        theParentTimestampFrame,
                                        theThreadId)
            else:
                #verificamos si es una funcion
                if theGlobals.has_key(theCode.co_name):
                    if inspect.isfunction(theGlobals[theCode.co_name]):
                        if not self.__inFunction__(theCode):
                            self.__registerFunction__(theCode)
                    theCurrentTimestamp = aFrame.f_locals['__timestampFrame__']
                    self.__functionCall__(theCode,
                                          aFrame,
                                          theDepth,
                                          theCurrentTimestamp,
                                          theParentTimestampFrame,
                                          theThreadId)   
            return self.__trace__
        elif aEvent == "line":
            if re.search(self.itsMethodPattern,theCode.co_name):
                if not theCode.co_name == '__init__':
                    return
            theParentTimestampFrame = self.__getTimestampFrame__(aFrame)
            theObject = self.__getObject__(theCode)
            if theObject == None:
                return
            theLnotab = theObject.__getLnotab__()
            if theLnotab.has_key(aFrame.f_lasti):
                theBytecodeLocals = self.__getpartcode__(theCode,theLnotab[aFrame.f_lasti])
                self.__register__(theObject,theBytecodeLocals)
                self.__localWrite__(theCode,
                                    theBytecodeLocals,
                                    theLocals,
                                    theObject,
                                    aFrame.f_lasti,
                                    aFrame.f_lineno,
                                    theDepth,
                                    theParentTimestampFrame,
                                    theThreadId)
            return self.__trace__
        elif aEvent == "return":
            if re.search(self.itsMethodPattern,theCode.co_name):
                if not theCode.co_name == '__init__':
                    return
            theParentTimestampFrame = self.__getTimestampFrame__(aFrame)
            if theLocals.has_key('__init__'):
                if not self.__inClass__(theCode):
                    theLocals.update(
                            {'__setattr__':Descriptor.__dict__['__setattr__']})
                    theLocals.update({'__metaclass__':MetaDescriptor})
                    self.__registerClass__(
                                           theCode,
                                           theLocals,
                                           theParentTimestampFrame,
                                           theDepth,
                                           aFrame.f_lineno)
            else:
                theObject = self.__getObject__(theCode)
                if theObject == None:
                    return
                if self.FLAG_THROWN == True:
                    self.FLAG_THROWN = False
                    return
                theLnotab = theObject.__getLnotab__()
                if theLnotab.has_key(aFrame.f_lasti):
                    theBytecodeLocals = self.__getpartcode__(
                                                    theCode,
                                                    theLnotab[aFrame.f_lasti])
                    self. __register__(theObject,theBytecodeLocals)
                    self.__localWrite__(theCode,
                                        theBytecodeLocals,
                                        theLocals,
                                        theObject,
                                        aFrame.f_lasti,
                                        aFrame.f_lineno,
                                        theDepth,
                                        theParentTimestampFrame,
                                        theThreadId)
                self.__behaviorExit__(aFrame,
                                     aArg,
                                     theDepth,
                                     theParentTimestampFrame,
                                     theThreadId,
                                     False)
        elif aEvent == "exception":
            theParentTimestampFrame = self.__getTimestampFrame__(aFrame)
            if type(aArg[1]) is tuple:
                theArgument = aArg[1][1]
            else:
                theArgument = aArg[1]
            self.__registerException__(aFrame,
                                        theArgument,
                                        theDepth,
                                        theParentTimestampFrame,
                                        theThreadId)
            for theTuple in dis.findlinestarts(theCode):
                if aFrame.f_lineno in theTuple:
                    theIndex = theTuple[0]
            theOp = ord(theCode.co_code[theIndex-3])
            theInstruction = dis.opname[theOp]
            if theInstruction == 'SETUP_EXCEPT':
                return self.__trace__
            self.__behaviorExit__(aFrame,
                                    theArgument,
                                    theDepth,
                                    theParentTimestampFrame,
                                    theThreadId,
                                    True)
            self.FLAG_THROWN = True           

hT = hunterTrace(
                 '127.0.0.1',
                 8058)

class MetaDescriptor(type):
    def __setattr__(self, aName, aValue):
        import sys
        theFrame = sys._getframe()
        theCode = theFrame.f_back.f_code
        theCurrentLasti = theFrame.f_back.f_lasti
        theCurrentDepth = hT.itsCurrentDepth
        theCurrentTimestamp = hT.__convertTimestamp__(time.time())
        theParentTimestamp = hT.__getTimestampParentFrame__(theFrame)
        theThreadId = hT.__getThreadId__(thread.get_ident())
        theKey = self.__name__
        theKey = hT.__getClassKey__(theKey)
        if theKey == None:
            return
        theObject = hT.itsClass[theKey]
        theObjectId = theObject.__getId__()
        theBehaviorId = hT.__getObjectId__(theCode)
        sys.settrace(None)
        theObject.__addStaticField__({aName:-1})
        Id = theObject.staticField[aName]
        if not hT.itsProbe.has_key((theCurrentLasti,theBehaviorId)):
            theProbeId = hT.__registerProbe__(theCurrentLasti,
                                              theBehaviorId,
                                              theFrame.f_lineno)
        else:
            theProbeId = hT.itsProbe[(theCurrentLasti,theBehaviorId)]          
        if type(aValue) == types.StringType:
            if not id(aValue) in hT.itsRegisterObjects:
                hT.__registerObject__(aValue, theCurrentTimestamp)
                hT.itsPacker.reset()
                hT.itsPacker.pack_int(hT.itsEvents['set'])
                hT.itsPacker.pack_int(hT.itsObjects['classAttribute'])
                hT.itsPacker.pack_int(Id)
                theDataType = hT.__getDataType__(aValue)
                hT.itsPacker.pack_int(theDataType)
                hT.itsPacker.pack_hyper(id(aValue))
                hT.itsPacker.pack_int(theProbeId)
                hT.itsPacker.pack_hyper(theParentTimestamp)        
                hT.itsPacker.pack_int(theCurrentDepth)
                hT.itsPacker.pack_hyper(theCurrentTimestamp)
                hT.itsPacker.pack_int(theThreadId)
                super(MetaDescriptor, self).__setattr__(aName, aValue)
                try:
                    hT.itsSocket.sendall(hT.itsPacker.get_buffer())
                except:
                    pass    
                sys.settrace(hT.__trace__)
        else:
            hT.itsPacker.reset()
            hT.itsPacker.pack_int(hT.itsEvents['set'])
            hT.itsPacker.pack_int(hT.itsObjects['classAttribute'])
            hT.itsPacker.pack_int(Id)
            theDataType = hT.__getDataType__(aValue)
            hT.itsPacker.pack_int(theDataType)
            thePackValue = hT.__packValue__(theDataType, aValue)
            hT.itsPacker.pack_int(theProbeId)
            hT.itsPacker.pack_hyper(theParentTimestamp)        
            hT.itsPacker.pack_int(theCurrentDepth)
            hT.itsPacker.pack_hyper(theCurrentTimestamp)
            hT.itsPacker.pack_int(theThreadId)
            super(MetaDescriptor, self).__setattr__(aName, aValue)
            try:
                hT.itsSocket.sendall(hT.itsPacker.get_buffer())
            except:
                pass    
        

class Descriptor(object):

    def __setattr__(self, aName, aValue):
        import sys
        theFrame = sys._getframe()
        theCode = theFrame.f_back.f_code
        theCurrentLasti = theFrame.f_back.f_lasti
        theCurrentDepth = hT.__getDepthFrame__(theFrame.f_back) + 1
        theCurrentTimestamp = hT.__convertTimestamp__(time.time()) 
        theParentTimestamp = hT.__getTimestampParentFrame__(theFrame)
        theThreadId = hT.__getThreadId__(thread.get_ident())
        theKey = type(self).__name__
        theKey = hT.__getClassKey__(theKey)
        if theKey == None:
            return
        theObject = hT.itsClass[theKey] 
        theObjectId = theObject.__getId__()
        theBehaviorId = hT.__getObjectId__(theCode)
        sys.settrace(None)
        theObject.__addAttribute__(aName, theObjectId)
        Id = theObject.attributes[aName]
        if not hT.itsProbe.has_key((theCurrentLasti,theBehaviorId)):
            theProbeId = hT.__registerProbe__(theCurrentLasti,
                                              theBehaviorId,
                                              theFrame.f_lineno)
        else:
            theProbeId = hT.itsProbe[(theCurrentLasti,theBehaviorId)]          
        if type(aValue) == types.StringType:
            if not id(aValue) in hT.itsRegisterObjects:
                hT.__registerObject__(aValue, theCurrentTimestamp)
                hT.itsPacker.pack_int(hT.itsEvents['set'])
                hT.itsPacker.pack_int(hT.itsObjects['attribute'])
                hT.itsPacker.pack_int(Id)
                try:
                    hT.itsPacker.pack_int(self.__pyTOD__)
                except:
                    object.__setattr__(self, aName, aValue)
                    return
                theDataType = hT.__getDataType__(aValue)
                hT.itsPacker.pack_int(theDataType)
                hT.itsPacker.pack_hyper(id(aValue))
                hT.itsPacker.pack_int(theProbeId)
                hT.itsPacker.pack_hyper(theParentTimestamp)        
                hT.itsPacker.pack_int(theCurrentDepth)
                hT.itsPacker.pack_hyper(theCurrentTimestamp)
                hT.itsPacker.pack_int(theThreadId)
                object.__setattr__(self, aName, aValue)
                try:
                    hT.itsSocket.sendall(hT.itsPacker.get_buffer())
                except:
                    pass   
                sys.settrace(hT.__trace__)
        else:
            hT.itsPacker.reset()
            hT.itsPacker.pack_int(hT.itsEvents['set'])
            hT.itsPacker.pack_int(hT.itsObjects['attribute'])
            hT.itsPacker.pack_int(Id)
            try:
                hT.itsPacker.pack_int(self.__pyTOD__)
            except:
                object.__setattr__(self, aName, aValue)
                return
            theDataType = hT.__getDataType__(aValue)
            hT.itsPacker.pack_int(theDataType)
            thePackValue = hT.__packValue__(theDataType, aValue)
            hT.itsPacker.pack_int(theProbeId)
            hT.itsPacker.pack_hyper(theParentTimestamp)        
            hT.itsPacker.pack_int(theCurrentDepth)
            hT.itsPacker.pack_hyper(theCurrentTimestamp)
            hT.itsPacker.pack_int(theThreadId)
            object.__setattr__(self, aName, aValue)
            try:
                hT.itsSocket.sendall(hT.itsPacker.get_buffer())
            except:
                pass   
            sys.settrace(hT.__trace__)
if th:
    settrace(hT.__trace__)  
sys.settrace(hT.__trace__)
\end{lstlisting}
\end{singlespace}

	\section{Código fuente de generatorId.py}
	

\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = "Milton Inostroza Aguilera"
__email__ = "minoztro@gmail.com"
__all__ = ['generatorId']

class generatorId(object):
    
    def __init__(self):
        self.Id = 101

    def __get__(self):
        return self.Id

    def __next__(self):
        self.Id = self.Id + 1
        return 
\end{lstlisting}
\end{singlespace}

	\section{Código fuente de Dictionary.py}

\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = "Milton Inostroza Aguilera"
__email__ = "minoztro@gmail.com"
__all__ = ['Dictionary']

import xdrlib
import inspect
import re

class Dictionary(dict):
    
    def __init__(self, hT):
        self.hT = hT
        dict.__init__(self)

    def __setitem__(self, aKey, aValue):
        dict.__setitem__(self,aKey,aValue)

    def __update__(self, aDictionary, aParentId, aArgument):
        for theKey, theValue in aDictionary.items():
            if theKey in aArgument:
                #variable local ya registrada ya que es un argumento
                self[theKey] = theValue
                return
            if not self.has_key(theKey):
                if not theKey == 'self':
                    self[theKey] = theValue
                    self.hT.itsPacker.reset()
                    self.hT.itsPacker.pack_int(self.hT.itsEvents['register'])
                    self.hT.itsPacker.pack_int(self.hT.itsObjects['local'])
                    self.hT.itsPacker.pack_int(theValue)
                    self.hT.itsPacker.pack_int(aParentId)
                    self.hT.itsPacker.pack_string(theKey)
                    if self.hT.FLAG_DEBUGG:
                        print self.hT.itsEvents['register'],
                        print self.hT.itsObjects['local'],
                        print theValue,
                        print aParentId,
                        print theKey
                        raw_input()
                    try:
                        self.hT.itsSocket.sendall(self.hT.itsPacker.get_buffer())
                    except:
                        pass
                    

    def __updateAttr__(self, aDictionary, aParentId): 
        for theKey, theValue in aDictionary.items():
            if not self.has_key(theKey):
                if not theKey == 'self':
                    theId = self.hT.itsId.__get__()
                    self.hT.itsId.__next__()
                    self[theKey] = theId
                    self.hT.itsPacker.reset()
                    self.hT.itsPacker.pack_int(self.hT.itsEvents['register'])
                    self.hT.itsPacker.pack_int(self.hT.itsObjects['attribute'])
                    self.hT.itsPacker.pack_int(theId)
                    self.hT.itsPacker.pack_int(aParentId)
                    self.hT.itsPacker.pack_string(theKey)
                    if self.hT.FLAG_DEBUGG:
                        print self.hT.itsEvents['register'],
                        print self.hT.itsObjects['attribute'],
                        print theId,
                        print aParentId,
                        print theKey 
                        raw_input()                          
                    try:       
                        self.hT.itsSocket.sendall(self.hT.itsPacker.get_buffer())
                    except:
                        pass

    def __updateStaticField__(self, aDictionary, aParentId): 
        for theKey, theValue in aDictionary.items():
            if not inspect.isfunction(theValue) and not theKey == 'self':
                if not re.search(self.hT.itsMethodPattern,theKey):
                    if not self.has_key(theKey):
                        theValue = self.hT.itsId.__get__()
                        self.hT.itsId.__next__()
                        self[theKey] = theValue
                        self.hT.itsPacker.reset()
                        self.hT.itsPacker.pack_int(
                            self.hT.itsEvents['register'])
                        self.hT.itsPacker.pack_int(
                            self.hT.itsObjects['classAttribute'])
                        self.hT.itsPacker.pack_int(theValue)
                        self.hT.itsPacker.pack_int(aParentId)
                        self.hT.itsPacker.pack_string(theKey)
                        if self.hT.FLAG_DEBUGG:
                            print self.hT.itsEvents['register'],
                            print self.hT.itsObjects['classAttribute'],
                            print theValue,
                            print aParentId,
                            print theKey 
                            raw_input()                          
                        try:       
                            self.hT.itsSocket.sendall(
                                self.hT.itsPacker.get_buffer())
                            pass
                        except:
                            pass
\end{lstlisting}
\end{singlespace}

	\section{Código fuente de constantsObjects}

\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = "Milton Inostroza Aguilera"
__email__ = "minoztro@gmail.com"
__all__ = ['events','objects', 'dataTypes','packXDRLib']


events = {
          'register':0,
          'call':1,
          'set':2,
          'return':3,
          'instantiation':4
          }

objects = {
           'class':0,
           'method':1,
           'attribute':2,
           'function':3,
           'local':4,
           'probe':5,
           'thread':6,
           'classAttribute':7,
           'object':8,
           'exception':9,
           'specialMethod':10
           }

dataTypes = {
             int.__name__:0,
             str.__name__:1,
             float.__name__:2,
             long.__name__:3,
             bool.__name__:4,
             tuple.__name__:5,
             list.__name__:6,
             dict.__name__:7
             #other type: 8
             }

packXDRLib = {
              0:'int',
              1:'string',
              2:'float',
              3:'double',
              4:'int', #4:'bool'
              }
\end{lstlisting}
\end{singlespace}

	\section{Código fuente de objectClass}
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = "Milton Inostroza Aguilera"
__email__ = "minoztro@gmail.com"
__all__ = ['Class']

import inspect
import dis
import time
import re
import thread
from Dictionary import Dictionary

class Class(object):

    def __init__(self, aHt, aClassId, aCode, aLnotab):
        self.hT = aHt
        self.staticField = Dictionary(self.hT)
        self.attributes = Dictionary(self.hT)
        self.method = Dictionary(self.hT)
        self.lnotab = aLnotab
        self.code = aCode
        self.name = aCode.co_name
        self.Id = aClassId
        self.SpecialBehaviorId = -1

    def __getId__(self):
        return self.Id

    def __getLnotab__(self):
        return self.lnotab

    def __addMethod__(self, aCode, aLocals):
        for theKey,theValue in aLocals.iteritems():
            if inspect.isfunction(theValue):
                if not (theKey == '__module__'):
                    theId = self.hT.itsId.__get__()
                    self.method.update({theKey:theId})
                    self.hT.itsId.__next__()
    
    def __addSpecialMethod__(self, aFileName):
        if self.method.has_key("%sStaticMethod"%self.name):
            return
        theId = self.hT.itsId.__get__()
        self.method.update({"%sStaticMethod"%self.name:theId})
        self.hT.itsId.__next__()
        self.hT.__registerSpecialMethod__("%sStaticMethod"%self.name,
                                          theId,
                                          self.Id,
                                          aFileName)
        self.SpecialBehaviorId = theId
    
    def __setStaticField__(self,
                           aId,
                           aValue,
                           aFrameLineNo,
                           aCurrentLasti,
                           aParentTimestamp,
                           aDepth):
        theThreadId = self.hT.__getThreadId__(thread.get_ident())
        theCurrentTimestamp = self.hT.__convertTimestamp__(time.time())
        if not self.hT.itsProbe.has_key((aCurrentLasti, self.SpecialBehaviorId)):
            theProbeId = self.hT.__registerProbe__(aCurrentLasti,
                                              self.SpecialBehaviorId,
                                              aFrameLineNo)
        else:
            theProbeId = hT.itsProbe[(aCurrentLasti,aTheSpecialBehaviorId)]
        self.hT.itsPacker.reset()
        self.hT.itsPacker.pack_int(self.hT.itsEvents['set'])
        self.hT.itsPacker.pack_int(self.hT.itsObjects['classAttribute'])
        self.hT.itsPacker.pack_int(aId)
        theDataType = self.hT.__getDataType__(aValue)
        self.hT.itsPacker.pack_int(theDataType)
        thePackValue = self.hT.__packValue__(theDataType, aValue)
        self.hT.itsPacker.pack_int(theProbeId)
        self.hT.itsPacker.pack_hyper(aParentTimestamp)        
        self.hT.itsPacker.pack_int(aDepth)
        self.hT.itsPacker.pack_hyper(theCurrentTimestamp)
        self.hT.itsPacker.pack_int(theThreadId)
        try:
            self.hT.itsSocket.sendall(self.hT.itsPacker.get_buffer())
            pass
        except:
            pass  
    
    def __register_set_StaticField__(self, 
                                     aLocals, 
                                     aFrameLineNo,
                                     aParentTimestamp,
                                     aDepth,
                                     aFileName):
        theLower = 0
        theUpper = len(self.code.co_code)
        theCode = self.code.co_code   
        while theLower < theUpper:
            theOp = ord(theCode[theLower])
            theNameOp = dis.opname[theOp]      
            theLower = theLower + 1
            if theOp >= dis.HAVE_ARGUMENT:
                theValue = ord(theCode[theLower])
                theValue += ord(theCode[theLower+1])*256
                if theNameOp == 'STORE_NAME':
                    theStaticFieldName = self.code.co_names[theValue] 
                    self.staticField.__updateStaticField__(
                                                    {theStaticFieldName:-1}, 
                                                    self.Id)
                    self.__addSpecialMethod__(aFileName)
                    if not re.search(self.hT.itsMethodPattern,theStaticFieldName):
                        if not inspect.isfunction(aLocals[theStaticFieldName]):
                            self.__setStaticField__(
                                                self.staticField[theStaticFieldName], 
                                                aLocals[theStaticFieldName],
                                                aFrameLineNo,
                                                theLower,
                                                aParentTimestamp,
                                                aDepth)
                theLower = theLower + 2
    
    def __addStaticField__(self, aLocals):
        self.staticField.__updateStaticField__(aLocals, self.Id)
    
    def __addAttribute__(self, aName, aObjectId):
        self.attributes.__updateAttr__({aName:-1}, aObjectId)  
\end{lstlisting}
\end{singlespace}

	\section{Código fuente de objectFunction}

\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = "Milton Inostroza Aguilera"
__email__ = "minoztro@gmail.com"
__all__ = ['Function']

from Dictionary import Dictionary

class Function(object):

    def __init__(self, aHt, aId, aCode, aLnotab, aArgs):
        self.hT = aHt
        self.locals = Dictionary(self.hT)
        self.argument = ()
        self.lnotab = aLnotab
        self.code = aCode
        self.name = aCode.co_name
        self.Id = aId
        self.__updateArgument__(aArgs)

    def __getId__(self):
        return self.Id

    def __getLnotab__(self):
        return self.lnotab

    def __getLocals__(self):
        return self.locals

    def __getArgs__(self):
        return self.argument
    
    def __getArgsValues__(self, aLocals):
        argValues = ()
        for name in self.argument:
            if aLocals.has_key(name):
                argValues = argValues + (aLocals[name],)
        return argValues

    def __updateArgument__(self, aArgs):
        for theArg in aArgs:
            if not theArg == 'self':
                self.argument = self.argument + (theArg,)
        theParentId = self.Id            
            
    def __registerLocals__(self, aLocal):
        self.locals.__update__(aLocal,self.Id,self.argument)
\end{lstlisting}
\end{singlespace}

	\section{Código fuente de objectMethod}
	
\begin{singlespace}
\begin{lstlisting}[style=Python]
#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = "Milton Inostroza Aguilera"
__email__ = "minoztro@gmail.com"
__all__ = ['Method']

from Dictionary import Dictionary

class Method(object):

    def __init__(self, aHt, aId, aCode, aLnotab, aIdClass, aArgs):
        self.hT = aHt
        self.locals = Dictionary(self.hT)
        self.argument = ()
        self.lnotab = aLnotab
        self.code = aCode
        self.name = aCode.co_name
        self.idClass = aIdClass
        self.Id = aId
        self.__updateArgument__(aArgs)

    def __getId__(self):
        return self.Id

    def __getLnotab__(self):
        return self.lnotab

    def __getLocals__(self):
        return self.locals

    def __getTarget__(self):
        return self.idClass

    def __getArgs__(self):
        return self.argument
    
    def __getArgsValues__(self, aLocals):
        argValues = ()
        for name in self.argument:
            if aLocals.has_key(name):
                argValues = argValues + (aLocals[name],)
        return argValues

    def __updateArgument__(self, aArgs):
        for theArg in aArgs:
            if not theArg == 'self':
                self.argument += (theArg,)
        theParentId = self.Id
        if self.hT.FLAG_DEBUGG:
            for theIndex in range(len(aArgs)):
                if not aArgs[theIndex] == 'self':
                    print self.hT.itsEvents['register'],
                    print self.hT.itsObjects['local'],
                    print theIndex + 1,
                    print theParentId,
                    print aArgs[theIndex]
                    raw_input() 
                    
    def __registerLocals__(self, aLocal):
        self.locals.__update__(aLocal,self.Id,self.argument)
\end{lstlisting}
\end{singlespace}


	\section{Código fuente de PythonTODServer.java (Interfaz de comunicación con base de datos de TOD)}
	

\begin{singlespace}
\begin{lstlisting}
package pytod.core.server;

import hep.io.xdr.XDRInputStream;

import java.io.IOException;
import java.net.Socket;

import tod.agent.transport.ValueWriter;
import tod.core.ILogCollector;
import tod.core.config.TODConfig;
import tod.core.database.structure.IMutableBehaviorInfo;
import tod.core.database.structure.IMutableClassInfo;
import tod.core.database.structure.IMutableStructureDatabase;
import tod.core.database.structure.ObjectId;
import tod.core.database.structure.IStructureDatabase.LineNumberInfo;
import tod.core.database.structure.IStructureDatabase.LocalVariableInfo;
import tod.core.server.TODServer;

/**
 * A Python TOD server accepts connections from debugged script Python and process instrumentation
 * requests as well as logged events.
 * The actual implementation of the instrumenter and database are left
 * to delegates.
 * @author minostro
 */

public class PythonTODServer extends TODServer
{
  private final IMutableStructureDatabase itsStructureDatabase;
  private final ILogCollector itsLogCollector;

  public PythonTODServer(
      TODConfig aConfig,
      IMutableStructureDatabase aStructureDatabase,
      ILogCollector aLogCollector) 
  {
    super(aConfig);
    itsStructureDatabase = aStructureDatabase;
    itsLogCollector = aLogCollector;
    IMutableClassInfo theClass = itsStructureDatabase.addClass(100, "functionClass");
	}

  @Override
  protected void accepted(Socket aSocket) 
  {
    try
    {
      XDRInputStream theStream = new XDRInputStream(aSocket.getInputStream());
      new Receiver(theStream);
    }
    catch (IOException e)
    {
      throw new RuntimeException(e);
    }
  }
	
  //events
  private static final int REGISTER_EVENT = 0;
  private static final int CALL_EVENT = 1;
  private static final int SET_EVENT = 2;
  private static final int RETURN_EVENT = 3;
  private static final int INSTANTIATION_EVENT = 4;	
  //objects
  private static final int OBJECT_CLASS = 0;
  private static final int OBJECT_METHOD = 1;
  private static final int OBJECT_ATTRIBUTE = 2;
  private static final int OBJECT_FUNCTION = 3;
  private static final int OBJECT_LOCAL = 4;
  private static final int OBJECT_PROBE = 5;
  private static final int OBJECT_THREAD = 6;
  private static final int OBJECT_STATICFIELD = 7;
  private static final int OBJECT_OBJECT = 8;
  private static final int OBJECT_EXCEPTION = 9;
  private static final int OBJECT_SPECIALMETHOD = 10;
  //dataTypes
  private static final int DATA_INT = 0;
  private static final int DATA_STR = 1;
  private static final int DATA_FLOAT = 2;
  private static final int DATA_LONG = 3;
  private static final int DATA_BOOL = 4;
  private static final int DATA_TUPLE = 5;
  private static final int DATA_LIST = 6;
  private static final int DATA_DICT = 7;
  private static final int DATA_OTHER = 8;
	
	
  private class Receiver extends Thread
  {
    private XDRInputStream itsStream;
    public Receiver(XDRInputStream aInputStream)
    {
      super("PythonTODServer.Receiver");
      itsStream = aInputStream;
      start();
    }
	  
    private String generateSignature(int aArgsCount)
    {
      StringBuilder theSignatureBuilder = new StringBuilder("(");
      for(int i=0;i<aArgsCount;i++) theSignatureBuilder.append("Ljava.lang.Object;");
      theSignatureBuilder.append(")Ljava.lang.Object;");
      return theSignatureBuilder.toString();
	  }
  
    public void registerFunction(XDRInputStream aInputStream)
    {
      IMutableClassInfo theClass;
      IMutableBehaviorInfo theBehavior;
      try
      {
	      int theFunctionId = aInputStream.readInt();
	      String theFunctionName = new String(aInputStream.readString());
        int theArgsCount = aInputStream.readInt();
	      theClass = itsStructureDatabase.getClass(100, true);
        theBehavior = theClass.addBehavior(theFunctionId, theFunctionName, generateSignature(theArgsCount), false);
        if (theArgsCount > 0){
          for(int i=0;i<theArgsCount;i=i+1)
          {
            String theArgName = new String(aInputStream.readString());						
            int theArgId = aInputStream.readInt();
            theBehavior.addLocalVariableInfo(new LocalVariableInfo(0, 32000, theArgName, "java.lang.Object", theArgId));
          }
        }
        String theFileName = aInputStream.readString();
        int theCodeSize = aInputStream.readInt();
        int theLineNumbers = aInputStream.readInt();
        int theStartPc = -1;
        int theLineNumber = -1;
        LineNumberInfo[] theLineNumberInfo = new LineNumberInfo[theLineNumbers];
        for (int i = 0; i < theLineNumbers; i++) {
          theStartPc = aInputStream.readInt();
          theLineNumber = aInputStream.readInt();
          theLineNumberInfo[i] = new LineNumberInfo((short) theStartPc, (short) theLineNumber);
        }
        theBehavior.setup(true, null, theCodeSize, theLineNumberInfo, null);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }
		

    public void registerLocal(XDRInputStream aInputStream)
    {
      IMutableBehaviorInfo theBehavior;			
      try
      {
        int theLocalId = aInputStream.readInt();
        int theParentId = aInputStream.readInt();
        String theLocalName = new String(aInputStream.readString());
        theBehavior = itsStructureDatabase.getBehavior(theParentId, true);
        theBehavior.addLocalVariableInfo(new LocalVariableInfo(0, 32000, theLocalName, "java.lang.Object", theLocalId));
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

    public void registerClass(XDRInputStream aInputStream)
    {
      IMutableClassInfo theClass;
      try
      {
        int theClassId = aInputStream.readInt();
        String theClassName = new String(aInputStream.readString());
        int theClassBases = aInputStream.readInt();
        theClass = itsStructureDatabase.addClass(theClassId, theClassName);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

    public void registerStaticField(XDRInputStream aInputStream)
    {
      IMutableClassInfo theClass;
      try
      {
        int theAttributeId = aInputStream.readInt();
        int theParentId = aInputStream.readInt();
        String theAttributeName = new String(aInputStream.readString());	
        theClass = itsStructureDatabase.getClass(theParentId, true);
        theClass.addField(theAttributeId, theAttributeName, null, true);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }	
    }

    public void registerMethod(XDRInputStream aInputStream)
    {
      IMutableClassInfo theClass;
      IMutableBehaviorInfo theBehavior;
      try
      {
        int theMethodId = aInputStream.readInt();
        int theClassId = aInputStream.readInt();
        String theMethodName = aInputStream.readString();
        int theArgsCount = aInputStream.readInt();
        theClass = itsStructureDatabase.getClass(theClassId, true);
        theBehavior = theClass.addBehavior(theMethodId, theMethodName, generateSignature(theArgsCount), false);
        if (theArgsCount > 0){
          for(int i=0;i<theArgsCount;i=i+1)
          {
            String theArgName = aInputStream.readString();
            int theArgId = aInputStream.readInt();
            theBehavior.addLocalVariableInfo(new LocalVariableInfo(0, 32000, theArgName, "java.lang.Object", theArgId));
          }
        }
        String theFileName = aInputStream.readString();
        theBehavior.setSourceFile(theFileName);
        int theCodeSize = aInputStream.readInt();
        int theLineNumbers = aInputStream.readInt();
        int theStartPc = -1;
        int theLineNumber = -1;
        LineNumberInfo[] theLineNumberInfo = new LineNumberInfo[theLineNumbers];
        for (int i = 0; i < theLineNumbers; i++) {
          theStartPc = aInputStream.readInt();
          theLineNumber = aInputStream.readInt();
          theLineNumberInfo[i] = new LineNumberInfo((short) theStartPc, (short) theLineNumber);
        }
        theBehavior.setup(true, null, theCodeSize, theLineNumberInfo, null);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

    public void registerSpecialMethod(XDRInputStream aInputStream)
    {
      IMutableClassInfo theClass;
      IMutableBehaviorInfo theBehavior;
      try
      {
        int theMethodId = aInputStream.readInt();
        int theClassId = aInputStream.readInt();
        String theMethodName = aInputStream.readString();
        theClass = itsStructureDatabase.getClass(theClassId, true);
        theBehavior = theClass.addBehavior(theMethodId, theMethodName, generateSignature(0), false);
        String theFileName = aInputStream.readString();
        theBehavior.setSourceFile(theFileName);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

    public void registerAttribute(XDRInputStream aInputStream)
    {
      IMutableClassInfo theClass;
      try
      {
        int theAttributeId = aInputStream.readInt();
        int theParentId = aInputStream.readInt();
        String theAttributeName = new String(aInputStream.readString());	
        theClass = itsStructureDatabase.getClass(theParentId, true);
        theClass.addField(theAttributeId, theAttributeName, null, true);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

    public void registerProbe(XDRInputStream aInputStream)
    {
      try
      {
        int theProbeId = aInputStream.readInt();
        int theParentId = aInputStream.readInt();				
        int theProbeCurrentLasti = aInputStream.readInt();
        int theCurrentLineno = aInputStream.readInt();
        itsStructureDatabase.addProbe(theProbeId, theParentId, theProbeCurrentLasti, null, 0);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

		
    public void registerThread(XDRInputStream aInputStream)
    {
      try
      {
        int theThreadId = aInputStream.readInt();
        int theSysId = aInputStream.readInt();
        itsLogCollector.thread(theThreadId, theSysId, "()V");
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

    public void registerObject(XDRInputStream aInputStream)
    {
      try
      {
        int theTypeId = aInputStream.readInt();
        long theId = aInputStream.readLong();
        Object theValue = getObjectValue(theTypeId, aInputStream);
        long theCurrentTimestamp = aInputStream.readLong();
        byte[] theByteValue = ValueWriter.serialize(theValue);
        itsLogCollector.register(
            theId,
            theByteValue, 
            theCurrentTimestamp, 
            true);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

    public void registerException(XDRInputStream aInputStream)
    {
      try
      {
        Object theValue = null;
        long theValueId = 0;
        int theTypeId = aInputStream.readInt();
        if (theTypeId == 1) {
          theValueId = aInputStream.readLong();
        }
        else{
          theValue = getObjectValue(theTypeId, aInputStream);					
        }
        int theProbeId = aInputStream.readInt();
        long theParentTimestamp = aInputStream.readLong();
        int theDepth = aInputStream.readInt();
        long theCurrentTimestamp = aInputStream.readLong();
        int theThreadId = aInputStream.readInt();
        itsLogCollector.exception(
            theThreadId, 
            theParentTimestamp,
            (short) theDepth, 
            theCurrentTimestamp, 
            null, 
            theProbeId, 
            theTypeId == 1 ? new ObjectId(theValueId) : theValue);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }
    }

    public void instantiationEvent(XDRInputStream aInputStream)
    {
      Object args[] = null;
      try
      {
        int theBehaviorId = aInputStream.readInt();
        int theTargetId = aInputStream.readInt();
        int theArgsCount = aInputStream.readInt();
        if (theArgsCount > 0){
          args = new Object[theArgsCount];
          for(int i=0;i<theArgsCount;i=i+1)
          {
            int theArgType = aInputStream.readInt();
            if (theArgType == 1) {
              long theValueId = aInputStream.readLong();
              args[i] = new ObjectId(theValueId);
            } 
            else {
              Object theValue = getObjectValue(theArgType, aInputStream);
              args[i] = theValue;
            }
          }
        }
        int theProbeId = aInputStream.readInt();
        long theParentTimestamp = aInputStream.readLong();
        int theDepth = aInputStream.readInt();
        long theCurrentTimestamp = aInputStream.readLong();
        int theThreadId = aInputStream.readInt();
        itsLogCollector.instantiation(
            theThreadId,
            theParentTimestamp,
            (short)theDepth, 
            theCurrentTimestamp, 
            null,
            theProbeId,
            true, 
            -1,
            theBehaviorId,
            new ObjectId(theTargetId),
            args);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }
    }

    public void methodCall(XDRInputStream aInputStream)
    {
      Object theArgs[] = null;
      try
      {
        int theMethodId = aInputStream.readInt();
        int theTargetId = aInputStream.readInt();
        int theArgsCount = aInputStream.readInt();
        if (theArgsCount > 0){
          theArgs = new Object[theArgsCount];
          for(int i=0;i<theArgsCount;i=i+1)
          {
            int theArgType = aInputStream.readInt();
            if (theArgType == 1) {
              long theValueId = aInputStream.readLong();
              theArgs[i] = new ObjectId(theValueId);
            } 
            else {
              Object theValue = getObjectValue(theArgType, aInputStream);
              theArgs[i] = theValue;
            }
          }
        }
        int theProbeId = aInputStream.readInt();
        long theParentTimestamp = aInputStream.readLong();
        int theDepth = aInputStream.readInt();
        long theCurrentTimestamp = aInputStream.readLong();
        int theThreadId = aInputStream.readInt();
        itsLogCollector.methodCall(
            theThreadId,
            theParentTimestamp,
            (short)theDepth, 
            theCurrentTimestamp, 
            null,
            theProbeId,
            true, 
            -1,
            theMethodId,
            new ObjectId(theTargetId),
            theArgs);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }
    }

    public void functionCall(XDRInputStream aInputStream)
    {
      Object theArgs[] = null;
      try
      {
        int theFunctionId = aInputStream.readInt();
        int theArgsCount = aInputStream.readInt();
        if (theArgsCount > 0){
          theArgs = new Object[theArgsCount];
          for(int i=0;i<theArgsCount;i=i+1)
          {
            int theArgType = aInputStream.readInt();
            if (theArgType == 1) {
              long theValueId = aInputStream.readLong();
              theArgs[i] = new ObjectId(theValueId);
          } else {
              Object theValue = getObjectValue(theArgType, aInputStream);
              theArgs[i] = theValue;
            }
          }
        }
        int theProbeId = aInputStream.readInt();
        long theParentTimestamp = aInputStream.readLong();
        int theDepth = aInputStream.readInt();
        long theCurrentTimestamp = aInputStream.readLong();
        int theThreadId = aInputStream.readInt();
        itsLogCollector.methodCall(
            theThreadId,
            theParentTimestamp,
            (short)theDepth, 
            theCurrentTimestamp, 
            null,
            theProbeId,
            false, 
            -1,
            theFunctionId,
            null,
            theArgs);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }
    }

    public Object getObjectValue(int aTypeId, XDRInputStream aInputStream)
    {
        try {
        Object theValue;
        switch (aTypeId) {
        case DATA_INT:
        {
          theValue = aInputStream.readInt();
          break;
        }
        case DATA_STR:
        {
          theValue = aInputStream.readString();
          break;
        }
        case DATA_FLOAT:
        {
          theValue = aInputStream.readFloat();
          break;
        }
        case DATA_LONG:
        {
          theValue = aInputStream.readLong();
          break;
        }
        case DATA_BOOL:
        {
          theValue = aInputStream.readInt();
          if (theValue.equals(1)) {
            theValue = Boolean.TRUE;
          }
          else {
            theValue = Boolean.FALSE;
          }
          break;
        }
        case DATA_TUPLE:
        {
          theValue = aInputStream.readInt();
          break;
        }
        case DATA_LIST:
        {
          theValue = aInputStream.readInt();
          break;
        }
        case DATA_DICT:
        {
          theValue = aInputStream.readInt();
          break;
        }
        case DATA_OTHER:
        {
          theValue = aInputStream.readInt();
          break;
        }
        default:
          theValue = aInputStream.readInt();					
          break;
        }
        return theValue;
      } 
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }
    }
		
		

    public void setStaticField(XDRInputStream aInputStream)
    {
      try
      {
        Object theValue = null;
        long theValueId = 0;
        int theStaticFieldId = aInputStream.readInt();
        int theTypeId = aInputStream.readInt();
        if (theTypeId == 1) {
          theValueId = aInputStream.readLong();
        } else {
          theValue = getObjectValue(theTypeId, aInputStream);
        }
        int theProbeId = aInputStream.readInt();
        long theParentTimestampFrame = aInputStream.readLong();
        int theDepth = aInputStream.readInt();
        long theCurrentTimestamp = aInputStream.readLong();
        int theThreadId = aInputStream.readInt();
        itsLogCollector.fieldWrite(
            theThreadId, 
            theParentTimestampFrame, 
            (short)theDepth, 
            theCurrentTimestamp, 
            null, 
            theProbeId, 
            theStaticFieldId, 
            null, 
            theTypeId == 1 ? new ObjectId(theValueId) : theValue);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

		
    public void setAttribute(XDRInputStream aInputStream)
    {
      try
      {
        Object theValue = null;
        long theValueId = 0;
        int attributeId = aInputStream.readInt();
        int targetId = aInputStream.readInt();
        int theTypeId = aInputStream.readInt();
        if (theTypeId == 1) {
          theValueId = aInputStream.readLong();
        } else {
          theValue = getObjectValue(theTypeId, aInputStream);
        }
        int probeId = aInputStream.readInt();
        long parentTimeStampFrame = aInputStream.readLong();
        int depth = aInputStream.readInt();
        long currentTimeStamp = aInputStream.readLong();
        int threadId = aInputStream.readInt();
        itsLogCollector.fieldWrite(
            threadId, 
            parentTimeStampFrame, 
            (short)depth, 
            currentTimeStamp, 
            null, 
            probeId, 
            attributeId, 
            new ObjectId(targetId), 
            theTypeId == 1 ? new ObjectId(theValueId) : theValue);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

		
		
    public void setLocal(XDRInputStream aInputStream)
    {
      try
      {
        Object theValue = null;
        long theValueId = 0;
        int theLocalId = aInputStream.readInt();
        int theParentId = aInputStream.readInt();
        int theTypeId = aInputStream.readInt();
        if (theTypeId == 1) {
          theValueId = aInputStream.readLong();
        } else {
          theValue = getObjectValue(theTypeId, aInputStream);
        }
        int theProbeId = aInputStream.readInt();
        long theParentTimestamp = aInputStream.readLong();
        int theDepth = aInputStream.readInt();
        long theCurrentTimestamp = aInputStream.readLong();
        int theThreadId = aInputStream.readInt();				
        itsLogCollector.localWrite(
            theThreadId,
            theParentTimestamp, 
            (short)theDepth, 
            theCurrentTimestamp, 
            null, 
            theProbeId, 
            theLocalId, 
            theTypeId == 1 ? new ObjectId(theValueId) : theValue);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }			
    }

		
    public void returnEvent(XDRInputStream aInputStream)
    {
      try
      {
        long theValueId = 0;
        Object theValue = null;
        int theBehaviorId = aInputStream.readInt();
        int typeId = aInputStream.readInt();
        if (typeId == 1) {
          theValueId = aInputStream.readInt() & 0xffffffffL;
        }
        else{
          theValue = getObjectValue(typeId, aInputStream);					
        }
        int theHasThrown = aInputStream.readInt();
        int theProbeId = aInputStream.readInt();
        long theParentTimestamp = aInputStream.readLong();
        int theDepth = aInputStream.readInt();
        long theCurrentTimestamp = aInputStream.readLong();
        int theThreadId = aInputStream.readInt();
        itsLogCollector.behaviorExit(
            theThreadId, 
            theParentTimestamp, 
            (short)theDepth, 
            theCurrentTimestamp, 
            null,
            theProbeId, 
            theBehaviorId,
            theHasThrown == 1? true : false,
            typeId == 1 ? new ObjectId(theValueId) : theValue);
      }
      catch (Exception e)
      {
        throw new RuntimeException(e);
      }
    }

		
    @Override
    public void run()
    {
      try
      {
        while (true)
        {
          int theEvent = itsStream.readInt();
          switch (theEvent)
          {
          case REGISTER_EVENT:
          {
            int theObject = itsStream.readInt();
            switch(theObject)
            {
            case OBJECT_CLASS:
              registerClass(itsStream);
              break;
            case OBJECT_METHOD:
              registerMethod(itsStream);
              break;
            case OBJECT_ATTRIBUTE:
              registerAttribute(itsStream);						
              break;
            case OBJECT_FUNCTION:
              registerFunction(itsStream);
              break;
            case OBJECT_LOCAL:
              registerLocal(itsStream);
              break;
            case OBJECT_PROBE:
              registerProbe(itsStream);
              break;
            case OBJECT_THREAD:
              registerThread(itsStream);
              break;
            case OBJECT_STATICFIELD:
              registerStaticField(itsStream);
              break;
            case OBJECT_OBJECT:
              registerObject(itsStream);
              break;
            case OBJECT_EXCEPTION:
              registerException(itsStream);
              break;
            case OBJECT_SPECIALMETHOD:
              registerSpecialMethod(itsStream);
              break;
            default:
              break;
            }	
          }
          break;
          case CALL_EVENT:
          {
            int theObject = itsStream.readInt();
            switch (theObject)
            {
            case OBJECT_METHOD:
              methodCall(itsStream);
              break;
            case OBJECT_FUNCTION:
              functionCall(itsStream);
              break;
            default:
              break;
            }
          }
          break;
          case SET_EVENT:
          {
            int theObject = itsStream.readInt();
            switch (theObject)
            {
            case OBJECT_STATICFIELD:
              setStaticField(itsStream);
              break;
            case OBJECT_ATTRIBUTE:
              setAttribute(itsStream);
              break;
            case OBJECT_LOCAL:
              setLocal(itsStream);
              break;
            default:
              break;
            }
          }
          break;	
          case RETURN_EVENT:
            returnEvent(itsStream);
            break;
          case INSTANTIATION_EVENT:
            instantiationEvent(itsStream);
            break;
          default:
            break;
          }
        }
      }
      catch (IOException e)
      {
        itsLogCollector.flush();
        throw new RuntimeException(e);
      }
    }	
  }
}
\end{lstlisting}
\end{singlespace}

\end{document}
